# MSA 테스트 전략

- 옛날 방식의 테스트는 보통 개발을 마친 다음 이어지는 활동으로, QA 팀은 개발자가 제출한 코드를 넘겨받아 잘 동작하는지를 손으로 일일이  
  눌러보며 테스트를 했다. 하지만 이런 식의 테스트는 아래의 2개 이유 때문에 결국 난관에 봉착하게 된다.

  - 수동 테스트는 비효율의 극치다.
  - 테스트가 너무 늦다.

- MSA를 도입하는 중요한 계기 중 하나는 테스트성(testability)를 개선하는 것이다. MSA 특유의 복잡성 때문이라도 테스트는 반드시 자동화해야  
  한다. 많은 서비스를 시동하는 느리고 복잡하고 신뢰할 수 없는 e2e 테스트 개수를 최소화하는 동시에 많은 서비스가 정확히 상호 작용하는지  
  확인해야 하기 때문이다.

- 기존 애플리케이션 중 주문 서비스를 변경할 일이 발생했다고 해보자. 당연히 고친 코드가 잘 작동되는지 직접 실행해봐야 할 것이다.  
  주문 서비스와 이 서비스가 의존성을 갖는 DB 등의 인프라, 다른 서비스들을 모두 실행한 상태에서 API를 호출하거나 화면에서 마우스를 직접  
  클릭하며 서비스를 "테스트"할 것이다. 그러나 이런 방식의 테스트는 일단 속도가 느리고, 번거로운 수작업이 동반된다는 치명적인 단점이 있다.

- 이를 위해 개발 도중 실행 가능한 자동화 테스트를 작성하는 것이 훨씬 낫다. 테스트는 빨리 실행되기에 개발자는 변경한 코드가 잘 작동되는지를  
  수초 내로 알 수 있다.

- 이번 장에서는 빨리 실행되는 테스트를 작성하려면 어떻게 해야 하는지, 이런 테스트를 작성하면 그것으로 충분한지, 아니면 조금 더 종합적인  
  테스트가 필요한지 등의 내용을 다룬다.

## 테스트 개요

- 여기서는 앞으로 자동화 테스트를 간단히 테스트 라고 표현할 것이다. 아래는 Wikipedia에 있는 test case의 정의이다.

> Test case: 어떤 목표(ex. 프로그램이 특정 경로를 실행하는지, 지정된 요건에 부합하는지)를 달성하기 위해 개발된 테스트 입력, 실행 조건, 기대 결과의 집합.

- 즉 테스트의 목적은 SUT(System Under Test, 테스트 대상 시스템)의 동작을 확인하는 것이다.

  ![picture 35](/images/MSAP_9_1.png)

- 여기서 _시스템_ 이란 테스트해야 할 소프트웨어 element를 가리키는 용어이다. 클래스 수준의 작은 단위나 전체 애플리케이션 만큼 큰 단위일 수도  
  있고, 여러 클래스나 개별 서비스처럼 중간 규모의 단위일 수도 있다. 그리고 test suite는 서로 연관된 테스트들을 모아놓은 것이다.

### 자동화 테스트 작성

- 자동화 테스트는 대부분 JUnit 등의 테스트 프레임워크로 작성한다. 테스트 클래스에 속한 테스트 메소드가 바로 하나의 테스트이다.

  ![picture 36](/images/MSAP_9_2.png)

- 자동화 테스트는 아래의 4개 단계로 구성된다.

  - (1) 설정: SUT와 그의 의존성들로 구성된 test fixture를 초기화한다.
  - (2) 실행: SUT 호출
  - (3) 확인: 호출 결과 및 SUT의 상태를 단언(assert)한다.
  - (4) 정리: 필요 시 test fixture를 깨끗이 정리한다.

- 코드 중복을 줄이고 테스트를 단순화하기 위해 테스트 메소드 이전에 실행되는 설정 메소드, 테스트 이후 실행되는 정리 메소드를 테스트 클래스에  
  따로 둘 수 있다. 이렇게 작성한 테스트는 test runner로 실행한다.

### Mock/Stub을 이용한 테스트

- SUT는 대부분 외부 의존성을 가지며 이러한 의존성 때문에 테스트가 복잡하고 느려질 수 있다. 가령 `OrderController`가 있고, 이 클래스는  
  `OrderService`를 호출하고, `OrderService`도 다른 수많은 애플리케이션/인프라 서비스에 의존한다 해보자. 이 경우 `OrderController`만을  
  테스트하기 위해 시스템 대부분을 가동해야 한다면 현실성이 없을 것이다. SUT만 따로 테스트할 방법은 없을까?

- 해결 방법은 의존성 시스템들을 test double로 대체하는 것이다. Test double은 의존성 시스템의 동작을 흉내낸 객체를 의미한다.

  ![picture 37](/images/MSAP_9_3.png)

- Test double은 stub, mock의 2개 종류로 나뉜다.

  - Stub: SUT에 값을 반환하는 test double
  - Mock: SUT가 정확히 의존성 시스템을 호출했는지 확인하는 test double
    > Mock은 stub의 일종이다.

### 테스트 종류

![picture 38](/images/MSAP_9_4.png)

- 테스트 피라미드의 핵심: 상부로 올라갈 수록 작성하는 테스트 개수가 줄어든다. 즉 단위 테스트는 많이, e2e 테스트는 적게 작성해야 한다.

---
