# 리액티브 애플리케이션과 DB

> Spring Boot를 사용하면 JVM이 있는 어디든 배포할 수 있다.

- 데이터를 데이터베이스에 넣기 전에, 먼저 리액티브 프로그래밍의 핵심 요건을 이해해야 한다.  
  리액티브 프로그래밍을 사용하려면 모든 과정이 리액티브여야 한다.

- 웹 컨트롤러를 리액티브 방식으로 동작하게 만들고, 서비스 계층도 리액티브 방식으로 만들었는데  
  블로킹 방식으로 연결되는 데이터베이스를 호출하면 리액티브는 무너진다. 블로킹 방식으로 데이터베이스를  
  호출한 스레드는 응답을 받을 때까지 다른 작업을 하지 못한 채 기다려야 한다.  
  리액터 기반 애플리케이션은 많은 수의 스레드를 가지고 있지 않으므로(필요도 없다) 데이터베이스 호출 후  
  블로킹되는 스레드가 많아지면 스레드가 모두 고갈돼서 결국 전체 애플리케이션이 데이터베이스로부터 결과를  
  기다리면서 아무런 일도 할 수 없는 상태가 되어 망가지게 된다.

- 이런 레거시 블로킹 코드를 따로 감싸고 격리해서 문제를 해결할 수도 있지만, 이렇게 하면 리액티브의  
  장점을 잃게 된다.

- 리액티브 프로그래밍과 관련해 흔히 떠올리는 선입견 중 하나는 *리액티브가 태생적으로 빠르다*는 주장이다.  
  이는 물론 사실이 아니다. 작업을 수행하는 단일 스레드의 처리 속도 기준으로 보면, 리액티브 프로그래밍은  
  여러 가지 오버헤드를 수반하므로 성능 저하가 발생한다.

- 작업량을 대규모로 늘려야하는 상황이 아니라면, 리액티브 방식의 오버헤드로 인해 시스템은 오히려 더  
  느리게 동작할 수 있다.

- 리액티브가 태생적으로 빠를 수 밖에 없다는 선입견과 오히려 리액티브가 더 느리다는 현실은 서로  
  상충되는 것처럼 보인다. 사례를 통해 어떤 일이 일어나는지 알아보자.

- 똑같은 화물을 나른다 해도, 소형차와 대형 트럭은 차이가 있다. 대형 트럭이 소형차보다 훨씬 많은  
  화물을 실어 나를 수 있는 것은 분명하지만, 주행 속도는 그다지 빠르지 않다. 트럭이 화물 운송의  
  주요 수단으로 사용되는 이유는 속도가 빠른 소형차보다 더 많은 양의 화물을 실어 나를 수 있기 때문이다.

- 물건 하나만 나르는 데 트럭을 사용하는 것은 되려 엄청난 낭비다. 트럭은 운송량이 크다는게 장점이므로  
  트럭에 화물을 가득 실어야 트럭의 장점을 활용할 수 있게 된다.

- 리액티브 프로그래밍도 마찬가지다. 사용자 수가 작고, 데이터도 많지 않다면 불필요한 오버헤드를  
  감수하면서 리액티브를 사용하는 것은 낭비다.

- 하지만 웹애서 대규모의 트래픽이 발생하고, 백엔드에서 대용량의 데이터를 처리하는 환경에서는  
  리액티브 프로그래밍의 장점이 빛을 발하게 된다. 즉 리액티브 프로그래밍에서 스레드는 어떤 작업이  
  끝날 때까지 블로킹되어 기다리지 않고 다른 작업을 수행할 수 있다.

- 리액티브 런타임은 요청과 응답을 조율해서 시스템 자원이 허용하는 한도 내에서 스레드 사용을 극대화한다.  
  Spring Data Project의 리드인 Mark Paluch는 이를 _시스템 자원 가용성에 반응한다_ 고 표현한다.

- 따라서 리액티브가 제대로 동작하려면 데이터베이스도 마찬가지로 리액티브하게 동작해야 한다.  
  그렇지 않으면 앞서 말한 것처럼 블로킹으로 인해 시스템은 결국 멈춰버릴 것이다. 마치 큰 트럭으로  
  많은 화물을 나르는 것은 좋지만, 그 트럭으로 접점마다 모두 들려서 하나하나 화물을 배송하면  
  엄청난 비효율이 초래되는 것과 비슷하다.

- 그렇다면 이제 어떤 데이터베이스가 리액티브 패러다임을 지원하는지 살펴보자.

  - MongoDB
  - Redis(Lettuce Driver와 함께 사용 시)
  - Apache Cassandra
  - ElasticSearch
  - Neo4j
  - CouchBase

- 선택의 폭이 아주 넓지는 않다. 최신 조사에 따르면 실무에 사용되는 데이터베이스의 80%가 RDBMS라 한다.  
  하지만 앞서 본 데이터베이스에는 RDBMS가 하나도 없다. 이유가 뭘까?

- 이유는 간단한데, Java에서 RDBMS를 사용할 때 어떤 기술들이 사용되는 지 살펴보자.

  - JDBC
  - JPA
  - Jdbi
  - jOOQ

- 이 외에도 RDBMS를 사용할 수 있게 해주는 도구가 더 있겠지만, 그 대부분은 이와 같이 가장 널리 사용되는  
  4가지 기술을 좀 더 쓰기 편하게 감싼 것들이다. 결국 JPA와 JDBC에는 어떤 문제가 있길래 이를 기반으로  
  연결되어 사용되는 RDBMS가 리액티브 애플리케이션에서 사용되지 못할지 알아야 한다.

- JPA와 JDBC는 블로킹 API다. 트랜잭션을 시작하는 메시지를 전송하고, 쿼리를 포함하는 메시지를 전송하고,  
  결과가 나올 때 클라이언트에게 스트리밍해주는 개념 자체가 없다. 모든 데이터베이스 호출은 응답을 받을 때까지  
  블로킹되어야 한다.

- JDBC나 JPA를 감싸서 리액티브 스트림 계층에서 사용할 수 있게 해주는 반쪽짜리 솔루션도 있긴 하지만,  
  이런 솔루션은 일반적으로 숨겨진 내부 스레드 풀을 사용해서 동작한다.

- 내부 스레드 풀을 사용하는 것이 어떻게 문제일까? **장비의 코어 수보다 많은 스레드를 사용하는 것은 장점이**  
  **거의 없다.** 4코어 장비면 4개의 스레드로 구성된 스레드 풀을 사용하는 것이 좋다. 만약 이 4코어 장비에  
  100개의 스레드를 만들어 사용한다면 CPU Context Switching 오버헤드가 증가하고, 효율이 급격히 떨어진다.

- 실제로 비동기, 논블로킹 방식으로 동작하는 단일 스레드 애플리케이션이 블로킹 방식으로 동작하면서 스레드 100개를  
  사용하는 애플리케이션보다 처리량이 높게 나온다는 사실은 JS 진영에서도 이미 입증되고 있다.

- JPA 같은 블로킹 API 앞에 스레드 풀을 두고, 여러 스레드를 사용하는 방식은 일반적으로 포화 지점에 도달하게 된다.  
  이 지점을 지나면 스레드 풀은 새 요청이 들어와도 받아서 처리할 스레드가 없으므로 스레드 풀 자체도 블로킹된다.  
  리액티브 프로그래밍에서 모든 것은 리액티브해야 하며, 일부라도 리액티브하지 않고 블로킹된다면 애플리케이션이 제대로  
  동작하지 않는다.

- 100% 리액티브 애플리케이션을 만들려면 데이터베이스와의 물리적 연결과 상호 작용 과정에 비동기, 논블로킹 개념을  
  적용할 수 있는 데이터베이스 드라이버가 필요하다. 앞서 나열한 리액티브 지원 데이터베이스는 모두 비동기, 논블로킹을  
  지원하는 데이터베이스 드라이버를 가지고 있다.
