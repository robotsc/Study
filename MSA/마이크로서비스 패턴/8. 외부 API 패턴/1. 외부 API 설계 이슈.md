# 외부 API 설계 이슈

- 모놀리틱 애플리케이션은 애플리케이션 등의 클라이언트가 호출하는 API가 그 자체로 노출되지만, MSA로 배포하면 서비스마다 각각의 API를 가지기에  
  어떤 종류의 API를 클라이언트에 표출해야 할지 결정해야 한다. 그렇다면 클라이언트가 어떤 서비스가 있는지를 직접 파악해서 원하는 서비스에 요청을 보내야 할까?

- 애플리케이션의 외부 API는 클라이언트가 다양한 만큼 설계하기 어렵다. 성격이 다른 클라이언트마다 다른 종류의 데이터를 요구하기도 할 것이다.  
  예를 들어 방화벽 내부의 클라이언트는 고성능 LAN을 사용해 접속하지만, 방화벽 외부의 클라이언트는 성능이 낮은 인터넷이나 모바일 네트워크를 통해  
  들어온다. 따라서 _만능_ API 같은 것은 없다.

- 이번 장에서는 우선 다양한 외부 API 설계 이슈를 살펴보고, 두 가지 외부 API 패턴(API Gateway, BFF) 및 각각의 설계, 구현 방식을 살펴보자.

- 아래는 우리가 설계하는 애플리케이션의 서비스 API를 소비하는 4가지의 클라이언트이다.

  ![picture 28](/images/MSAP_8_1.png)

- 웹 애플리케이션은 방화벽 내부에서 실행되기에 대역폭이 높고 latency가 짧은 LAN을 통해 서비스에 접속하지만, 그 외의 다른 클라이언트들은 방화벽  
  외부에 있으므로 상대적으로 대역폭이 낮고 latency가 높은 인터넷 또는 모바일 네트워크 환경에서 서비스에 접근한다.

- 클라이언트가 서비스를 직접 호출하도록 API를 설계할 수 있다. 아주 직관적이며 모놀리틱 애플리케이션의 API를 클라이언트가 단순히 호출하는 방식과  
  동일하다. 그러나 이런 방식은 MSA에서는 아래의 단점들 때문에 거의 사용되지 않는다.

  - 서비스 API가 잘게 나뉘어 있어 클라이언트가 필요한 데이터를 가져오려면 여러 번 요청을 해야 하고, 그만큼 효율과 UX가 나빠진다.
  - 클라이언트가 서비스 및 API를 알아야 하는 구조이기에 캡슐화가 되지 않고, 이후 아키텍쳐와 API를 바꾸기도 어렵다.
  - 클라이언트(특히 방화벽 외부의 클라이언트)가 사용하기에 불편하거나 실용적이지 못한 IPC를 서비스에서 사용 중인 경우가 있다.

## API 설계 이슈: 모바일 클라이언트

- 소비자가 모바일 클라이언트에 접속해 주문을 하고 이력을 관리한다 해보자. 그리고 주문 상태, 지불 상태, 음식점 관점에서의 주문 상태 등의  
  기본적인 주문 정보와 배달 중인 경우 현재 배달원의 위치 및 배달 시간 등의 배달 관련 상태를 한 눈에 볼 수 있는 주문 조회 view가 있다.

- 모놀리틱 버전에서는 주문 내역을 반환하는 API endpoint가 있어 모바일 클라이언트가 원하는 정보를 요청 한 번으로 모두 가져오도록 할 수 있지만,  
  MSA 버전은 주문 데이터가 아래와 같이 여러 서비스에 분산되어 있다.

  - 주문 서비스: 기본 주문 정보(주문 내역, 주문 상태 등)
  - 주방 서비스: 음식점 관점에서 본 주문 상태 및 픽업 준비를 마칠 예상 시간
  - 배달 서비스: 주문 배달 상태, 예상 배달 시간, 현재 위치
  - 회계 서비스: 주문 지불 상태

- 모바일 클라이언트가 서비스를 직접 호출하는 구조로 되어 있다면, 아래 그림과 같이 서비스를 여러 번 호출해 데이터를 가져올 수 밖에 없다.

  ![picture 29](/images/MSAP_8_2.png)

- 위 구조대로라면 API 조합기 역할을 모바일 앱 자체가 맡게 된 것이다. 이렇게 설계하는 것도 그리 나빠 보이진 않지만, 몇 가지 심각한 문제점들을 갖고 있다.

### 클라이언트가 요청을 여러 번 하기에 UX가 나빠진다.

- 모바일 앱은 사용자에게 보여줄 데이터를 여러 번 요청해 가져와야 한다. 특히 인터넷 또는 모바일 네트워크로 접속하는 클라이언트의 애플리케이션과  
  서비스 간의 상호 작용이 너무 자주 발생하면 애플리케이션이 느린 것처럼 보일 수 있다. 인터넷은 LAN보다 대역폭이 훨씬 낮고 latency가 길다.  
  모바일 네트워크는 더하다. 일반적으로 모바일 네트워크의 latency가 LAN보다 100배는 더 길다.

- 모바일 애플리케이션은 동시에 요청을 실행해 latency를 최소화하기 때문에 주문 내역을 조회할 때 더 높은 latency가 문제가 되지 않을 수도 있다.  
  전체 응답 시간이 요청 하나의 응답 시간보다 길지 않기 때문이다. 하지만 클라이언트가 요청을 순차적으로 실행할 수 밖에 없는 상황이라면 UX가  
  형편없이 나빠질 것이다.

### 캡슐화가 되지 않아 클라이언트와 서버의 코드가 강결합된다.

- 캡슐화가 되지 않는 것도 문제다. 애플리케이션이 발전함에 따라 서비스 개발자는 기존 클라이언트와 호환되지 않는 변경을 해야 할 일이 생긴다.  
  시스템을 여러 서비스로 분해하는 체계를 건드려야 할 수도 있고, 서비스를 새로 추가하거나 기존 서비스를 병합해야 할 때도 있다.  
  이런 상황에서 서비스에 대한 지식이 모바일 애플리케이션에 포함되어 있으면 서비스 API를 변경하기가 아주 곤란해질 수 있다.

- 서버 쪽 애플리케이션과 달리 모바일 애플리케이션은 새로운 버전을 출시하는 데 몇 시간, 심지어 몇 일도 걸린다. 그리고 app store, play store에  
  애플리케이션을 배포해도 모든 사용자가 바로 업그레이드를 하진 않는다. 끝까지 자신의 기기에 설치된 버전을 고수하는 사람도 있을 것인데,  
  이런 사용자들에게 업데이트를 강요하면 역효과가 날 것이다.

- 이렇게 서비스 API를 모바일에 표출시키는 전략이 API를 발전시키는 데 중대한 걸림돌이 될 수 있다.

### 클라이언트에게 익숙하지 않은 IPC를 사용 중인 서비스가 있을 수 있다.

- 클라이언트가 소비하기 어려운 프로토콜을 사용하는 서비스도 있다. 방화벽 외부에서 동착하는 클라이언트 애플리케이션들은 대부분 HTTP, WebSocket  
  등의 프로토콜을 쓰지만, HTTP 외에도 서비스 개발자가 선택할 수 있는 프로토콜의 종류는 정말 많다. gRPC 기반의 서비스도 있을 것이고, AMQP와  
  같은 messaging 프로토콜을 쓰는 서비스도 있을 것이다. 이런 종류의 프로토콜은 내부에서는 잘 동작하지만 모바일 클라이언트가 소비하기 어려운  
  경우가 많다. 추가적으로 방화벽에 친화적이지 않은 프로토콜들도 있다.

---

## API 설계 이슈: 다른 종류의 클라이언트들

- 위에서 모바일 클라이언트를 예로 들어 서비스에 직접 접근하는 클라이언트들의 단점을 보았지만, 모바일 클라이언트 뿐만 아니라 방화벽 외부에 있는  
  다른 종류의 클라이언트도 마찬가지로 해당된다. 브라우저 기반의 Javascript 웹 애플리케이션, 3rd party 애플리케이션, 웹 애플리케이션과  
  같은 클라이언트들은 어떤 API 설계 이슈가 있을까?

### 웹 애플리케이션

- 전통적인 서버 측 웹 애플리케이션은 브라우저에서 HTTP 요청을 받아 HTML 페이지를 반환하며, 방화벽 내부에서 실행되고 LAN을 통해 서비스에  
  접근한다. 웹 애플리케이션의 경우, API 조합 로직을 구현하는 데 있어 네트워크 대역폭과 latency는 장애물이 아니다. 사실 웹 애플리케이션은  
  웹에 친화적이지 않은 프로토콜로도 서비스에 접근할 수 있다. 따라서 사실 크게 문제될 거리는 없다.

### 브라우저 기반의 Javascript 애플리케이션

- 요즘 브라우저 애플리케이션들은 Javascript를 많이 사용한다. 서버 측 웹 애플리케이션은 주로 HTML을 생성하지만, 서비스를 호출하는 주체는  
  대부분 브라우저에서 실행되는 Javascript 코드이다. 가령 소비자 웹 애플리케이션은 서비스 API를 호출하는 Javascript로 주문 내역 페이지를  
  동적으로 refresh한다.

- 브라우저 기반의 Javascript 애플리케이션은 서비스 API 변경 시 업데이트하기는 쉽지만, 모바일 애플리케이션 처럼 인터넷을 통해 서비스에 접근하기에  
  네트워크 latency 문제는 별반 다를게 없다.

- 그런데 보통 일반적인 모바일 애플리케이션보다 더 정교한 브라우저 기반의 UI는 더 많은 정보를 표현할 공간이 있기에 그만큼 더 많은 서비스를 조합해야  
  하는 경우가 많다. 따라서 인터넷으로 웹 애플리케이션에 접속한 소비자들은 서비스 API를 효율적으로 조합하기 어려울 것이다.

### 3rd party 애플리케이션

- 때에 따라 3rd party 개발자용 API를 제공할 수도 있다. 외부 개발자들은 이 API를 사용해 자신이 필요한 기능을 만들 수 있다.  
  이런 3rd party 애플리케이션들은 인터넷을 통해 접속하기 때문에 API 조합이 비효율적일 가능성이 크지만, API 조합의 비효율성은 3rd party  
  애플리케이션용 API를 설계하는 데 드는 비용에 비하면 비교적 사소한 문제이다. 3rd party 사용자들에게는 안정된 API를 제공해야 하기 때문이다.

- 3rd party 애플리케이션을 위한 API들은 하위 호환성을 잘 보장해야 하고, 경쟁사에게 지지 않기 위해 안정하게 API를 제공해야 한다.  
  따라서 어쩌면 영원히 구 버전의 API를 유지해야 하는 경우도 있다.

---
