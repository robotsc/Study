# 모듈, 패키지, 임포트

- 최신 프로그래밍 언어는 namespace나 라이브러리로 코드를 구성하기 위한 시스템을 갖고 있고, Go도 예외는 아니다.  
  다른 기능을 살펴보면서 봤듯이 Go는 이 오랜 아이디어에 대한 몇 가지 새로운 접근 방식을 소개한다.  
  이번에는 패키지와 모듈로 코드를 구성해 가져오는 import 방법, 3rd-party 라이브러리와 동작하는 방법, 그리고 자신만의  
  라이브러리를 만드는 방법을 살펴보자.

## 저장소, 모듈, 패키지

- Go에서 라이브러리 관리는 저장소, 모듈, 패키지라는 개념에 기반한다. 저장소는 모든 개발자에게 익숙한 것으로, 프로젝트를 위한 소스코드가 저장된  
  VCS의 공간이다. 모듈은 저장소에 저장된 Go 라이브러리나 응용 프로그램의 최상위 루트이다. 모듈은 모듈 구성 및 구조를 제공하는 하나 이상의 패키지로  
  구성되어 있다.

> 저장소에 하나 이상의 모듈을 저장할 수는 있지만, 권장되지는 않는다. 모듈 내에 있는 모든 것은 함께 버전 지정이 되기 때문이다.  
> 하나의 저장소에 두 개 이상의 모듈을 관리한다는 것은 단일 저장소에 다른 두 개 이상의 프로젝트를 위한 분리된 버전을 만들어야함을 의미한다.

- 표쥰 라이브러리의 외부 패키지에서 가져온 코드를 사용하기 전에, 우리의 프로젝트가 모듈로 선언되었는지 확인할 필요가 있다.  
  모든 모듈은 전역적으로 유일한 식별자를 가지고 있어야 한다. 이는 Go에서만 적용되는 사항은 아닌데, 예를 들어 Java는 `com.organization.library`와  
  같이 전역적으로 유일한 패키지명을 사용한다.

- 보통 Go에서는 모듈이 있는 곳의 모듈 저장소 경로를 사용한다. 예를 들어, Go에서 RDBMS의 접근을 간소화하는 Proteus라는 모듈은 Github에서 볼 수 있다.

---

## `go.mod`

- Go 소스 코드의 컬렉션은 해당 루트 디렉토리에 유효한 `go.mod` 파일이 있을 때 모듈이 된다. 해당 파일을 수동으로 생성하는 것보다, 모듈을 관리하기 위한  
  `go mod` 명령의 하위 명령어를 사용하는 것이 좋다. `go mod init $MODULE_PATH` 명령어는 현재 디렉토리를 모듈의 root로 만드는 `go.mod`  
  파일을 생성한다. `MODULE_PATH`는 해당 모듈을 식별하기 위한 전역적으로 유일한 이름이다. 모듈 경로는 대소문자를 구분하며, 혼선을 줄이기 위해  
  대문자를 사용하지 않는다.

- 아래는 `go.mod` 파일의 간단한 내용이다.

```mod
module github.com/daangn/minimemcached

go 1.15

require (
	github.com/benbjohnson/clock v1.3.0
	github.com/bradfitz/gomemcache v0.0.0-20220106215444-fb4bf637b56d
	github.com/rs/zerolog v1.26.1
)
```

- 모든 `go.mod` 파일은 module이라는 단어와 모듈의 유일한 경로로 구성되는 module 선언으로 시작된다. 다음으로는 Go의 최소 호환 버전을 지정하고,  
  마지막으로 require 섹션에 해당 모듈이 의존하는 다른 모듈과 각 모듈에 필요한 최소 버전이 나열된다. 만약 모듈이 다른 어떠한 모듈에도 의존하지 않는다면  
  require 섹션은 생략할 수 있다.

- 추가적으로 두 가지 선택적 섹션이 있는데, replace 섹션은 의존성 있는 모듈이 있는 위치를 재정의할 수 있고, exclude 섹션은 특정 버전의 모듈의  
  사용을 막을 수 있다.

---

## 패키지 빌드

- 위에서 코드의 디렉토리를 모듈로 만드는 방법을 봤으니, 이제는 코드를 구성하기 위해 패키지를 사용해보도록 하자.  
  import 문이 동작하는 방법을 시작으로 패키지를 생성하고 구성한 다음, Go의 기능 중 몇 가지를 장단점과 함께 살펴보도록 하자.

### import, export

- Go의 import문은 다른 패키지에서 노출(export)된 상수, 변수, 함수, 타입을 접근할 수 있도록 한다. 패키지의 export된 식별자는 import문  
  없이는 다른 패키지에서 접근할 수 없다. 그렇다면 Go에서 식별자를 노출시키는 방법은 무엇일까? 특별한 키워드를 사용하기 보단, Go에서는 패키지 레벨  
  식별자를 선언된 패키지 외부에서 보여지도록 하기 위해 **대문자**를 사용한다. 이름이 대문자로 시작되는 식별자는 export되는 것이다.  
  반대로 이름이 소문자로 시작하거나 `_`로 시작하는 식별자는 선언된 패키지 내에서만 접근 가능하다.

- Export된 모든 것은 패키지 API의 일부이다. 식별자를 노출시키기 전, 클라이언트에게 이를 노출하는 것을 의도한 것인지 확인해봐야 한다.  
  노출된 모든 식별자는 문서화하고 의도적으로 주요 버전을 변경하지 않는 한 이전 버전과의 호환을 유지해야 한다.

### 패키지 생성 및 접근

- Go에서 패키지를 만드는 방법은 매우 쉬운데, 이를 시연하는 작은 프로그램을 먼저 살펴보자.

- 우선 프로젝트 루트에 있는 math 디렉토리에는 아래와 같은 `math.go` 파일이 있다.

```go
package math

func Double(a int) int {
	return a*2
}
```

- 위 파일에서 첫 번째 라인을 **package clause(패키지 절)** 라 한다. package 키워드와 패키지명으로 구성되며, package clause는 Go 소스  
  파일에서 비어 있지 않고, 주석이 아닌 첫 번째 라인이다.

- 프로젝트 루트에 있는 다른 폴더인 formatter 디렉토리의 하위에는 `formatter.go` 파일이 있다.

```go
package print

import "fmt"

func Format(num int) string {
	return fmt.Sprintf("The number is %d", num)
}
```

- Package clause에서 패키지명이 print라고 되어 있지만, formatter 디렉토리의 하위에 있다는 점을 유의하자. 이는 후에 더 자세히 다룰 것이다.

- 마지막으로 아래 코드는 루트 디렉토리에 있는 `main.go` 파일이다.

```go
package main

import (
	"fmt"
	"github.com/learning-go-book/package_example/formatter"
	"github.com/learning-go-book/pacakge_example/math"
)

func main() {
	num := math.Double(2)
	output := print.Format(num)
	fmt.Println(output)
}
```

- 해당 파일의 첫 번째 라인은 많이 본 것일 텐데, 패키지명이 main이라고 선언되어 있다. 잠시 뒤에 이것이 의미하는 바를 살펴보자.

- import 부분을 보면 총 3개의 패키지를 가져왔음을 알 수 있다. 첫 번째는 표준 라이브러리에 있는 `fmt`이고, 다음 두 개는 해당 프로그램에 있는  
  패키지를 참조한 것이다. 표준 라이브러리를 제외한 다른 모든 곳에서 가져오는 경우에는 **import path** 를 반드시 지정해야 한다.  
  Import path는 모듈에 있는 패키지 경로를 모듈 경로에 추가해 만들어진다.

- 패키지에서 노출된 어떠한 식별자도 사용하지 않는다면 패키지를 import로 가져오는 것은 컴파일 오류를 발생시킨다. 이는 Go 컴파일러가 만들어내는  
  바이너리는 프로그램에서 실제 사용되는 코드만 포함한다는 것을 보장한다.

> 동일한 모듈 내에 있는 의존 패키지는 상대 경로를 통해 가져올 수 있지만, 그렇게 하지 않도록 하자. 절대 경로는 가져오려는 것을 명확하게 하고  
> 코드 리팩토링을 쉽게 할 수 있도록 한다. 반면 상대 경로로 가져온 파일이 다른 패키지로 옮겨졌을 때, import 문은 반드시 수정되어야 하고, 해당 파일이  
> 완전히 다른 모듈로 옮겨진다면 import 참조는 절대 경로로 만드시 수정되어야 한다.

- 위에서 `main.go`에 있는 `main()` 함수에서는 `github.com/learning-go-book/package_example/formatter` 의 경로로 모듈을 가져와  
  `print` 패키지의 `Format()` 함수를 호출했다. 경로와 모듈명이 다르기 때문에 `print.Format()`의 `print` 패키지가 어느 모듈에서 온 것인지  
  알게 어렵다.

- 디렉토리에 있는 모든 Go 파일은 동일한 package clause를 가져야 한다. 여기서는 `github.com/learning-go-book/package_example/formatter`  
  경로의 모듈에서 `print` 패키지를 가져왔다. 이는 import path가 아니라 package clause에 의해 패키지명으로 결정되기 때문이다.

- 위와 같은 혼란을 방지하기 위해 패키지를 포함하는 디렉토리명과 일치하는 패키지명을 만들도록 하자. 포함하는 디렉토리와 이름이 다르다면 패키지명으로  
  찾아내기 어려울 수 있다. 하지만 디렉토리와 패키지명을 다르게 사용해야 하는 몇 가지 상황이 있다.

  - 첫 번째는 특별한 패키지명인 `main`을 사용해 Go 응용 프로그램의 시작점으로 패키지를 선언할 때이다. `main` 패키지는 import가 불가하기 때문에  
    혼란스러운 import문을 생성하지 않는다.

  - 다른 상황은 덜 일반적인데, 디렉토리명에 Go 식별자로 유효하지 않은 문자를 포함한다면 어쩔 수 없이 디렉토리명과 다른 패키지명을 선택해야 한다.  
    이는 애초에 유효하지 않은 디렉토리명을 사용하지 않는 것으로 방지하는 것이 좋다.

  - 마지막 상황은 디렉토리를 사용해 버전 관리를 하는 경우이다. 이후에 조금 더 다뤄보자.

- 패키지명은 파일 블록 내에 있다. 같은 패키지 내에 두 개의 다른 파일에서 같은 패키지를 사용하는 경우, 두 파일 모두 해당 패키지를 가져와야 한다.

### 패키지명 짓기

- 패키지 내의 항목을 참조하는 데 사용되는 이름의 일부로 패키지명을 갖는 것은 몇 가지 의미가 있다.  
  첫 번째로 패키지명은 설명적이어야 한다. `util` 이라는 패키지명을 갖는 것보다 패키지가 제공하는 기능을 설명하는 패키지명을 생성하자.  
  예를 들어, 2개의 헬퍼 함수가 있다 해보자. 하나는 문자열에서 모든 이름을 추출하고 다른 하나는 알맞게 formatting을 수행하는 것이다.  
  이 두 함수를 `util` 패키지에 `ExtractName()`, `FormatName()`으로 만들지 않도록 하자. 이렇게 한다면 이 함수를 사용할 때마다  
  `util.ExtractName()`와 `util.FormatName()`로 참조해야 할 것이고, 여기서 `util` 패키지는 해당 함수가 하는 일에 대해 아무것도  
  알려 주지 않는다.

- 하나는 `extract`라 불리는 패키지에 `Names()`라는 함수를 생성하고, 다른 하나는 `format` 패키지에 `Names()`라는 함수를 만드는 것이 더  
  좋을 것이다. 패키지명으로 명확하게 구분이 되기 때문에 두 함수명이 같더라도 문제가 없다. 이렇게 하면 참조할 때 `extract.Names()`,  
  `format.Names()`가 될 것이다.

- 또한 패키지 내에 함수 및 타입의 이름에서 패키지의 이름을 반복하지 않도록 하자. 위의 예를 계속해 `extract` 패키지에 `ExtractNames()`라고  
  함수명을 지으면 같은 의미가 불필요하게 중복된다. 식별자의 이름이 패키지명과 같은 경우에는 해당 규칙에서 예외로 한다. 예를 들어, 표준 라이브러리의  
  `sort` 패키지는 `Sort()`라는 함수를 갖고 있고, `context` 패키지는 `Context`라는 인터페이스를 정의한다.

### 모듈을 구성하는 방법

- 모듈에서 Go 패키지를 구성하는 공식적인 방법은 없지만, 몇 년에 걸쳐 몇 가지 패턴들이 나타났다. 이들은 코드를 쉽게 이해하고 유지 보수할 수  
  있도록 만드는 데 집중해야 한다는 원칙에 따라 만들어졌다. 모듈이 작을 때는 모든 코드를 단일 패키지에 유지하도록 하자. 자신의 모듈에 의존하는  
  다른 모듈이 없는 한, 구성을 지연하더라도 아무런 해가 없다.

- 프로젝트가 성장함에 따라 코드의 가독성을 높이기 위해 몇 가지 순서를 지정하고 싶을 것이다. 모듈이 하나 이상의 응용 프로그램으로 구성되었다면,  
  모듈의 루트 디렉토리에 cmd라는 디렉토리를 만들자. cmd 디렉토리 내에서는 모듈에서 생성하는 각 바이너리에 대해 하나의 디렉토리를 만든다.  
  예를 들어, 모듈이 웹 응용 프로그램과 웹 응용 프로그램의 데이터베이스에 데이터를 분석하는 CLI 도구를 갖고 있다고 해보자. 각 디렉토리 내에서  
  패키지명으로 main을 사용하면 된다.

- 만약 모듈의 루트 디렉토리에 testing 관리 및 프로젝트의 배포를 위한 많은 파일들이 포함된다면, 모든 Go 코드를 pkg라는 디렉토리 하위에  
  넣도록 하자.

- pkg 디렉토리 내에서 패키지 간 의존성을 제한하도록 코드를 구성하자. 한 가지 일반적인 패턴은 기능의 조각별로 코드를 구성하는 것이다.  
  예를 들어 Go로 쇼핑 사이트를 작성한다면, 하나의 패키지 내에 고객 관리를 위한 모든 코드를 둘 것이고, 다른 곳에는 재고를 관리하기 위한  
  모든 코드를 둘 것이다. 이런 스타일은 패키지 간의 의존성을 제한하므로 나중에 단일 웹 응용 프로그램을 마이크로 서비스로 쉽게 리팩토링할 수  
  있을 것이다.

### 패키지명 재정의

- 때로는 중복된 이름의 두 패키지를 가져와야 하는 경우가 있다. 예를 들어, 표준 라이브러리는 난수를 생성하기 위한 두 개의 패키지를 가진다.  
  하나는 `crypto/rand`이고 다른 하나는 `math/rand`이다. 이 둘을 모두 사용해야 한다면 어떻게 해야 할까? 패키지명에 충돌이 나지 않도록  
  import하는 파일 내에서 하나의 패키지에 대체 이름을 부여해야 한다.

```go
import (
	crand "crypto/rand"
	"encoding/binary"
	"fmt"
	"math/rand"
)

func seedRand() *rand.Rand {
	var b [8]byte
	_, err := crand.Read(b[:])
	if err != nil {
		panic("cannot seed with cryptographic random number generator")
	}
	r := rand.New(rand.NewSource(int64(binary.LittleEndian.Uint64(b[:]))))
	return r
}
```

- 위 코드를 보면 `crypto/rand`를 crand라는 이름으로 가져왔고, 즉 패키지 내에 선언된 rand라는 이름을 재정의했다.  
  `seedRand()` 함수를 보면 `math/rand` 내의 식별자에 접근할 때는 `rand` 접두사를 사용하고, `crypto/rand` 패키지의 것을  
  접근할 때는 접두사로 `crand`를 사용하는 것을 볼 수 있다.

- Shadowing 변수와 마찬가지로 패키지명도 shadowing될 수 있다. 패키지와 이름이 같은 변수, 타입 혹은 함수를 선언하면 해당 선언이 있는  
  블록 내에서 패키지에 접근할 수 없게 된다. 만약 이를 피할 수 없다면, 충돌을 해결하기 위해 패키지명을 재정의하도록 하자.

### 패키지 주석, godoc

- Go는 자동적으로 문서로 변환해주는 주석을 작성하기 위한 Go만의 포맷, godoc을 가진다.  
  godoc 주석에는 특별한 심볼이 없고, 단지 관례에 따라 진행된다. 규칙은 아래와 같다.

  - 항목의 선언과 주석 사이에 빈 줄이 없이 문서화가 될 항목 바로 전에 주석을 작성한다.
  - 두 개의 슬래시(`//`)와 항목의 이름으로 주석을 시작한다.
  - 여러 단락으로 주석을 나누기 위해서는 빈 주석 라인을 사용한다.
  - 라인을 들여쓰기 해 미리 서식이 지정된 주석을 추가할 수 있다.

- 패키지 선언 전에 주석은 패키지 레벨의 주석을 생성한다. 패키지를 위한 긴 주석을 작성해야 한다면, 패키지 내에 있는 `doc.go`라는 파일에 주석을  
  넣는 것이 관례이다.

- 주석이 잘 작성된 파일을 살펴보도록 하자. 우선 아래의 패키지 레벨 주석으로 시작해보자.

```go
// Package money provides various utilities to make it easy to manage money.
package money
```

- 아래는 노출된 구조체에 대한 주석 작성 예시이다.  
  해당 주석은 구조체의 이름으로 시작한다.

```go
// Money represents the combination of an amount of money
// and the currency the money is in.
type Money struct {
	Value    decimal.Decimal
	Currency string
}
```

- 마지막으로 함수의 주석이다.

```go
// Convert converts the value of one currency to another.
//
// It has two parameters: a Money instance with the value to convert,
// and a string that represents the currency to convert to. Convert returns
// the converted currency and any errors encountered from unknown or unconvertible
// currencies.
// If an error is returned, the Money instance is set to the zero value.
//
// Supported currencies are:
// 	USD = US Dollar
// 	CAD - Canadian Dollar
// 	EUR = Euro
// 	INR - Indian Rupee
//
// More information on exchange rates can be found
// at https://www.investopedia.com/terms/e/exchangerates.asp
func Convert(from Money, to string) (Money, error) {
	//..
}
```

- Go는 godoc을 보여주는 `go doc` CLI 도구를 포함한다. 명령어 `go doc $PACKAGE_NAME`은 지정된 패키지를 위한 패키지 godoc과  
  패키지의 식별자 목록을 보여준다. 패키지의 특정 식별자를 위한 문서를 출력하려면 `go doc $PACKAGE_NAME.$IDENTIFIER_NAME`을 사용하자.

### 내부 패키지

- 때로는 모듈에서 패키지 간에 함수, 타입, 상수를 공유하고 싶지만 이들이 API의 일부가 되게는 하고 싶지 않는 경우가 있다.  
  Go는 특별한 패키지명 internal을 통해 이를 지원한다.

- internal이라는 패키지를 생성할 때, 패키지와 해당 하위 패키지의 노출된 식별자는 internal의 바로 상위 부모 패키지와 internal과 같은  
  레벨의 디렉토리에서만 접근이 가능하다. 예시를 보자. 디렉토리 구조는 아래와 같다.

```
|- bar(directory)
|   |- bar.go
|- example.go
|- foo(directory)
|   |- foo.go
|   |- internal(directory)
|   |   |- internal.go
|   |- sibling(directory)
|   |   |- sibling.go
|- go.mod
```

- 아래는 internal 패키지 내의 `interal.go`의 내용이다.

```go
func Doubler(a int) int {
	return a*2
}
```

- 이런 상황이라면 foo 패키지의 `foo.go` 그리고 siblings 패키지의 `sibling.go`에서 해당 함수에 접근할 수 있다.

- 만약 bar 패키지의 `bar.go`나 루트 패키지에 있는 `example.go`에서 internal 패키지에 있는 함수를 사용하려 하면, 컴파일 오류가 발생한다.

### `init()`: 가능하면 피하자

- Go 코드를 읽을 때, 어떤 메소드나 함수가 실행되고 언제 호출이 되는지는 대체로 명확하다. Go에서 메소드나 함수의 overriding을 허용하지 않는  
  여러 이유 중 하나는 코드가 무엇을 수행하는지 이해하기 쉽도록 하기 위함이다. 하지만 명시적으로 아무것도 하지 않아도 패키지에서 상태를 설정하기  
  위한 방법으로 `init()` 함수를 사용할 수 있다. 어떠한 파라미터도 받지 않고 반환되는 값이 없는 `init()` 함수를 선언하면, 다른 패키지에서  
  패키지가 처음 참조되는 순간 수행된다. `init()`은 어떠한 입력과 출력도 갖지 않기 때문에, 패키지 레벨 함수나 변수와 상호작용하는 범위에서만  
  동작한다.

- `init()`은 다른 독특한 기능이 있다. Go는 단일 패키지 내에서 `init()` 함수를 여럿 선언할 수 있도록 한다. 단일 패키지에 있는 여려 개의  
  `init()` 함수는 작성된 순서대로 실행되지만, 이를 기억하는 것 보다는 아예 사용하지 않는 것이 낫다.

- 데이터베이스 드라이버와 같은 패키지에서는 데이터베이스 드라이버를 등록하기 위해 `init()`을 사용한다. 하지만 패키지 내에 있는 어떠한 식별자도  
  사용하지 않는다. 위에서 봤듯이 Go는 사용되지 않는 패키지를 import하는 것을 허용하지 않는다. 이를 해결하기 위해 Go는 import하는 패키지 앞에  
  `_`를 이름으로 할당해 blank input(공백 가져오기)을 허용한다. `_`는 함수에서 사용되지 않는 반환값을 문제없이 넘기기 위해 사용한 것처럼,  
  black input은 패키지에서 `init()`을 수행하지만 패키지에 노출된 식별자에 대한 접근은 허용하지 않는다.

```go
import (
	"database/sql"

	_ "github.com/lib/pq"
)
```

- 이런 패턴은 등록 작업이 수행되고 있는지가 명확하지 않기 때문에 더 이상 사용하지 않는 것으로 간주된다.

- 최근 `init()`의 주요 사용처는 단일 할당에서 설정될 수 없는 패키지 레벨의 변수를 초기화하는 경우이다. 데이터가 응용 프로그램을 통해 흐르는  
  방식을 이해하기 어렵게 만들기 때문에, 패키지의 최상위 레벨에서 변경 가능한 상태를 만드는 것은 좋지 않은 선택이다. 즉, `init()`을 통해  
  어떤 패키지 레벨의 변수를 설정하는 것은 _효과적으로 변경할 수 없다_ 는 것이다. Go는 값을 변경할 수 없도록 강제하는 기능을 제공하지 않기에  
  코드가 직접 변경을 불가하게 만들어야 한다. 프로그램이 수행되는 동안 수정되어야 하는 패키지 레벨 변수가 있는 경우, 코드를 리팩토링해 패키지 내에서  
  함수로 초기화하고 반환되는 구조체에 해당 상태를 넣을 수 있는지 확인하자.

- `init()`에 대한 몇 가지 주의점이 있다. Go에서 여러 `init()`의 선언을 허용하더라도, 패키지 당 하나의 `init()` 만을 선언하도록 하자.  
  `init()`이 파일을 로드하거나 네트워크에 접근하는 경우, 코드 사용자를 위해 해당 동작을 문서화하도록 하자.

### 순환 의존성

- Go의 목표 중 두 개는 빠른 컴파일러, 그리고 코드를 쉽게 이해하도록 하는 것이다. 이를 지원하기 위해 Go는 패키지들 간에 순환 의존성을 갖는 것을  
  허용하지 않는다.

- 만약 순환 의존성을 스스로 발견했다면, 아래의 조언을 참고하자.

  - 어떤 경우, 순환 의존성은 패키지를 너무 작게 나눠 발생한 것이다. 두 패키지가 서로 의존한다면, 단일 패키지로 합쳐질 수 있도록 고민해보자.
  - 분리된 패키지로 유지해야 하는 합당한 이유가 있다면, 순환 의존성을 유발하는 항목만 두 패키지 중 하나로 통합하거나 새로운 패키지로 이동시키자.

### API명을 우아하게 바꾸고 재구성하기

- 한동안 모듈을 사용하다보면 해당 API가 이상적이지 않음을 깨닫게 된다. Export된 식별자들 일부의 이름을 바꾸고 싶거나 그들을 모듈 내의 다른  
  패키지로 이동시키고 싶을 수도 있을 것이다. 기존 호환성을 깨는 변경을 피하기 위해, 원본 식별자를 제거하는 대신 대체 이름을 제공하자.

- 함수나 메소드는 이를 구현하기 쉽다. 원본을 호출하는 함수나 메소드를 선언하고, 상수의 경우라면 단순히 같은 타입과 같은 값이지만 이름이 다른  
  새로운 상수를 선언하면 된다. 아래의 상황을 보자.

```go
type Foo struct {
	x int
	S string
}

func (f Foo) Hello() string {
	return "hello"
}

func (f Foo) goodbye() string {
	return "goodbye"
}
```

- 만약 `Foo`의 이름을 `Bar`로 바꾸고 싶다면, 아래처럼 동일한 타입의 새로운 이름을 제공하면 된다.

```go
type Bar = Foo
```

- 별칭을 생성하기 위해서는 type 키워드를 사용하면 된다.  
  별칭은 타입 변환 없이 원본 타입의 변수에 할당될 수도 있다.

```go
func MakeBar() Bar {
	bar := Bar{
		x: 20,
		S: "hello",
	}
	var f Foo = bar
	fmt.Println(f.Hello())
	return bar
}
```

- 한가지 중요한 점은 **별칭은 단지 타입을 위한 다른 이름에 불과하다** 는 것이다.  
  별칭 구조체의 항목을 변경하거나 새로운 메소드를 추가하려면 원본 타입에 대해 수해앻야 한다.

- 원본 타입으로 같은 패키지나 다른 패키지 내에 정의된 타입의 변칭을 지정할 수 있다. 다른 모듈에 있는 타입도 별칭을 지정할 수 있다.  
  다른 패키지의 별칭 지정은 단점이 있는데, 원본 타입의 노출되지 않은 메소드와 항목을 참조하기 위해 별칭을 사용할 수 없다는 것이다.  
  패키지의 API를 점진적으로 변경할 수 있도록 별칭이 존재하고 API는 패키지의 노출된 일부로 구성되므로 해당 제한은 의미가 있다.  
  이 제한을 해결하기 위해 노출되지 않은 항목과 메소드를 제어하기 위해 타입의 원본 패키지 내에서 코드를 호출하는 것이 좋다.

- 대체 이름을 가질 수 없는 export된 식별자 두 가지가 있다. 하나는 패키지 레벨 함수이고, 다른 하나는 구조체의 항목이다.  
  일단 export된 구조체 항목을 위한 이름을 선택한다면, 더 이상 대체 이름을 생성할 수 있는 방법이 없다.

---

## 모듈 관련 작업

### 3rd-party 코드 가져오기

- 지금까지는 `fmt`, `errors`, `os`, `math` 등의 표준 라이브러리에서 패키지를 가져오는 방법을 보았다. Go는 3rd-party의 패키지를  
  통합하기 위해서도 동일한 import 시스템을 사용한다. 다른 많은 컴파일 언어와는 달리, Go는 응용 프로그램을 위한 3rd-party에서 가져온  
  코드와 본인이 작성한 코드 모두를 컴파일해 단일 바이너리로 만든다. 자신의 프로젝트 내에 있는 패키지를 가져올 때 봤듯이, 3rd-party  
  패키지를 가져올 때는 패키지가 있는 소스 코드 저장소의 위치를 지정하면 된다.

- 예를 보도록 하자.

```go
package main

import (
	"fmt"
	"log"
	"os"

	"github.com/learning-go-book/formatter"
	"github.com/shopspring/decimal"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Need two parameters: amount and percent")
		os.Exit(1)
	}

	amount, err := decimal.NewFromString(os.Args[1])
	if err != nil {
		log.Fatal(err)
	}

	percent, err := decimal.NewFromString(os.Args[2])
	if err != nil {
		log.Fatal(err)
	}

	percent = percent.Div(decimal.NewFromInt(100))
	total := amount.Add(amount.Mul(percent)).Round(2)
	fmt.Println(formatter.Space(80, os.Args[1], os.Args[2], total.StringFixed(2)))
}
```

- 가져온 두 개의 모듈 `github.com/learning-go-book/formatter`와 `ithub.com/shopspring/decimal`는 모두 3rd-party  
  모듈이다. 해당 모듈은 저장소의 위치를 포함시킨다는 것을 기억하자. 일단 가져오면, 다른 가져온 패키지들과 같이 해당 패키지의 export된  
  항목들에 접근할 수 있다.

- 빌드 전 `go.mod` 파일은 다음과 같다.

```mod
module PlaygroundGo

go 1.17
```

- 빌드 후 변경된 `go.mod` 파일은 아래와 같다.

```mod
module PlaygroundGo

go 1.17

require (
	github.com/learning-go-book/formatter v0.0.0-20200921021027-5abc380940ae
	github.com/shopspring/decimal v1.3.1
)
```

- 의존성이 필요한 go 명령(`go run`, `go build`, `go test`, `go list` 등)들을 실행할 때마다 `go.mod`에는 아직 기록되지 않은  
  import 모듈이 캐시에 다운로드된다. `go.mod` 파일은 모듈의 버전과 패키지를 포함하는 모듈 경로를 포함하면 자동으로 업데이트 된다.  
  반면 `go.sum` 파일은 2개 항목이 업데이트 되는데, 하나는 모듈과 모듈의 버전, 그리고 모듈의 해시이고 다른 하나는 모듈을 위한 `go.mod`의  
  해시다.

### 버전 작업

- 기본적으로 Go는 모듈을 프로젝트에 추가하면, 해당 모듈의 최신 버전을 사용한다. 하지만 모듈의 이전 버전도 선택할 수 있다는 점이 버전 관리를  
  유용하게 만든다. 아래와 같이 `go list`를 통해 모듈의 어떤 버전이 사용 가능한지 볼 수 있다.

```
go list -m -versions github.com/daangn/minimemcached
github.com/daangn/minimemcached v1.0.0 v1.0.1 v1.1.0
```

- `go list`는 프로젝트에 사용된 패키지들을 나열한다. `-m` 플래그는 패키지 대신에 모듈을 나열하도록 변경하고, `-version` 플래그는 `go list`가  
  지정된 모듈의 가능한 버전을 보고하도록 변경한다. 위 경우에는 v1.0.0, v1.0.1, v1.1.0의 3개 버전을 볼 수 있다. 만약 현재 버전이 v1.1.0  
  이었는데 v1.0.0으로 버전을 낮추고 싶다면 `go get`을 사용해 이를 수행할 수 있다.

```
go get github.com/daangn/minimemcached@v1.0.0
```

- `go get` 명령어는 모듈과 관련된 작업과 의존성 업데이트를 할 수 있도록 한다.  
  위 명령어를 수행하고 `go.mod`를 보면, 해당 모듈의 버전이 변경되어 있음을 확인할 수 있다.  
  반면 `go.sum`에는 2개 버전 모두 기록되어 있다. 모듈의 버전을 변경하거나 프로젝트에서 해당 모듈을 지운다고 해도 `go.sum`에는 해당 모듈에  
  대한 내용이 들어있을 것이다. 하지만 이는 어떤 문제도 일으키지 않는다.

### 최소 버전 선택

- 어떤 지점에서는 프로젝트가 같은 모듈에 의존하는 2개 이상의 모듈에 의존성을 가질 수 있다. 이런 상황이 발생하면, 해당 모듈의 다른 minor  
  버전이나 patch 버전에 의존한다고 선언한다. Go에서는 이를 어떻게 할까?

- 모듈 시스템은 최소 버전 선택의 원칙을 사용한다. 즉 `go.mod`에서 기록되어 가져오게 될 선언된 의존성들을 만족할 수 있는 가장 낮은 버전을 가져오도록  
  한다는 것이다. 예를 들어, 우리가 작성한 모듈이 직접적으로 A, B, C 모듈에 의존한다고 해보자. 해당 3개 모듈은 모두 모듈 D에 의존하고 있다.  
  모듈 A의 `go.mod`는 D@v1.1.0에 의존한다고 써있고 B는 D@v1.2.0, C는 D@v1.2.3에 의존한다고 써있다고 해보자.  
  이런 상황에서 Go는 모듈 D를 단 한 번만 가져올 것이고, 가장 최근에 지정된 버전인 v1.2.3을 선택할 것이다.

- 하지만 가끔은 모듈 D의 v1.1.0과는 동작하지만, v1.2.3과는 동작하지 않을 수도 있다. 이럴 때는 어떻게 해야 할까?  
  Go의 대답은 _"해당 모듈의 작성자에게 연락해 호환성 수정을 요청해야 한다."_ 이다. 이런 import 호환성 규칙은 모든 minor 버전 번호와  
  patch 버전 번호가 하위 호환성을 유지하도록 하기 때문이다. 그렇지 않다면, 이는 버그라고 판단할 수 있다. 이는 모듈 D가 하위 호환성을 깨뜨렸기  
  때문에 수정될 필요가 있거나, 모듈 A가 모듈 D의 동작에 대해 잘못된 가정을 했기 때문에 수정이 필요하다.

### 버전 관련 go 명령어

- 현재 설치되어 있는 버전의 patch 버전 업데이트를 받고 싶다면, 아래처럼 하면 된다.

```sh
go get -u=patch $MODULE_PATH
```

- 특정 모듈의 최신 버전을 받고 싶다면, 아래처럼 하면 된다.

```sh
go get -u $MODULE_PATH
```

- 모듈의 버전을 변경시키며 `go.sum`의 내용이 방대해져 갈 때, 이를 정리하려면 아래 명령을 수행하면 된다.

```sh
go mod tidy
```

### 벤더링

- 모듈이 항상 동일한 의존성과 빌드되는 것을 보장하기 위해, 어떤 조직에서는 해당 모듈 내에 의존성의 복사본을 유지하기를 선호하기도 한다.  
  이를 vendoring(벤더링)이라 한다. `go mod vendor` 명령을 수행해 활성화시킬 수 있고, 이 명령을 수행하면 모듈의 최상위 디렉토리에  
  모듈이 갖는 의존성 모두를 포함하는 vendor 라는 디렉토리를 생성한다.

- `go.mod`에 새로운 의존성이 추가되거나 `go get`으로 기존 의존성을 업그레이드한다면, vendor 디렉토리 또한 함께 업데이트해주려면  
  `go mod vendor`를 수행해야 한다. 이 명령 수행을 까먹고 하지 않았다면, `go build`, `go run`, 그리고 `go test`는 실행되지  
  않고 오류 메시지를 출력할 것이다.

- 의존성 벤더링을 할지의 여부는 조직의 상황에 따라 다르다. 이전의 Go 의존성 관리 시스템은 벤더링을 필수로 필요로 했지만, Go 모듈과 프록시 서버의  
  등장으로 이 방식은 더 이상 선호하지 않게 되었다. 벤더링의 이점은 해당 프로젝트에서 사용되는 3rd-party 코드에 대해 정확히 알고 있다는 것이지만,  
  버전 관리되는 프로젝트의 크기가 엄청나게 커질 수 있다는 단점이 있다.

### pkg.go.dev

- Go 모듈에 대한 단일 중앙 집중 저장소는 없지만, Go 모듈에 대한 문서를 함께 수집하는 단일 서비스가 있다.  
  이는 pkg.go.dev라는 웹사이트로, Go 팀이 오픈 소스 Go 프로젝트를 자동으로 indexing한다. 각 모듈을 위해 패키지 인덱스는 godocs, 적용된  
  라이센스, README, 모듈의 의존성 및 어떤 오픈소스 프로젝트가 사용하는지에 대해 게시한다.

---

## 모듈 배포

- 모듈을 Github와 같은 VCS에 올려놓으면 다른 사람이 해당 모듈을 사용할 수 있다. VCS 상에 해당 모듈을 담은 저장소가 공개이든, 비공개이든  
  상관 없다. Go 프로그램은 소스 코드로부터 빌드되고 소스 코드를 식별하기 위해 저장소 경로를 사용하기 때문에, Maven Central이나 npm을 위해  
  하는 것처럼 중앙 라이브러리 저장소에 모듈을 명시적으로 업로드할 필요가 없다. 단지 `go.mod`나 `go.sum` 파일에 필요한 모듈 정보가 있기만  
  하면 된다.

- 오픈 소스 모듈을 배포할 때, 저장소의 루트에 코드를 배포할 오픈 소스 라이센스를 지정하는 `LICENSE`라는 파일을 포함해야 한다.

- 오픈 소스 라이센스는 크게 사용자가 해당 코드를 비공개로 유지할 수 있도록 허용하는 _관대한(permissive)_ 라이센스, 그리고 사용자가 사용자 자신의  
  코드 또한 오픈 소스로 공개하도록 요구하는 _관대하지 않은(non-permissive)_ 라이센스로 나뉜다. Go 커뮤니티는 주로 BSD, MID, Apache와 같은  
  _관대한_ 라이센스를 선호한다. Go가 모든 응용 프로그램에서 3rd-party 코드를 직접적으로 컴파일하기 때문에, GPL과 같이 _비관대한_ 라이센스의  
  사용은 해당 오픈소스의 사용자가 자신의 코드 또한 공개하도록 하는데, 많은 조직에서는 이를 허용하지 않을 것이다.

> 라이센스는 기존에 존재하는 것들을 사용하자.

---

## 모듈 버전 관리

- 모듈이 공개이든 아니든 Go의 모듈 시스템과 제대로 동작하기 위해서는 모듈에 알맞게 버전을 부여해야 한다. 기능을 추가하거나 버그를 수정하는 한 이 과정은  
  단순하다. 소스 코드 저장소에 변경 사항을 저장하고, semantic versioning rule에 따라 태그를 적용하면 된다.

- 하위 호환을 깰 필요가 있는 변경 지점에 도달한다면 해당 과정은 더 복잡해진다.

- 이렇게 새로운 버전을 지정하기 위한 방법은 크게 아래의 2가지가 있다.

  - 모듈 내에 `vN`이라는 하위 디렉토리를 생성한다. 여기서 `N`은 모듈의 major 버전이다. 예를 들어, 모듈의 버전 2를 생성한다면 `v2` 디렉토리를  
    생성한다. 해당 하위 디렉토리로 `README`, `LICENSE`를 포함한 코드를 복사한다.

  - VCS에서 새로운 branch를 생성한다. 이전 코드나 새로운 코드를 branch에 넣을 수 있다. 새로운 코드를 해당 branch에 넣는다면 branch명을  
    `vN`으로 지정하고, 예전 코드를 넣는다면 `vN-1`로 지정한다. 예를 들어, 모듈의 버전 2를 생성하고 branch에 버전 1의 코드를 넣고 싶다면  
    branch를 `v1`으로 네이밍한다.

- 새로운 코드를 저장하는 방법을 결정한 뒤에 하위 디렉토리나 branch의 코드에서 import path를 변경할 필요가 있다. `go.mod`에서 모듈 경로는 반드시  
  `/vN`으로 끝나야 하고, 모듈 내에 모든 import path도 `/vN`을 사용하도록 해야 한다. 모든 코드를 검토하는 것은 지루할 수 있지만, 이를 자동화하는  
  도구도 있다. 일단 경로가 수정되면 계속 진행해 변경 사항을 구현하면 된다.

- 새로운 코드를 게시할 준비가 되었다면, `vN.0.0`과 같은 태그를 저장소에 적용하자. 하위 디렉토리 시스템을 사용하거나 main branch를 최신 코드로  
  유지한다면 main branch를 tagging하자. 새로운 코드를 다른 branch에 위치시켰다면, 태그를 main branch 대신 해당 branch로 만들어야 한다.

---
