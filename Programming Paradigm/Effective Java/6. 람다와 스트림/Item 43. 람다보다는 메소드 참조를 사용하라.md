# 람다보다는 메소드 참조를 사용하라

- 람다가 익명 클래스보다 나은 점 중 가장 큰 특징은 간결함이다. 그런데 Java에서는 함수 객체를 심지어  
  람다보다도 더 간결하게 만드는 방법이 있으니, 바로 **메소드 참조(Method Reference)** 이다.  
  아래 코드는 임의의 key와 `Integer` value의 매핑을 관리하는 프로그램의 일부다. 이때, value가 key의  
  인스턴스 개수로 해석된다면 이 프로그램은 multiset을 구현한게 된다. 이 코드는 key가 map 안에  
  없다면 key와 숫자 1을 반환하고, 이미 있다면 기존 매핑 값을 증가시킨다.

```java
map.merge(key, 1, (count, increment) -> count + increment);
```

- 위 코드는 Java8에 `Map`에 추가된 `merge()`를 사용했다. `merge()`는 key, value, 함수를  
  인수로 받으며 주어진 key가 map 안에 없다면 주어진 [key, value] 쌍을 그대로 저장한다.  
  반대로 key가 이미 있다면 세 번째 인수로 받은 함수를 현재 값과 주어진 값에 적용한 다음, 그 결과로  
  현재 값을 덮어쓴다. 즉, map에 [key, 함수의 결과] 쌍을 저장한다. 이 코드는 `merge()`의  
  전형적인 쓰임을 잘 보여준다.

- 깔끔해 보이는 코드지만, 아직도 거추장스러운 부분이 남아 있다. 매개변수인 count와 increment는  
  크게 하는일 없이 공간을 꽤 차지한다. 사실 이 람다는 두 인수의 합을 단순히 반환할 뿐이다.  
  Java8이 되면서 `Integer`와 같은 기본 타입의 박싱 타입 클래스는 이 람다와 기능이 같은  
  정적 메소드인 `sum()`을 제공하기 시작했다. 따라서 람다 대신 이 메소드의 참조를 전달하면  
  똑같은 결과를 더 보기 좋게 얻을 수 있다.

```java
map.merge(key, 1, Integer::sum);
```

- 매개변수 수가 늘어날수록 메소드 참조로 제거할 수 있는 코드량도 늘어난다.

- 하지만 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다.  
  이런 람다는 길이는 더 길지만 메소드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.

- 람다로 할 수 없는 일이라면 메소드 참조로도 할 수 없다. 그렇더라도 메소드 참조를 사용하는 편이  
  보통은 더 짧고 간결하므로, 람다로 구현했을 때 너무 길거나 복잡하다면 메소드 참조가 좋은 대안이 되어준다.  
  즉, 람다로 작성할 코드를 새로운 메소드에 담은 다음, 람다 대신 그 메소드 참조를 사용하는 식이다.  
  메소드 참조에는 기능을 잘 드러내는 이름을 지어줄 수 있고, 친절한 설명을 문서로 남길 수도 있다.

- IDE들은 대체로 람다를 메소드 참조로 바꾸라고 권하지만, 이를 항상 따르는게 좋지 않을 수도 있다.  
  때로는 람다가 메소드 참조보다 간결할 때도 있다. 주로 메소드와 람다가 같은 클래스에 있을 때 그렇다.  
  예를 들어, 아래 코드가 `ThisClassHasTooLongName`에 있다고 해보자.

```java
service.execute(ThisClassHasTooLongName::action);
```

- 이를 람다로 대체하면 아래처럼 된다.

```java
service.execute(() -> action());
```

- 위 경우에서 메소드 참조는 더 짧지도, 더 명확하지도 않다. 따라서 람다쪽이 더 낫다.  
  같은 선상에서 `java.util.function` 패키지가 제공하는 제네릭 정적 팩토리 메소드인 `Function.identity()`를  
  사용하기보다는 똑같은 기능의 람다인 `(x -> x)`를 사용하는 편이 코드도 짧고 명확하다.

- 메소드 참조의 유형은 총 다섯 가지로, 가장 흔한 유형은 앞서 본 것처럼 정적 메소드를 가리키는 메소드 참조다.  
  나머지 네 개 유형을 살펴보자.

- 먼저 인스턴스 메소드를 참조하는 유형이 두 가지 있다. 그중 하나는 수신 객체(receiving object: 참조 대상 인스턴스)를  
  특정하는 한정적(bounded) 인스턴스 메소드 참조이고, 다른 하나는 수신 객체를 특정하지 않는 비한정적(unbounded) 인스턴스  
  메소드 참조이다. 한정적 참조는 근본적으로 정적 참조와 비슷하다. 즉, 함수 객체가 받는 인수와 참조되는 메소드가 받는 인수가  
  똑같다. 비한정적 참조에서는 함수 객체를 적용하는 시점에 수신 객체를 알려준다. 이를 위해 수신 객체 전달용 매개변수가  
  매개변수 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메소드 선언에 정의된 매개변수들이 뒤따른다.  
  비한정적 참조는 주로 Stream 파이프라인에서의 매핑과 필터 함수에 쓰인다.

- 마지막으로 클래스 생성자를 가리키는 메소드 참조와 배열 생성자를 가리키는 메소드 참조가 있다.  
  생성자 참조는 팩토리 객체로 사용된다.

| 메소드 참조 유형   | 예시                     | 같은 기능을 하는 람다                                 |
| :----------------- | :----------------------- | :---------------------------------------------------- |
| 정적               | `Integer::parseInt`      | `str -> Integer.parseInt(str)`                        |
| 한정적(인스턴스)   | `Instant.now()::isAfter` | `Instant then = Instant.now(); t -> then.isAfter(t);` |
| 비한정적(인스턴스) | `String::toLowerCase`    | `str -> str.toLowerCase()`                            |
| 클래스 생성자      | `TreeMap<K, V>::new`     | `() -> new TreeMap<K, V>()`                           |
| 배열 생성자        | `int[]::new`             | `len -> new int[len]`                                 |

---

## 핵심 정리

- 메소드 참조는 람다의 간단명료한 대안이 될 수 있다.  
  **메소드 참조쪽이 짧고 명확하다면 메소드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하자.**

---

## 추가

- 람다로는 불가능하나, 메소드 참조로는 가능한 유일한 상황이 하나 있는데, 바로 **제네릭 함수 타입(Generic Function Type)** 구현이다.  
  아래는 Java 명세의 일부이다.

> 함수형 인터페이스의 추상 메소드가 제네릭일 수 있듯이, 함수 타입도 제네릭일 수 있다.  
> 아래의 인터페이스 계층 구조를 생각해보자.
>
> ```java
> interface G1 {
>    <E extends Exception> Object m() throws E;
> }
>
> interface G2 {
>    <F extends Exception> String m() throws Exception;
> }
>
> interface G extends G1, G2 { }
> ```
>
> - 이때 함수형 인터페이스 `G`를 함수 타입으로 표현하면 아래와 같다.  
>   `<F extends Exception> () -> String throws F`
>
> - 이처럼 함수형 인터페이스를 위한 제네릭 함수 타입은 메소드 참조 표현식으로는 구현할 수 있지만,  
>   람다식으로는 불가능하다. 제네릭 람다식이라는 문법이 존재하지 않기 때문이다.

---
