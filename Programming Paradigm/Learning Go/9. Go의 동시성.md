# Go의 동시성

- **동시성**은 단일 프로세스를 독립적인 컴포넌트로 분리하고 해당 컴포넌트가 안전하게 데이터를 공유하는 방법을 지정하는 컴퓨터 과학 용어이다.  
  대부분의 언어는 lock을 획득해 공유 데이터를 접근하는 OS level 스레드를 사용하는 라이브러리를 통해 동시성을 제공한다. 하지만 Go는 다르다.  
  Go는 주요 동시성 모델로 CSP(Communicating Sequential Processes, 순차적 프로세스들의 통신)에 기반한다.

- 이번 장에서는 Go네애 동시성을 위한 중추인 goroutine, channel, select 키워드의 기능을 빠르게 살펴보는 것으로 시작해보자.  
  그리고 몇 몇의 일반적인 Go 동시성 패턴을 살펴보고 low-level 접근 방식이 더 나은 상황도 다뤄보자.

---

## 동시성 사용 지점

- 동시성을 사용하기 전, 먼저 프로그램이 동시성을 사용했을 때 얻을 수 있는 이점이 있는지 확신할 수 있어야 한다. 새로운 Go 개발자가 동시성을  
  실험으로 시작하면 아래의 과정을 거치는 경향이 있다.

  - (1) 동시성은 굉장하다. Goroutine 내에 모든 것을 넣자!
  - (2) 내 프로그램은 더 빨라지지 않는다. 따라서 channel에 버퍼를 추가하자.
  - (3) 내 channel은 blocking되고 deadlock에 빠진다. 따라서 정말 큰 버퍼를 사용하는 buffered channel을 사용하자.
  - (4) 내 channel은 여전히 blocking된다. Mutex를 사용하자!
  - (5) 모르겠다. 그냥 동시성 안써야겠다.

- 사람들은 동시성을 가진 프로그램은 더 빠르게 수행된다고 믿기에 동시성을 사용한다. 하지만 모든 경우가 이렇지는 않다. 더 많은 동시성은 어떤 것을  
  자동으로 더 빠르게 만들지는 않으며 코드를 이해하기 더 어렵게 만들 수 있다. 먼저 **동시성(concurrency)과 병렬성(parallelism)은 다르다** 는  
  것을 먼저 이해하는 것이 중요하다. 동시성은 해결하고자 하는 문제를 더 나은 구조로 만들기 위한 도구이다. 동시성 코드가 병렬적으로(동시에)  
  실행되는지의 여부는 하드웨어와 알고리즘이 허용하는지의 여부에 따라 다르다.

- 넓은 의미로 모든 프로그램은 같은 3단계 처리를 따른다. 이 단계는 데이터를 받고, 데이터를 변환하고, 결과를 출력하는 것을 의미한다.  
  프로그램에서 동시성 사용의 여부는 각 단계에 따른 데이터 흐름에 따라 결정된다. 한 단계의 데이터가 다른 단계를 진행하는 데 필요하지 않기에  
  두 단계가 동시성을 가질 수 있는 경우도 있고, 다른 하나의 결과에 의존해 두 단계가 순차적으로 실행되어야 하는 경우도 있다.  
  독립적으로 수행할 수 있는 여러 처리로부터 데이터를 결합시키길 원한다면 동시성을 사용하자.

- 또다른 중요한 점은 동시성은 동시에 실행되는 작업들이 시간이 얼마 걸리지 않을 때 사용하기 좋지 않다는 것이다. 동시성은 공짜가 아니다.  
  많은 일반적인 in-memory 알고리즘은 너무 빨라 동시성을 통해 값을 전달하는 오버헤드가 병렬적으로 동시성 코드를 수행해 얻는 잠재적인 시간 절약을  
  압도할 수 있다. 이래서 동시성 수행은 보통 I/O 작업을 위해 사용된다. 디스크나 네트워크로부터 읽거나 쓰는 동작은 대부분의 복잡한 in-momory의  
  처리보다 1000배 정도 느리다. 동시성이 도움이 되는지 확실치 않다면 먼저 코드를 순차적으로 구현하고, 동시성 구현과 성능을 비교하기 위한 벤치마크를  
  작성하자.

- 예시를 들어보자. 3개의 다른 웹 서비스를 호출하는 웹 서비스를 작성한다고 생각해보자. 해당 서비스 중 2곳에 데이터를 보내 결과를 받은 다음, 이 결과를  
  3번째 서비스에 전달해 결과를 반환 받을 것이다. 전체 과정은 50ms내에 완료되지 않는다면 오류를 반환해야 한다. 이 예시 상황은 서로가 상호작용 없이  
  I/O를 수행할 필요가 있는 부분과 결과를 결합하는 부분, 그리고 수행을 완료해야 하는 시간적 제약까지 있기에 동시성을 사용하기 좋다.

---

## Goroutine

- Goroutine은 Go의 동시성 모델의 핵심 개념이다. Goroutine을 이해하기 위해 용어 몇 개를 정의해보자.

  - Process: Process는 컴퓨터의 OS에서 수행 중인 프로그램의 인스턴스이다. OS는 프로세스와 메모리 같은 자원을 연결시키고, 다른 프로세스에서  
    접근할 수 없도록 보장한다.

  - Thread: Process는 하나 이상의 thread로 구성된다. Thread는 OS가 주어진 시간 동안 수행하는 실행의 단위이다. Process 내의 thread는  
    자원들의 접근을 공유한다. CPU는 코어 수에 따라 하나 이상의 thread를 동시에 실행시킬 수 있다. OS의 역할 중 하나는 모든 process가  
    수행되는 기회를 얻을 수 있도록 보장하기 위해 thread를 CPU에 scheduling하는 것이다.

- Goroutine은 Go runtime에서 관리하는 가벼운 process이다. Go 프로그램이 실행되면, Go runtime은 여러 개의 thread를 생성하고 프로그램을  
  실행시키기 위한 단일 goroutine을 시작한다. 프로그램에서 생성된 goroutine은 초기에 생성된 하나를 포함해 OS에서 CPU 코어 수에 따라 thread를  
  scheduling 하듯이 Go runtime scheduler가 자동으로 thread들을 할당한다. 이미 OS가 thread, process를 관리하는 scheduler를 이미  
  갖고 있기 때문에, 이런 작업이 추가 작업으로 보일 수 있으나 아래의 몇 가지 이점들이 있다.

  - Goroutine의 생성은 OS level 자원을 생성하지 않기에 thread 생성보다 빠르다.
  - Goroutine의 초기 스택 크기는 thread의 스택 크기보다 작으며, 필요하다면 늘릴 수 있다. 그리고 goroutine은 메모리를 더 효율적으로  
    사용할 수 있게 한다.
  - Goroutine 간의 전환은 완전히 process 내에서 일어나기에 상대적으로 느린 OS syscall을 회피한다. 따라서 thread 사이의 전환보다 빠르다.
  - Scheduler가 Go process의 일부이기 때문에 scheduling 결정을 최적화할 수 있다. Scheduler는 네트워크를 확인하는 작업과 함께 수행돼  
    I/O가 blocking되어 goroutine이 scheduling되지 않는 시점을 감지할 수 있다. 그리고 GC와 통합되어 작업이 go process에 할당된  
    모든 OS thread에서 균형을 이루도록 한다.

- 이런 장점들이 Go 프로그램이 수백 개, 수천 개, 수만 개의 동시 goroutine을 생성할 수 있도록 한다.

- Goroutine은 함수의 실행 전에 go 키워드를 사용함으로써 시작된다. 다른 함수들과 같이 상태를 초기화하기 위해 파라미터를 전달할 수도 있다.  
  하지만 해당 함수에서 반환되는 모든 값들은 무시된다.

- 모든 함수는 goroutine으로 실행될 수 있다.

---
