# CQRS View 설계

- CQRS view 모듈에는 하나 이상의 query 작업으로 구성된 API가 있다. 이 API들은 다른 서비스들이 발행한 이벤트를 구독해 최신 상태로  
  유지된 DB를 조회하는 query API이다. View 모듈은 view DB와 세 개의 하위 모듈로 구성된다.

![picture 12](/images/MSAP_7_10.png)

- 이벤트 핸들러, query API 모듈은 데이터 접근 모듈을 통해 DB를 조회, 수정한다. 이벤트 핸들러 모듈은 이벤트를 구독해 DB를 수정하고  
  query API 모듈은 데이터를 조회한다.

- View 모듈을 개발할 때는 몇 가지 중요한 설계 결정을 해야 한다.

  - DB 선정 및 스키마 설계
  - 데이터 접근 모듈을 설계할 때 멱등성, 동시성 업데이트 등의 다양한 문제 고려
  - 기존 애플리케이션에 새로운 view를 구현하거나 기존 스키마를 바꾸는 경우, view를 효율적으로 빌드할 수 있는 수단 강구
  - View 클라이언트에서 복제 시차 처리 방안에 대한 모색

## DB 선정 및 스키마 설계

- DB는 신중하게 결정해야 하며 스키마도 잘 설계해야 한다. DB와 데이터 모델의 주 목적은 view 모듈의 query 작업을 효율적으로 구현하는 것이다.  
  DB를 선택할 때 이런 query 작업의 특성이 주된 검토 항목이지만, DB 역시 이벤트 핸들러가 수행하는 업데이트 작업을 효율적으로 지원할 수 있어야 한다.

### SQL vs NoSQL database

- 최근 NoSQL DB의 사용성이 급증하고 있다. NoSQL DB는 대부분 transaction 기능이 제한적이고 범용적인 질의 능력은 없지만, 특정 use case에서는  
  유연한 데이터 모델, 우수한 성능과 확정성 등 SQL 기반의 RDBMS보다 더 낫다.

- NoSQL DB는 CQRS view와 잘 맞는 편이다. NoSQL DB의 풍성한 데이터 모델과 우수한 성능이 CQRS view에 유리하기 때문이다. 또한 CQRS  
  view는 단순 transaction만 사용하고 고정된 query만 실행하므로 NoSQL DB의 제약 사항도 거의 영향을 받지 않는다.

- 물론 SQL DB를 사용해 CQRS view를 구현하는 것이 타당한 경우도 있다.

- 아래 표는 SQL, NoSQL DB 중 어느 것을 사용할지를 고민할 때 참고할 정도의 사항들을 나타낸다.

| ~가 필요하면                | ~를 사용한다                                              |
| --------------------------- | --------------------------------------------------------- |
| JSON 객체를 PK로 검색       | Document store(MongoDB, DynamoDB), key-value store(redis) |
| Query 기반의 JSON 객체 검색 | Document store                                            |
| 텍스트 query                | 텍스트 검색 엔진(ElasticSearch, Solr)                     |
| 그래프 query                | Graph DB(Neo4j)                                           |
| 전통적인 SQL 리포팅/BI      | RDBMS                                                     |

### 업데이트 작업 지원

- View 데이터 모델에서는 query 뿐만 아니라 이벤트 핸들러가 실행하는 업데이트 작업 역시 효율적으로 구현되어야 한다. 이벤트 핸들러는 대부분  
  view DB에 있는 레코드를 PK로 찾아 수정/삭제할 것이다.

- 하지만 FK를 이용해 레코드를 수정/삭제해야 하는 경우도 있다. 일부 DB 자료형은 FK 기반의 업데이트 작업을 효율적으로 지원한다.  
  가령 RDBMS나 MongoDB를 사용 중이라면 필요한 column의 index를 생성하면 되지만, 다른 NoSQL DB에서는 PK가 아닌 key를 기반으로  
  업데이트를 수행하기가 결코 쉽지 않다. 애플리케이션이 업데이트할 레코드를 결정하려면 FK에서 PK로 mapping 가능한 데이터를 DB에 갖고 있어야 한다.  
  예를 들어 PK 기반의 수정, 삭제만 지원하는 DynamoDB를 사용 중이라면 먼저 DynamoDB의 secondary index를 사용해 query를 수행한 후  
  수정, 삭제할 항목의 PK를 결정해야 한다.

## 데이터 접근 모듈 설계

- 이벤트 핸들러와 query API 모듈은 DB에 직접 접근하지 않는다. 그 대신 DAO(데이터 접근 객체) 및 helper 클래스들로 구성된 데이터 접근  
  모듈을 사용한다. DAO는 이벤트 핸들러가 호출한 업데이트 작업과 query API 모듈이 호출한 query 작업을 실질적으로 수행한다.  
  또한 고수준 코드에 쓰이는 자료형과 DB API간의 mapping, 동시 업데이트 처리 및 업데이트 멱등성 보장 등의 역할을 수행한다.

### 동시성 처리

- 동일한 DB record에 대해 여러 DAO가 동시에 업데이트를 처리하려는 경우가 있다. View가 한 종류의 aggregate가 발행한 이벤트만을 구독한다면  
  동시성 이슈는 없을 것이다. 특정 aggregate 인스턴스가 발행한 이벤트는 순차적으로 처리되기 때문에 어느 한 aggregate 인스턴스에 해당되는  
  레코드가 동시에 업데이트될 일이 없기 때문이다. 하지만 view가 여러 종류의 aggregate가 발행한 이벤트를 구독할 경우, 여러 이벤트 핸들러가  
  동일한 record에 달려들어 업데이트하려 할 수 있다.

- 따라서 DAO는 동시 업데이트로 서로가 서로의 데이터를 덮어 쓰지 않도록 작성되어야 한다. 만약 DAO가 레코드를 읽고, 업데이트된 레코드를 쓴다면  
  pessimistic lock이든 optimistic lock이든 하나를 적용해야 한다.

### 멱등한 이벤트 핸들러

- 이벤트 핸들러는 같은 이벤트를 한 번 이상 넘겨받고 호출될 수 있다. Query 쪽 이벤트 핸들러가 멱등한 경우, 즉 중복 이벤트를 처리해도 결과가  
  정확히 동일하다면 문제될 일은 아니다. 하지만 최악의 경우, view 데이터 저장소가 일시적으로 동기화가 안될 수 있다.

![picture 13](/images/MSAP_7_11.png)

- 위 예시 처럼 중복 이벤트 때문에 부정확한 결과가 나온다면, 이는 멱등한 이벤트 핸들러가 아닌 것이다. 이벤트 핸들러는 멱등해지기 위해 자신이  
  view 데이터 저장소에서 처리한 이벤트의 ID를 기록해 두었다가 중복된 이벤트가 들어오면 솎아낼 수 있어야 한다.

- 위에서 말했듯이 이벤트 핸들러는 멱등해지기 위해 반드시 이벤트 ID를 기록하고 데이터 저장소를 원자적으로 업데이트해야 한다. 그 방법은 DB  
  종류마다 다르다. View 데이터 저장소가 SQL DB이면 이벤트 핸들러가 처리 완료한 이벤트를 view 업데이트 트랜잭션의 일부로 `processed_events`  
  테이블에 삽입하게 할 수 있다. 그러나 트랜잭션 능력이 제한적인 NoSQL DB라면 이벤트 핸들러는 자신이 업데이트하는 데이터 저장소의 record  
  자체에 이벤트를 함께 저장해야 한다.

- 이벤트 핸들러가 모든 이벤트 ID를 일일이 기록할 필요는 없다. 만약 이벤트 ID가 그냥 하나씩 증가하는 구조라면, 주어진 aggregate 인스턴스에서  
  전달받은 `max(eventId)`를 각 record에 저장하면 된다. 레코드가 단일 aggregate 인스턴스에 해당된다면 이벤트 핸들러는 `max(eventId)`만  
  기록하면 된다. 여러 aggregate의 이벤트가 조합된 결과를 나타내는 레코드는 `[aggregateType, aggregateID] -> max(eventID)`의  
  mapping 로직을 담고 있어야 한다.

### 클라이언트 애플리케이션은 eventually consistent한 view를 사용할 수 있다

- CQRS를 적용하면 command 쪽을 업데이트한 직후 query를 실행하는 클라이언트가 자신이 업데이트한 내용을 바라보지 못하게 될 가능성이 있다고  
  했다. Messaging 인프라의 지연 시간은 불가피하기 때문에 이 view는 eventually consistent하다. Command와 query 모듈 AP를  
  이용하면 클라이언트가 비일관성을 감지하게 만들 수 있다. Command 쪽 작업이 클라이언트에 발행된 이벤트의 ID가 포함된 토큰을 반환하고,  
  클라이언트는 이 토큰을 query 작업에 함께 전달하면 해당 이벤트에 의해 view가 업데이트되지 않았을 경우 에러가 반환되게 하는 것이다.  
  이런 중복 이벤트 감지 메커니즘을 view 모듈에 구현할 수 있다.

---
