# 2

## Program and declarations

```yacc
program
	: translation_unit
translation_unit
	: external_declaration
	| translation_unit external_declaration
external_declaration
	: function_declaration
	| declaration
```

## Function definition

```yacc
function_definition
	: declaration_specifiers declarator compound_statement
	| declarator compound_statement
```

```c
int *fun(int a, /* */)
{
	int x;
	x = a * a;
}
```

- 위 코드에서

  - declaration_specifier: `int`
  - declarator: `*fun(int a, /* */)`
  - compound_statement: `{ int x; x = a * a; }`

## Declaration - 일반 선언문

```yacc
declaration
	: declaration_specifiers ; (ex. `int;`)
	| declaration_specifiers init_declarator_list ; (ex. `int x, y = 10;`)
declaration_specifiers
	: type_specifier (ex. `struct { .. } *a;`에서 `struct { .. }`가 type_specifier)
	| storage_class_specifier
	| type_specifier declaration_specifiers
	| storage_class_specifier declaration_specifiers
storage_class_specifier
	: auto
	| static
	| typedef
init_declarator_list
	: init_declarator
	| init_declarator_list, init_declarator
init_declarator
	: declarator
	| declarator = initializer
```

- ex. `int x, a = 10`에서 `x`는 declarator 이므로 `init_declarator`가 되고, `a = 10`은 `declarator = initializer`의  
  형식을 따르므로 결과적으로 `init_declarator_list, init_declarator`가 되므로 `init_declarator_list`가 된다.

## Type identifier(타입 명시자)

```yacc
type_specifier
	: struct_specifier (struct)
	| enum_specifier (enum)
	| TYPE_IDENTIFIER (int, long, float)
```

## Struct specifier

- 특징

  - `struct`, `union`은 형태가 동일하다.
  - struct declaration은 일반 declaration과 달리 초기화가 불가능하다.
  - struct declaration은 일반 declaration과 달리 storage class specifier(auto, static, typedef)를 사용할 수 없다.
  - struct declaration은 goto와 함께 선언 전 미리 사용하는 전방 참조(forward reference)가 사용 가능한 유일한 선언문이다.
    - struct는 같은 block 내, goto label은 함수 내면 가능하다.

## Enum specifier

```c
int x;
enum e { A, B = x + 1, C = A + B};
```

- 위 코드에서 `B = x + 1`은 불가한데, 변수가 사용 불가한 이 상황은 문법적 오류가 아닌 semantic(의미적) 문제이다.
- 반면 `C = A + B`는 가능한데, 이는 A, B가 모두 변수가 아닌 상수이기 때문이다.
- `enum e = { A, B = 1 + sizeof(int) }`는 `sizeof(int)`가 상수와 마찬가지이기에 가능하다.

## Statement - 명령문

```yacc
statement
	: labeled_statement
	| compound_statement -> `{ + 선언문 + 명령문 + }`
	| expression_statement -> `x = 10 + 5;`
	| selection_statement -> `if, switch, else`
	| iteration_statement -> `for, do-while`
	| jump_statement -> `goto, return`
labeled_statement
	: case constant_expression : statement
	| default : statement
	| IDENTIFIER : statement
```

## Ambiguity in if-statement

```c
int a = 10, b = 20, c = 30;
int max = b;
if(a > b) if(a > c) max = a; else max = c;
```

- 위 코드에서 syntax tree가 else 때문에 2개가 생기기 때문에 ambiguity가 발생한다.  
  따라서 yacc를 수행하면 shift-reduce conflict가 발생한다.
