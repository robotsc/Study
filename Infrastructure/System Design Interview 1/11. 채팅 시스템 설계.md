# 채팅 시스템 설계

- 이번에는 채팅 시스템을 설계해보자.

## 문제 이해 및 설계 범위 확정

- 현재 시장에 나와있는 채팅 앱들을 보면 1:1 채팅에 집중하는 앱들이 있는가 하면 그룹 채팅에 중점을 둔 업무용 앱이나, 게임 채팅을 위해 대규모  
  그룹의 소통과 응답지연(latency)이 낮은 음성 채팅에 집중하는 앱 등이 있다.

- 따라서 채팅 시스템을 설계하기 전에, 요구 사항들을 명확히 해놔야 한다.

- 이번에 설계할 채팅 시스템의 요구사항은 아래와 같다.

  - 1:1, 그룹 채팅 모두 지원
  - 모바일 앱, 웹 앱 모두 지원
  - DAU: 5000만명
  - 그룹 채팅은 최대 100명까지 참가 가능
  - 1:1채팅, 그룹 채팅, 사용자 접속상태 표시를 지원해야 한다.
  - 텍스트 메시지만 주고 받을 수 있다.
    - 메시지 길이 제한: 100,000자 이하
  - 채팅 이력은 영원히 보관되어야 한다.
  - 이후 end-to-end encryption(종단 간 암호화)를 지원할 수 있어야 한다.

- 아래는 한 번 더 정리한 설계할 시스템의 주요 기능이다.

  - latency가 낮은 1:1 채팅 기능
  - 최대 100명까지 참여 가능한 그룹 채팅 기능
  - 사용자의 접속 상태 표시 기능
  - 다양한 단말 지원
    - 하나의 계정으로 여러 단말에 동시 접속 지원
  - 푸시 알림

---

## 개략적 설계안 제시 및 동의 구하기

- 이 시스템을 설계하기 위해서는 클라이언트와 서버의 통신 방법에 대한 기본적 지식은 갖추고 있어야만 한다.  
  채팅 시스템의 경우, 클라이언트는 모바일 앱이거나 웹 애플리케이션이다. 클라이언트들은 서로 직접 통신하지 않는다.  
  대신, 각 클라이언트는 위에 나열한 모든 기능을 지원하는 채팅 서비스와 통신한다.  
  기본 기능에 집중해, 채팅 서비스의 기능을 다시 생각해보자.

  - 클라이언트들로부터 메시지 수신
  - 메시지 수신자(recipient) 결정 및 전달
  - 수신자가 접속(online) 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

- 아래 그림은 클라이언트(메시지 송신 클라이언트와 수신 클라이언트)와 채팅 서비스 사이의 관계를 나타낸 것이다.

![picture 34](/images/SDI_CS_1.png)

- 채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용해 서비스에 접속한다.  
  따라서 채팅 서비스의 경우, 어떤 통신 프로토콜을 사용할 것인가도 매우 중요한 문제다.

- 대부분의 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트인데, 채팅 시스템의 경우에도 마찬가지다.  
  sender(메시지 송신 클라이언트)가 이 역할을 한다. 위 그림에서 sender는 receiver(수신 클라이언트)에게 전달할 메시지를  
  채팅 서비스에게 보낼 때, 오랜 세월 검증된 HTTP Protocol을 사용한다. HTTP는 현재 웹에서 가장 널리 사용되는 프로토콜이다.  
  위 그림에서 클라이언트는 채팅 서비스에 HTTP Protocol로 연결한 다음, 메시지를 보내 receiver에게 해당 메시지를 전달하라고 알린다.  
  채팅 서비스와의 접속에는 keep-alive header를 사용하면 효율적인데, 클라이언트와 서버 사이의 연결을 끊지 않고 계속 유지할 수 있기 때문이다.  
  TCP 접속 과정에서 발생하는 handshake 횟수를 줄일 수 있음은 물론이다. HTTP는 메시지 전송 용도로는 괜찮은 선택이며, Facebook 같은  
  많은 대중적 채팅 프로그램이 초기에 HTTP를 사용했다.

- 하지만 메시지 수신 시나리오는 이보다 복잡하다. HTTP는 클라이언트가 연결을 만드는 프로토콜이자, 서버에서 클라이언트로 임의 시점에 메시지를  
  보내는 데는 쉽게 쓰일 수 없다. 서버가 연결을 만드는 것처럼 동작할 수 있도록 하기 위해 많은 기법들이 제안되어 있는데,  
  polling, long polling, WebSocket 등이 그런 기술이다. 이들 각각에 대해 조금 더 자세히 살펴보자.

### Polling

- Polling은 클라이언트가 주기적으로 서버에게 새로운 메시지가 있는지를 물어보는 방법이다.  
  Polling 비용은 polling을 자주하면 할수록 올라간다.  
  답해줄 새로운 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비된다는 문제도 있다.  
  아래는 polling을 대략적으로 그린 그림이다.

![picture 35](/images/SDI_CS_2.png)

### Long Polling

- Polling은 여러 가지로 비효율적일 수 있어서 나온 기법이 Long Polling이다.

![picture 36](/images/SDI_CS_3.png)

- Long polling의 경우 클라이언트는 새로운 메시지가 반환되거나 timeout 될 때까지 연결을 유지한다.  
  클라이언트는 새로운 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.  
  이 방법에는 아래와 같은 단점들이 있다.

  - 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있다.  
    HTTP 서버들은 보통 stateless 서버이다. Load balancing을 위해 round-robin 알고리즘을 사용하는 경우,  
    메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 long polling 연결을 갖고 있지 않은 서버일 수도 있는 것이다.

  - 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 수 있는 좋은 방법이 없다.

  - 여전히 비효율적이다. 메시지를 많이 받지 않는 클라이언트도 timeout이 일어날 때마다 주기적으로 서버에 다시 접속할 것이다.

### Websocket

- WebSocket은 서버가 클라이언트에게 asynchronous(비동기) 메시지를 보낼 때 가장 널리 사용하는 기술이다.

![picture 37](/images/SDI_CS_4.png)

- WebSocket 연결은 클라이언트가 시작한다. 한번 맺어진 연결은 항구적이며 양방향이다. 이 연결은 처음에는 HTTP 연결이지만, 특정 handshake 절차를  
  거쳐 WebSocket Connection으로 업그레이드 된다. 일단 이 항구적인 연결이 만들어지고 나면, 서버는 클라이언트에게 비동기적으로 메시지를  
  전송할 수 있다. WebSocket은 일반적으로 방화벽이 있는 환경에서도 잘 동작한다. 80, 443처럼 HTTP 혹은 HTTPS Protocol이 사용하는  
  기본 포트 번호를 그대로 사용하기 때문이다.

- 앞서 HTTP Protocol이 메시지를 보내려는 클라이언트에게는 썩 괜찮은 프로토콜임을 보았다.  
  하지만 WebSocket은 이에 더해 양뱡향 메시지 전송까지 가능하게 하므로, WebSocket 대신 HTTP를 굳이 고집할 필요는 없다.  
  아래 그림은 어떻게 WebSocket이 메시지 전송이나 수신에 쓰일 수 있는지 간략하게 나타낸 그림이다.

![picture 38](/images/SDI_CS_5.png)

### 개략적 설계안

- 이제 클라이언트와 서버 사이의 주 통신 프로토콜로 WebSocket을 사용하기로 결정했다.  
  하지만 다른 부분에서는 굳이 WebSocket을 사용할 필요가 없다. 사실 대부분의 기능(회원가입, 로그인, 사용자 프로필 등)들은 일반적인  
  HTTP 상에서 구현해도 된다.

- 이제부터는 전체 시스템의 개략적인 설계안을 살펴보자.  
  아래 그림처럼, 이번 채팅 시스템은 크게 세 가지 부분으로 나눠볼 수 있다.

![picture 39](/images/SDI_CS_6.png)

#### Stateless Service

- 이 설계안에서 Stateless(무상태) 서비스는 로그인, 회원가입, 사용자 프로필 표시 등을 처리하는 전통적인 요청/응답 서비스이다.  
  무상태 서비스가 제공하는 기능은 많은 웹사이트와 같이 앱이 보편적으로 제공하는 기능이다.

- 무상태 서비스는 load balancer 뒤에 위치한다. Load balancer가 하는 일은 요청을 그 경로에 맞는 서비스로 정확하게 전달하는 것이다.  
  Load balancer 뒤에 있는 monolithic 서비스일 수도 있고, micro 서비스일 수도 있다. 이 서비스들 가운데 상당수가 시장에 완제품으로  
  나와있기에, 직접 구현하지 않아도 쉽게 사서 쓸 수 있다. 이들 가운데 나중에 살펴볼 것은 **Service Discovery** 이다.  
  이 서비스는 클라이언트가 접속할 채팅 서버의 DNS hostname을 클라이언트에게 알려주는 역할을 한다.

#### Stateful Service

- 이 설계안에서 유일하게 상태 유지가 필요한 서비스는 채팅 서비스다. 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 하기 때문이다.  
  클라이언트는 보통 서버가 살아 있는 한 다른 서버로 연결을 변경하지 않는다. 위에서 언급한 Service Discovery 서비스는 채팅 서비스와  
  긴밀히 협력해 특정 서버에 부하가 몰리지 않도록 한다.

#### Third party 연동

- 채팅 앱에서 가장 중요한 제3자 서비스는 Push Notification이다. 새로운 메시지를 받았다면, 설사 앱이 실행중이지 않더라도  
  알림을 받을 수 있어야 하기 때문이다.

##### 규모 확장성

- 트래픽 규모가 얼마 되지 않을 때는 위에서 설명한 모든 기능을 단 한 대의 서버로 구현할 수 있다.  
  지금 설계중인 시스템의 경우처럼 대량의 트래픽을 처리해야 하는 경우에도 이론적으로는 모든 사용자 연결을 최신 클라우드 서버 한대로 처리할 수  
  있기는 하다. 이때 따져봐야 할 것은 **서버 한 대로 얼마나 많은 접속을 동시에 허용할 수 있느냐** 이다. 이번에 다루는 시스템의 경우에는  
  동시 접속자가 1M 명이라고 가정할 것인데, 접속당 10K의 메모리가 필요하다고 본다면(매우 개략적인 수치) 10GB의 메모리만 있으면 모든  
  연결을 다 처리할 수 있을 것이다.

- 하지만 모든 것을 서버 한 대에 담은 설계안은 절대 좋지 못하다. 누구도 그 정도 규모의 트래픽을 서버 한 대로 처리하려하지 않을 것이기 때문이다.  
  여기에는 여러 이유가 있는데, SPOF도 그 중 하나다.

> 서버만 한 대 갖는 설계안에서 출발해 점차 다듬어 나가는 것은 괜찮다. 단, 면접관에게 _"이것은 그저 시작일 뿐"_ 이라는 것만 정확히  
> 전달해 놓으면 된다.

- 지금까지 본 것들을 정리하면, 아래와 같은 개략적 설계안이 만들어진다.

![picture 40](/images/SDI_CS_7.png)

- 위 그림에서 유의할 점은 실시간으로 메시지를 주고받기 위해 클라이언트가 웹 서버와 WebSocket 연결을 끊지 않고 유지한다는 것이다.  
  각 컴포넌트의 역할과 기능을 살펴보자.

  - 채팅 서버: 클라이언트 사이에 메시지를 중계하는 역할을 담당한다.
  - 접속 상태 서버(presence server): 사용자의 접속 여부를 관리한다.
  - API 서버: 로그인, 회원가입, 프로필 변경 등 그 외 나머지 전부를 처리한다.
  - 알림 서버: Push 알림을 보낸다.
  - Key-value Store: 채팅 이력(history)을 보관한다.  
    시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게될 것이다.

##### 저장소

- 이제 서버도 준비되었고 제3자 서비스 연동도 모두 끝났다고 해보자. 이 기술 스택 깊은 곳에 데이터 계층이 있다.  
  데이터 계층을 올바르게 만드는 데는 노력이 필요하다. 중요한 것 가운데 하나는 어떤 데이터베이스를 쓸 것인가 이다.  
  RDBMS를 쓸 것인가, 아니면 NoSQL을 쓸 것인가? 이 질문에 대한 올바른 답을 하기 위해 중요하게 따져야할 것은  
  데이터의 유형과 읽기/쓰기 연산의 패턴이다.

- 채팅 시스템이 다루는 데이터는 보통 두 가지다. 첫 번째는 사용자 프로필, 설정, 친구 목록처럼 일반적인 데이터다.  
  이런 데이터는 안정성을 보장하는 RDBMS에 보관한다. 다중화(replication)와 sharding은 이런 데이터의 가용성과 규모 확장성을  
  보증하기 위해 보편적으로 사용하는 기술이다.

- 두 번째 유형의 데이터는 채팅 시스템에 고유한 데이터로, 바로 채팅 이력이다.  
  이 데이터를 어떻게 보관할지 결정하려면 읽기/쓰기 연산의 패턴을 이해해야 한다.

  - 채팅 이력 데이터의 양은 엄청나다. Facebook은 매일 대략 600억 개의 메시지를 처리한다.
  - 이 데이터 가운데 빈번하게 사용되는 것은 주로 최근에 주고받은 메시지이다.  
    대부분의 사용자는 오래된 메시지는 들여다보지 않는다.
  - 사용자는 대체로 최근에 주고받은 메시지 데이터만 보게 되는 것이 사실이나, 특정 메시지로 jump하거나 특정 사용자가 mention된 메시지를  
    보거나하여 무작위적인 데이터에 접근하게 되는 일도 있다. 데이터 계층은 이런 기능도 지원해야 한다.
  - 1:1 채팅 앱의 경우, 읽기 쓰기 비율은 대략 1:1 정도다.

- 위 모두를 지원할 데이터베이스를 고르는 것은 아주 중요한 일이다.  
  이 설계안의 경우에는 key-value store를 추천할 것인데, 이유는 아래와 같다.

  - Key-value store는 horizontal scaling이 쉽다.
  - Key-value store는 latency가 낮다.
  - RDBMS는 데이터 가운데 long tail에 해당하는 부분을 잘 처리하지 못하는 경향이 있다.  
    index가 커지면 데이터에 대한 무작위적 접근(random access)을 처리하는 비용이 늘어난다.
  - 이미 많은 안정적인 채팅 시스템이 key-value store를 채택하고 있다. Facebook 메신저나 Discord가 그 사례다.  
    Facebook 메신저는 HBase를, Discord는 Cassandra를 사용하고 있다.

#### 데이터 모델

- Key-value store를 데이터 계층 기술로 사용하기로 했으니, 메시지 데이터를 어떻게 보관할 것인지 자세히 살펴보자.

##### 1:1 채팅을 위한 메시지 테이블

![picture 41](/images/SDI_CS_8.png)

- 위 그림은 1:1 채팅을 지원하기 위한 메시지 테이블의 사례다. 이 테이블의 primary key는 `message_id`로, 메시지 순서를 쉽게 정할 수 있도록  
  하는 역할도 담당한다. `created_at`을 사용해 메시지 순서를 정할 수는 없는데, 서로 다른 두 메시지가 동시에 만들어질 수도 있기 때문이다.

##### 그룹 채팅을 위한 메시지 테이블

![picture 42](/images/SDI_CS_9.png)

- 위 그림은 그룹 채팅을 위한 메시지 테이블의 사례다. `(channel_id, message_id)`의 composite key를 primary key로 사용한다.  
  여기서 channel은 채팅 그룹과 같은 뜻이다. `channel_id`는 partition key로도 사용할 것인데, 그룹 채팅에 적용될 모든 질의는  
  특정 channel을 대상으로 할 것이기 때문이다.

##### Message ID

- `message_id`를 만드는 기법은 자세히 논의해 볼 만한 가치가 있는 흥미로운 주제이다.  
  `message_id`는 메시지들의 순서도 표현할 수 있어야 한다. 그러기 위해서는 아래와 같은 속성들을 만족해야 할 것이다.

  - `message_id` 값은 unique 해야 한다.
  - ID 값은 정렬 가능해야 하며 시간 순서와 일치해야 한다. 즉, 새로운 ID는 이전 ID보다 큰 값이어야 한다.

- 위 두 조건을 어떻게 만족시킬 수 있을까? RDBMS라면 auto_increment가 대안이 될 수 있겠지만, NoSQL은 보통 해당 기능을 제공하지 않는다.

- 두 번째 방법은 Snowflake와 같은 전역젹 64-bit sequence number 생성기를 사용하는 것이다.

- 마지막 방법으로는 local sequence number generator를 이용하는 것이다.  
  여기서 _local_ 이라 함은, ID의 uniqueness는 같은 그룹 내에서만 보증하면 충분하다는 것이다.  
  이 방법이 사용 가능한 이유는 메시지 사이의 순서는 같은 channel, 혹은 같은 1:1 채팅방에서만 유지되면 충분하기 때문이다.  
  이 방법은 전역젹 ID 생성기에 비해 구현하기 쉬운 접근법이다.

---

## 상세 설계

- 개략적 설계안에 포함된 컴포넌트 가운데 몇 가지를 좀 더 자세히 들여다보자.  
  여기서 다루는 채팅 시스템의 경우에는 Service Discovery, 메시지 전달 흐름, 그리고 사용자 접속 상태를 표시하는 방법 정도가  
  좀 더 자세히 살펴볼만한 부분이다.

### Service Discovery

- Service discovery의 주된 역할은 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것이다.  
  이때 사용되는 기준으로는 클라이언트의 위치(geographical location), 서버의 용량(capacity) 등이 있다.  
  Service discovery를 구현하는 데 널리 쓰이는 오픈 소스 솔루션으로는 Apache Zookeeper 같은 것이 있다.  
  사용 가능한 모든 채팅 서버를 여기에 등록시켜 두고, 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의  
  채팅 서버를 골라주면 된다.

- 아래 그림은 Zookeeper로 구현한 Service Discovery 기능이 어떻게 동작하는지를 보여준다.

![picture 43](/images/SDI_CS_10.png)

- 작동 방식을 보자.

  - (1) 사용자 A가 시스템에 로그인을 시도한다.
  - (2) Load balancer가 로그인 요청을 API 서버들 가운데 하나로 보낸다.
  - (3) API 서버가 사용자 인증을 처리하고 나면 Service Discovery 기능이 동작해 해당 사용자를 서비스할 최적의 채팅 서버를 찾는다.  
    위 그림의 경우, 채팅 서버 2가 선택되어 사용자 A에게 반환되었다고 해보자.
  - (4) 사용자 A는 채팅 서버 2와 WebSocket connection을 맺는다.

### 메시지 흐름

#### 1:1 메시지 처리 흐름

- 아래 그림은 1:1 채팅에서 사용자 A가 B에게 보낸 메시지가 어떤 경로로 처리되는지를 보여준다.

![picture 44](/images/SDI_CS_11.png)

- 위 그림의 순서는 아래와 같다.

  - (1) 사용자 A가 채팅 서버 1로 메시지 전송
  - (2) 채팅 서버 1은 ID 생성기를 사용해 해당 메시지의 ID 결정
  - (3) 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
  - (4) 메시지를 key-value store에 저장
  - (5)
    - (a) 사용자 B가 접속 중인 경우, 메시지는 사용자 B가 접속중인 채팅 서버(채팅 서버 2)로 전송된다.
    - (b) 사용자 B가 접속 중이 아니라면, push 알림 메시지를 push 알림 서버로 보낸다.
  - (6) 채팅 서버 2는 메시지를 사용자 B에게 전송한다. 사용자 B와 채팅 서버 2 사이에는 WebSocket connection이 있는  
    상태이므로, 이를 이용한다.

#### 여러 단말 사이의 메시지 동기화

- 여러 개 단말을 사용하는 사람은 많다. 이제 여러 단말 사이에 메시지 동기화를 어떻게 처리할지 보자.

![picture 45](/images/SDI_CS_12.png)

- 위 그림에서 사용자 A는 전화기와 랩톱의 두 대 단말을 사용하고 있다.  
  사용자 A가 전화기에서 채팅 앱에 로그인한 결과로 채팅 서버 1과 해당 단말 사이에 WebSocket connection이 만들어져 있고,  
  랩톱에서 로그인한 결과로 역시 별도의 WebSocket connection이 채팅 서버 1에 연결되어 있는 상황이다.

- 각 단말은 `cur_max_message_id`라는 변수를 유지하는데, 해당 단말에서 관측된 가장 최신 메시지의 ID를 추적하는 용도다.  
  아래 두 조건을 만족하는 메시지는 새로운 메시지로 간주한다.

  - 수신자 ID가 현재 로그인한 사용자 ID와 같다.
  - key-value store에 보관된 메시지로서, 그 ID가 `cur_max_message_id` 보다 크다.

- `cur_max_message_id`는 단말마다 별도로 유지 관리하면 되는 값이라 key-value store에서 새로운 메시지를 가져오는 동기화 작업도  
  쉽게 구현할 수 있다.

#### 소규모 그룹 채팅에서의 메시지 흐름

- 1:1 채팅에 비해 그룹 채팅에서의 메시지 흐름은 조금 더 복잡하다.  
  우선 아래 그림을 보자.

![picture 46](/images/SDI_CS_13.png)

- 위 그림은 사용자 A가 그룹 채팅방에서 메시지를 보냈을 때 어떤 일이 벌어지는지를 보여준다.  
  해당 그룹에 3명의 사용자(A, B, C)가 있다고 해보자. 우선 사용자 A가 보낸 메시지가 사용자 B와 C의 메시지 동기화 큐(message sync queue)에  
  복사된다. 이 큐를 사용자 각각에 할당된 메시지 수신함 같은 것으로 생각해도 무방하다. 이 설계안은 소규모 그룹 채팅에 적합한데, 그 이유는 아래와 같다.

  - 새로운 메시지가 왔는지 확인하려면 자신의 큐만 보면 되니, 메시지 동기화 flow가 단순한다.
  - 그룹이 크지 않으면 메시지를 수신자별로 복사해 큐에 넣는 작업의 비용이 문제되지 않는다.

- WeChat이 위와 같은 접근법을 사용하고 있으며, 그룹의 크기는 500명으로 제한하고 있다. 하지만 많은 사용자를 지원해야 하는 경우라면 똑같은 메시지를  
  모든 사용자의 큐에 복사하는 것은 바람직하지 않을 것이다.

- 위의 과정을 수신자 관점에서 살펴보면, 한 수신자는 여러 사용자로부터 오는 메시지를 수신할 수 있어야 한다.  
  따라서 각 사용자의 수신함, 즉 메시지 동기화 큐는 아래 그림과 같이 여러 사용자로부터 오는 메시지를 받을 수 있어야 한다.

![picture 47](/images/SDI_CS_14.png)

### 접속 상태 표시

- 사용자의 접속 상태를 표시하는 것은 상당수 채팅 애플리케이션의 핵심적 기능이다.

- 개략적 설계안에서는 presence server(접속 상태 서버)를 통해 사용자의 상태를 관리한다고 했었다.  
  여기서 유의할 점은 presence server도 클라이언트와 WebSocket으로 통신하는 실시간 서비스의 일부라는 점이다.  
  사용자의 상태가 바뀌는 몇 가지 시나리오가 있는데, 하나씩 살펴보자.

#### 사용자 로그인

- 사용자 로그인 절차에 대해서는 Service Discovery를 볼 때 다뤘다. 클라이언트와 실시간 서비스(real-time service) 사이에 WebSocket  
  Connection이 맺어지고 나면 서버는 사용자 A의 상태와 `last_active_at` timestamp 값을 key-value store에 보관한다.  
  이 절차가 끝나고 나면, 해당 사용자는 접속 중인 것으로 표시될 것이다.

![picture 48](/images/SDI_CS_15.png)

#### 로그아웃

- 사용자가 로그아웃을 하면, 아래 그림과 같은 절차를 거친다. Key-value store에 보관된 사용자 상태가 online에서 offline으로 바뀌게 된다는  
  점에 유의하자. 이 절차가 끝나고 나면, UI 상에서 해당 사용자의 상태는 접속 중이 아닌 것으로 표시될 것이다.

![picture 49](/images/SDI_CS_16.png)

#### 접속 장애

- 인터넷을 통한 연결은 항상 안정적일 수 없다. 따라서 그런 상황에 대응할 수 있는 설계를 준비해야 한다.  
  사용자의 인터넷이 끊어지면 클라이언트와 서버 사이에 맺어진 WebSocket 같은 지속성 연결도 끊어진다.  
  이런 장애에 대응하는 간단한 방법은 사용자를 오프라인 상태로 표시하고, 연결이 복구되면 온라인 상태로 변경하는 것이다.  
  하지만 이 방식에는 심각한 문제가 있다. 짧은 시간 동안 인터넷 연결이 끊어졌다 복구되는 일이 매우 흔하기 때문이다.  
  따라서 이런 일이 벌어질 때마다 사용자의 접속 상태를 변경한다면, 그것은 지나친 일일 것이고, UX 측면에서도 바람직하지 않을 것이다.

- 이 설계안에서는 heartbeat 검사를 통해 이 문제를 해결할 것이다. 즉, 온라인 상태의 클라이언트로 하여금 주기적으로 heartbeat event를  
  presence server로 보내도록 하고, 마지막 이벤트를 받은지 x초 이내에 또다른 heartbeat event 메시지를 받으면 해당 사용자의 접속상태를  
  계속 온라인으로 유지하는 것이다. 그렇지 않을 경우에만 오프라인으로 상태를 바꾼다.

- 아래 그림에 등장하는 클라이언트는 heartbeat event를 매 5초마다 서버로 보낸다. 그런데 이벤트를 3번 보낸 후, `x = 30`초 동안 아무런  
  메시지를 보내지 않아서 오프라인 상태로 변경되었다.

![picture 50](/images/SDI_CS_17.png)

#### 상태 정보의 전송

- 그렇다면 사용자 A와 친구 관계에 있는 사용자들은 어떻게 A의 상태 변화를 알게 될까?  
  Presence sever는 publish-subscribe model을 사용하는데, 즉 각각의 친구관계마다 channel을 하나씩 두는 것이다.  
  가령 사용자 A의 접속상태가 변경되었다고 해보자. 그 사실을 3개의 채널, 즉 `A-B`, `A-C`, `A-D`에 쓰는 것이다.  
  그리고 `A-B`는 B가 구독하고, `A-C`는 C가, 그리고 `A-D`는 사용자 D가 구독하도록 하는 것이다.  
  이렇게 하면 친구 관계에 있는 사용자가 상태정보 변화를 쉽게 통지 받을 수 있게 된다.  
  클라이언트와 서버 사이의 통신에는 실시간 WebSocket을 사용한다.

![picture 51](/images/SDI_CS_18.png)

- 이 방안은 그룹의 크기가 작을 때는 효과적이다. WeChat은 그룹 크기의 상한을 500명으로 제한하고 있어서, 이와 유사한 접근법을  
  사용할 수 있었다. 그룹 크기가 더 커지면 이런 식으로 접속 상태 변화를 알려서는 비용이나 시간이 많이 들게 되므로 좋지 않다.  
  가령 그룹 하나에 100,000명의 사용자가 있다고 해보자. 그러면 상태변화 1건당 100,000 개의 이벤트 메시지가 발생할 것이다.  
  이런 성능 문제를 해소하는 한 가지 방법은 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나,  
  친구 리스트에 있는 사용자의 접속 상태를 갱신하고 싶으면 manually(수동으로) 하도록 유도하는 것이다.

---

## 마무리

- 이번 장에서는 1:1 채팅과 그룹 채팅을 모두 지원하는 채팅 시스템의 아키텍쳐를 살펴보았다.  
  클라이언트와 서버 사이의 실시간 통신을 가능하도록 하기 위해 WebSocket을 사용했으며, 실시간 messaging을 지원하는 채팅 서버,  
  접속 상태 서버, push 알림 서버, 채팅 이력을 보관할 key-value store, 그리고 이를 제외한 나머지 기능을 구현하는 데 쓰일  
  API 서버 등이 그 주요 컴포넌트였다.

- 아래의 항목들도 더 논의해볼만 하다.

  - 채팅 앱을 확장해 사진, 비디오 등의 미디어를 지원하도록 하는 방법

    - 미디어 파일은 텍스트에 비해 크기가 크다. 그와 관련해 압축 방식, 클라우드 저장소, thumbnail 생성 등을 생각해보자.

  - 종단 간 암호화: WhatsApp은 메시지 전송에 있어 end-to-end encryption을 지원한다.  
    메시지 발신인과 수신자 이외에는 아무도 메시지 내용을 볼 수 없다는 뜻이다.

  - 캐시: 클라이언트에 이미 읽은 메시지를 캐시해두면, 서버와 주고받은 데이터량을 줄일 수 있다.
  - 로딩 속도 개선: Slack은 사용자의 데이터, channel 등을 지역적으로 분산하는 네트워크를 구축해 앱 로딩 속도를 줄였다.
  - 오류 처리
    - 채팅 서버 오류: 채팅 서버 하나에 수십만 사용자가 접속해 있는 상황을 생각해보자. 그런 서버 하나가 죽으면, Service Discovery 기능이  
      동작해 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있도록 해야 한다.
    - 메시지 재전송: retry나 queue는 메시지의 안정적 전송을 보장하기 위해 흔히 사용되는 기법이다.

---
