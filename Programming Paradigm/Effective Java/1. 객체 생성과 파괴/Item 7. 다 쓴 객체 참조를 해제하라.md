# 다 쓴 객체 참조를 해제하라

- C, C++ 처럼 메모리를 직접 관리해야 하는 언어를 쓰다가 Java처럼 GC를 갖춘 언어로 넘어오면, 프로그래머로써의  
  삶이 훨씬 평안해진다. 다 쓴 객체를 GC가 알아서 회수해 가기 때문이다. 이는 개발자가 메모리 관리에 더 이상  
  신경쓰지 않아도 된다고 오해를 일으킬 수 있는데, 아래 코드를 보자.

```java
public class Stack {
	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;

	public Stack() {
		elements = new Object[DEFAULT_INITIAL_CAPACITY];
	}

	public void push(Object o) {
		ensureCapacity();
		elements[size++] = o;
	}

	public Object pop() {
		if(size == 0) {
			throw new EmptyStackException();
		}
		return elements[--size];
	}

	/**
	* 원소를 위한 공간을 적어도 1개 이상 확보한다.
	* 배열 크기를 늘려야할 때마다 대략 2배씩 늘린다.
	*/
	private void ensureCapacity() {
		if(elements.length == size) {
			elements = Arrays.copyOf(elements, size * 2 + 1);
		}
	}
}
```

- 위 `Stack`의 코드에서 특별한 문제점은 보이지 않는다. 하지만 위 코드에는 **메모리 누수** 가 일어난다.  
  이 Stack을 사용하는 프로그램을 오래 실행하다 보면 점차 GC 활동과 메모리 사용량이 늘어나 결국에는  
  성능이 저하될 것이다. 상대적으로 드문 경우이긴 하지만, 디스크 페이징이나 `OutOfMemoryError`를 일으켜  
  프로그램이 예기치 않게 종료될 수도 있다.

- 그렇다면 위 코드에서 메모리 누수는 어디에서 일어날까? 위 코드에서는 Stack이 커졌다가 줄어들 때  
  Stack에서 꺼내진 객체들을 GC가 회수하지 않는다. 프로그램에서 그 객체들을 더 이상 사용하지 않더라도 말이다.  
  이 Stack이 그 객체들의 다 쓴 참조(Obsolete Reference)를 여전히 갖고 있기 때문이다.  
  여기서 *다 쓴 참조*란 문자 그대로 다시 쓰지 않을 참조를 뜻한다.  
  위 코드에서는 elements 배열의 _활성 영역_ 밖의 참조들이 모두 여기에 해당한다.  
  활성 영역은 인덱스가 size보다 작은 원소들로 구성된다.

- GC가 지원되는 언어에서는 의도치 않게 객체를 살려두게 됨으로써 발생하는 메모리 누수를 찾기가 매우 까다롭다.  
  객체 참조 하나를 살려두면, GC는 그 객체 뿐 아니라 그 객체가 참조하는 객체, 또 그 객체가 참조하는 객체들을  
  모두 회수해가지 못한다. 그래서 단 몇 개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고,  
  잠재적으로 성능에 큰 악영향을 줄 수 있다.

- 그렇다면 이를 어떻게 해결할 수 있을까?  
  해법은 간단한데, 해당 참조를 다 썼을 때 null 처리(참조 해제)하면 된다.  
  위의 `Stack` 클래스에서 각 원소의 참조가 더 이상 필요 없어지는 시점은 Stack에서 꺼내질 때이다.  
  아래는 메모리 누수가 나지 않도록 수정한 `pop()` 메소드이다.

```java
public class Stack {
	//..

	public Object pop() {
		if(size == 0) throw new EmptyStackException();
		Object result = elements[--size];
		elements[size] = null;
		return result;
	}
}
```

- 다 쓴 참조를 null 처리하면 다른 이점도 따라온다. 만약 null 처리한 참조를 실수로 사용하려 하면  
  프로그램은 즉시 `NullPointerException`을 던지며 종료된다. 이와 같은 프로그램 오류는 가능한 한  
  조기에 발견하는 것이 좋다.

- 하지만 그렇다고 모든 객체를 다 쓰자마자 null 처리를 하는 것은 오히려 좋지 않다.  
  왜냐하면 그럴 필요가 없을 뿐만 아니라 프로그램을 필요 이상으로 지저분하게 만들기 때문이다.  
  **객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.** 다 쓴 참조를 해제하는 가장 좋은 방법은  
  그 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것이다. 개발자가 변수의 범위를 최소가 되게  
  정의했다면, 이는 자연스럽게 이루어진다.

- 그렇다면 null 처리는 언제 해야하며, 위에서 본 `Stack` 클래스는 왜 메모리 누수에 취약한걸까?  
  이는 바로 `Stack`이 **자신의 메모리를 직접 관리하기 때문** 이다. 이 스택은 객체 자체가 아니라 객체들의 참조를 담는  
  elements 배열로 저장소 풀을 만들어 원소들을 관리한다. 배열의 활성 영역에 속한 원소들이 사용되고, 비활성 영역은  
  쓰이지 않는다. 논리상의 문제는 전혀 없지만 진짜 문제는 GC가 이를 알 길이 전혀 없다는 것이다.  
  GC가 보기에는 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체이다. 비활성 영역의 객체가 더 이상 쓸모없다는건  
  프로그래머만 아는 사실이다. 그러므로 프로그래머는 비활성 영역이 되는 순간 null 처리해서 해당 객체를 더 이상 쓰지  
  않을 것임을 GC에 알려야 한다.

- 일반적으로 **자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항상 메모리 누수에 주의** 해야 한다.  
  원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리해 줘야 한다.

- 캐시 역시 메모리 누수를 일으키는 주범이다. 객체 참조를 캐시에 넣고 나서, 이 사실을 잊어버린 채 그 객체를  
  다 쓴 뒤로도 한참을 그냥 놔두는 일을 자주 접할 수 있다. 해법은 여러 가지이다. 운 좋게 캐시 외부에서  
  key를 참조하는 동안만 (value가 아니다.) 엔트리가 살아 있는 캐시가 필요한 상황이라면 `WeakHashMap`을  
  사용해 캐시를 만들자. 다 쓴 엔트리는 그 즉시 자동으로 제거될 것이다. 단, `WeakHashMap`은 이러한 상황에서만  
  유용하다는 사실을 기억하자.

- 캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의  
  가치를 떨어뜨리는 방식을 흔히 사용한다. 이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해줘야 한다.  
  `ScheduledThreadPoolExecutor`와 같은 백그라운드 스레드를 활용하거나, 캐시에 새로운 엔트리가  
  추가될 때 부수 작업으로 수행하는 방법이 있다. `LinkedHashMap`은 `removeEldestEntry()` 메소드를  
  써서 후자의 방식으로 처리한다. 더 복잡한 캐시를 만들고 싶다면 `java.lang.ref` 패키지를 직접 활용해야 한다.

- 메모리 누수의 세 번째 주범은 바로 listener 또는 callback이다. 클라이언트가 callback을 등록만 하고  
  명확히 해지하지 않는다면 뭔가 조치를 해주지 않는 한 callback은 계속 쌓여질 것이다.  
  이럴 때 callback을 약한 참조(weak reference)로 저장하면, GC가 즉시 수거해간다.  
  예를 들어 `WeakHashMap`에 key로 저장하면 된다.

---

## 핵심 정리

- 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다.  
  이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다.  
  그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.

---
