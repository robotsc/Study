# 비동기 메시징 패턴 응용 통신

- 메시징은 서비스가 메시지를 서로 비동기적으로 주고 받는 통신 방식이다.  
  메시징 기반 애플리케이션은 보통 서비스 간 중개 역할을 하는 메시지 브로커를 사용하지만  
  서비스가 직접 서로 통신하는 Brokerless 아키텍쳐도 있다. 클라이언트가 서비스에 메시지를 보내  
  요청을 하면, 요청을 받은 서비스 인스턴스가 응답 가능할 경우 별도의 메시지를 클라이언트에게 응답한다.  
  비동기 통신을 하기 때문에 클라이언트가 응답을 기다리며 블로킹하지 않는다.  
  클라이언트는 응답을 바로 받지 못할 것이라는 전제 하에 작성한다.

<h2>메시징 개요</h2>

- 메시징 모델에 따르면 메시지는 메시지 채널(Message Channel)을 통해 교환된다.  
  송신자(애플리케이션 또는 서비스)가 채널에 메시지를 쓰면 수신자(애플리케이션 또는 서비스)는 채널에서  
  메시지를 읽는다. 우선 메시지와 채널이 각각 무엇인지 살펴보자

<h3>메시지</h3>

- 메시지는 Header와 Body로 구성된다. Header는 송신된 데이터에 대한 메타데이터에 해당하는 키/값들로  
  구성된다. 그 밖에도 송신자 또는 메시징 인프라에서 생성된 메시지 ID, 응답이 출력될 메시지 채널을 가리키는  
  반환 주소(Optional) header가 있다. 메시지 Body는 실제로 송신할 텍스트 또는 이진 포맷의 데이터이다.

- 메시지의 종류는 다양하다.

  - **문서(Document)** : 데이터만 포함한 제네릭한 메시지(ex. 커맨드에 대한 응답).  
    메시지를 어떻게 해석할지는 수신자가 결정한다.
  - **커맨드(Command)** : RPC 요청과 동등한 메시지. 호출할 작업과 전달할 매개변수가 지정되어 있다.
  - **이벤트(Event)** : 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 이벤트는 대부분  
    `Order`, `Customer`와 같은 도메인 객체의 변화를 나타내는 도메인 이벤트이다.

<h3>메시지 채널</h3>

- 메시지는 채널을 통해 교환된다. 송신자의 비즈니스 로직은 하부 통신 메커니즘을 캡슐화한 송신 포트 인터페이스를  
  호출한다. 이 인터페이스는 메시지 송신자 어댑터 클래스로 구현되며, 이 클래스는 메시징 인프라를 추상한 메시지  
  채널을 통해 수신자에게 메시지를 전달한다. 수신자의 메시지 handler 어댑터 클래스는 메시지를 처리하기 위해  
  호출되고, 이 클래스는 Consumer 비즈니스 로직으로 구현된 수신 포트 인터페이스를 호출한다.  
  송신자가 채널에 보낼 수 있는 메시지와 수신자가 채널에서 받을 수 있는 메시지의 개수는 무제한이다.

- 채널은 두 종류가 있다.

  - **점대점(Point-To-Point)채널** : 채널을 읽는 consumer 중 딱 하나만 지정하여 메시지를 전달한다.  
    앞서 본 일대일 상호 작용 스타일의 서비스가 이 채널을 사용한다.(ex. 커맨드 메시지)
  - **발행-구독(Publish-Subscribe)채널** : 같은 채널을 바라보는 모든 Consumer에 메시지를 전달한다.  
    앞서 본 일대다 상호 작용 스타일의 서비스가 이 채널을 사용한다.

<hr/>

<h2>메시징 상호 작용 스타일 구현</h2>

- 메시징은 앞서 설명한 상호 작용 스타일을 모두 지원할 만큼 아주 유용하다.  
  스타일에 따라 메시징으로 직접 구현 가능한 것도 있고, 메시징을 토대로 구현해야 하는 것도 있다.

<h3>요청/응답 및 비동기 요청/응답</h3>

- 요청/응답, 비동기 요청/응답 방식 모두 클라이언트가 요청을 보내면 서비스는 응답을 반환한다.  
  요청/응답은 서비스가 즉시 응답할 것이라고 클라이언트가 기대하지만 비동기 요청/응답은 클라이언트가  
  그런 기대를 하지 않는다. 메시징은 원래 성격 자체가 비동기적이라서 비동기 요청/응답만 제공하지만  
  응답을 수신할 때까지 클라이언트를 블로킹할 수도 있다.

- 클라이언트/서비스는 한 쌍의 메시지를 주고받는 비동기 요청/응답 스타일로 상호 작용한다.  
  먼저 클라이언트는 수행할 작업과 매개변수가 담긴 커맨드 메시지를 서비스가 소유한 점대점 메시징 채널에  
  보낸다. 그러면 서비스는 요청을 처리한 후 그 결과가 담긴 응답 메시지를 클라이언트가 소유한  
  점대점 채널로 돌려보낸다.

- 클라이언트는 서비스가 어디로 응답 메시지를 보내야 하는지 알려주고 이렇게 받은 응답 메시지는 요청과  
  짝이 맞아야 한다. 다행이 이 두가지는 어렵지 않게 해결할 수 있다.  
  클라이언트는 `MessageId` 및 응답 채널이 header에 명시된 커맨드 메시지를 보내고,  
  서버는 `MessageId` 값이 동일한 `CorrelationId`가 포함된 응답 메시지를 지정된 응답 채널에 쓰면 된다.  
  클라이언트는 이 `CorrelationId`를 이용하여 응답 메시지와 요청을 맞춰볼 수 있다.

- 본래 메시징으로 통신하는 클라이언트/서비스 간 상호 작용은 비동기적이다.  
  이론적으로 클라이언트가 응답을 수신할 때까지 블로킹할 수는 있지만, 실제로 클라이언트는 응답을  
  비동기 처리하고 클라이언트 인스턴스 중 하나가 응답을 처리한다.

<h3>단방향 알림</h3>

- 단방향 알림(One-way notification)은 비동기 메시징을 이용하여 직관적으로 구현할 수 있다.  
  서비스가 소유한 점대점 채널로 클라이언트가 커맨드 메시지를 보내면, 서비스는 이 채널을 구독해서  
  메시지를 처리하는 구조이다. 물론 단방향이므로 서비스는 응답을 반환하지 않는다.

<h3>발행/구독</h3>

- 메시징은 발행/구독 스타일의 상호 작용을 기본 지원한다. 클라이언트는 여러 consumer가 읽는  
  발행/구독 채널에 메시지를 발행하고, 서비스는 도메인 객체의 변경 사실을 알리는 도메인 이벤트를 발행한다.  
  이렇게 도메인 이벤트를 발행한 서비스는 해당 도메인 클래스의 이름을 딴 발행/구독 채널을 소유한다.  
  가령 주문 서비스는 `Order` 이벤트를 `Order` 채널에 발행하고, 배달 서비스는 `Delivery` 이벤트를  
  `Delivery` 채널에 발행한다. 서비스는 자신이 관심 있는 도메인 객체의 채널을 구독한다.

<h3>발행/비동기 응답</h3>

- 발행/비동기 응답 스타일은 발행/구독과 요청/응답의 엘리먼트를 조합한 고수준의 상호 작용 스타일이다.  
  클라이언트는 응답 채널 header가 명시된 메시지를 발행/구독 채널에 발행하고, consumer는 `CorrelationId`가  
  포함된 응답 메시지를 지정된 응답 채널에 쓴다. 클라이언트는 이 `CorrelationId`로 응답을 취합하여  
  응답 메시지와 요청을 맞추어본다.

- 비동기 API를 갖고 있는 애플리케이션 서비스는 지금까지 본 기법 중 적어도 하나는 응용한다.  
  비동기 API로 작업을 호출하는 서비스에는 요청용 메시지 채널이 있고, 이벤트를 발행하는 서비스는 이벤트 메시지 채널에  
  이벤트를 발행할 것이다.

<hr/>

<h2>메시징 기반 서비스의 API 명세 작성</h2>

- 서비스의 비동기 API 명세에는 메시지 채널과, 각 채널을 통해 교환되는 메시지 타입과 포맷을 명시하고,  
  메시지 포맷은 JSON, XML, Protocol Buffer 등 표준 포맷으로 기술해야 한다.  
  그러나 REST, Open API와 달리 채널 및 메시지 타입은 딱히 정해진 문서화 표준이 없으므로  
  자유롭게 기술하면 된다.

- 서비스 비동기 API는 클라이언트가 호출하는 작업과 서비스에 의해 발행되는 이벤트로 구성된다.  
  작업과 이벤트는 문서화하는 방법이 다르다.

<h3>비동기 작업 문서화</h3>

- 서비스 작업은 두 가지 상호 작용 스타일 중 하나로 호출할 수 있다.

  - 요청/비동기 응답 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷,  
    서비스가 반환하는 응답 메시지의 타입과 포맷으로 구성된다.
  - 단방향 알림 스타일 API: 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷으로 구성된다.

- 서비스는 요청/비동기 응답, 단방향 알림 모두 동일한 요청 채널을 사용할 수 있다.

<h3>발행 이벤트 문서화</h3>

- 서비스는 발행/구독 스타일로도 이벤트를 발행할 수 있다.  
  이런 스타일의 API 명세는 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성된다.

- 메시지, 메시징의 채널 모델은 서비스 비동기 API를 설계하는 좋은 수단이지만, 서비스를 구현하려면 메시징 기술을  
  선택하고 그 기술이 가진 기능으로 어떻게 설계할지 방향을 잡아야 한다.  
  메시징 기술을 하나씩 구체적으로 살펴보자.

<hr/>

<h2>메시지 브로커</h2>

- 메시징 기반의 애플리케이션은 대부분 메시지 브로커를 사용한다.  
  메시지 브로커는 서비스가 서로 통신할 수 있게 해주는 인프라 서비스이다.  
  물론 서비스가 서로 직접 통신하는 Brokerless 기반의 메시징 아키텍쳐도 있다.  
  제각기 장단점이 있지만, 일반적으로 브로커 기반의 아키텍쳐가 더 낫다.

<h3>브로커리스(Brokerless) 메시징</h3>

- Brokerless 아키텍쳐의 서비스는 메시지를 서로 직접 교환한다.  
  ZeroMQ는 잘 알려진 brokerless 메시징 기술이다. 그 자체가 명세이자, 여러 언어를  
  지원하는 라이브러리 세트이다. TCP, Unix형 Domain Socket, Multicast 등 다양한  
  전송 기술을 지원한다.

- Brokerless 아키텍쳐는 아래와 같은 장점들이 있다.

  - 송신자가 보낸 메시지가 브로커를 거쳐 수신자로 이동하는 것이 아니라, 송신자에서  
    수신자로 직접 전달되므로 네트워크 트래픽이 가볍고 지연 시간이 짧다.
  - 메시지 브로커가 성능 병목점이나 SPOF(Single Point Of Failure)가 될 일이 없다.
  - 메시지 브로커를 설정/관리할 필요가 없으므로 운영 복잡도가 낮다.

- 하지만 아래와 같은 중요한 단점도 있다.

  - 서비스가 서로의 위치를 알고 있어야 하므로 서비스 디스커버리 메커니즘 중  
    하나를 사용해야 한다.
  - 메시지 교환 시 송신자/수신자가 모두 실행 중이어야 하므로 가용성이 떨어진다.
  - 전달 보장(Guaranteed Delivery) 같은 메커니즘을 구현하기가 더 어렵다.

- 가용성 저하 및 서비스 디스커버리가 필요한 것은 사실 동기 요청/응답을 사용하는 방식도  
  별반 다르지 않다. 이런 한계 때문에 엔터프라이즈 애플리케이션은 대부분 메시지 브로커 기반의  
  아키텍쳐를 선호한다.

<h3>브로커 기반 메시징 개요</h3>

- 메시지 브로커는 모든 메시지가 지나가는 중간 지점이다. 송신자가 메시지 브로커에 메시지를 쓰면 메시지 브로커는  
  메시지를 수신자에게 전달한다. 메시지 브로커의 가장 큰 장점은 송신자가 consumer의 네트워크 위치를  
  몰라도 된다는 것이다. 또 consumer가 메시지를 처리할 수 있을 때까지 메시지 브로커에 메시지를  
  버퍼링할 수도 있다.

- 메시지 브로커 제품은 다양하다. 아래는 많이 쓰는 오픈 소스 메시지 브로커들이다.

  - ActiveMQ
  - RabbitMQ
  - Apache Kafka

- AWS Kinesis, AWS SQS 등 클라우드 기반의 메시징 서비스도 있다.

- 메시지 브로커를 선택할 때에는 아래 항목들을 잘 검토해야 한다.

  - 프로그래밍 언어 지원 여부: 다양한 프로그래밍 언어를 지원할 수록 좋다.
  - 메시징 표준 지원 여부: AMQP나 STOMP 등 표준 프로토콜을 지원하는 제품인가, 아니면 자체 표준만  
    지원하는 제품인가?
  - 메시지 순서: 메시지의 순서가 유지되는가?
  - 전달 보장: 어떤 종류의 전달 보장을 하는가?
  - 영속화: 브로커가 고장나도 문제가 없도록 메시지를 디스크에 저장하는가?
  - 내구성: consumer가 메시지 브로커에 다시 접속할 경우, 접속이 중단된 시간에 전달된  
    메시지를 받을 수 있나?
  - 확장성: 얼마나 확장성이 좋은가?
  - 지연 시간: 종단 간 지연 시간은 얼마나 되나?
  - 경쟁사 consumer: 경쟁사의 consumer를 지원하는가?

- 여러 가지 고려할 포인트들 중 **메시징 순서 유지 및 확장성**은 필수 요건이다.

<h3>메시지 브로커로 메시지 채널 구현</h3>

- 메시지 채널은 메시지 브로커마다 구현 방식이 조금씩 다르다.

| 메시지 브로커      | 점대점 채널      | 발행-구독 채널                   |
| ------------------ | ---------------- | -------------------------------- |
| JMS                | Queue            | Topic                            |
| Apache Kafka       | Topic            | Topic                            |
| AMQP(ex. RabbitMQ) | Exchange + Queue | Fanout Exchange + Consumer Queue |
| AWS Kinesis        | Stream           | Stream                           |
| AWS SQS            | Queue            | -                                |

<h3>브로커 기반 메시징의 장단점</h3>

- 브로커 기반의 메시징은 여러모로 장점이 많다.

  - 느슨한 결합: 클라이언트는 적절한 채널에 그냥 메시지를 보내는 식으로 요청한다. 클라이언트는 서비스 인스턴스를  
    몰라도 되므로 서비스 인스턴스 위치를 알려주는 디스커버리 메커니즘도 필요 없다.

  - 메시지 버퍼링: 메시지 브로커는 처리 가능한 시점까지 메시지를 버퍼링한다. HTTP 같은 동기 요청/응답  
    프로토콜을 사용하면 교환이 일어나는 동안 클라이언트/서비스 모두 가동 중이어야 하지만, 메시징을 쓰면  
    consumer가 처리할 수 있을 때 까지 그냥 큐에 메시지가 쌓인다. 덕분에 예를 들어 온라인 상점에서  
    주문 이행 시스템에 느려지거나 불능 상태에 빠지더라도 consumer는 계속 주문을 접수할 수 있다.  
    그냥 언젠가는 처리될 것이라 간주하고 메시지를 차곡차곡 쌓아두는 것이다.

  - 유연한 통신: 메시징은 지금까지 본 모든 상호 작용 스타일을 지원한다.

- 반대로 단점은 아래와 같다.

  - 성능 병목 가능성: 메시지 브로커가 성능 병목점이 될 위험이 있다. 하지만 다행이 요즘 메시지 브로커는  
    대부분 확장이 잘 되도록 설계되었다.
  - 단일 장애점 가능성: 메시지 브로커는 가용성이 높아야 한다. 그렇지 않으면 시스템의 신뢰성에 흠이 갈 수 있다.  
    다행이 요즘 브로커는 대부분 고가용성이 보장되도록 설계되었다.
  - 운영 복잡도 증가: 메시징 시스템 역시 설치, 구성, 운영해야할 시스템 컴포넌트이다.

<hr/>

<h2>수신자 경합과 메시지 순서 유지</h2>

- 메시지 순서를 유지한 채 메시지 수신자를 Scale-out 할 수 있을까?  
  일반적으로 메시지를 동시 처리하려면 서비스 인스턴스를 여러 개 두어야 한다.  
  물론 단일 서비스 인스턴스라도 스레드를 이용하면 여러 메시지를 동시 처리할 수 있지만,  
  다수의 스레드와 서비스 인스턴스를 동원하면 애플리케이션 처리율이 증가한다.  
  그런데 이렇게 메시지를 동시 처리하면 각 메시지를 정확히 한 번만 순서대로 처리해야 한다.

- 예를 들어 동일한 점대점 채널을 읽는 서비스 인스턴스가 3개 있고, 송신자는 _주문 생성됨_, _주문 변경됨_,  
  _주문 취소됨_ 이벤트 메시지를 차례로 전송한다고 하자. 단순하게 보면 메시지를 종류별로 정해진 수신자에  
  동시 전달하면 될 것 같지만, 갖가지 네트워크 이슈나 GC 문제로 지연이 발생하고 메시지 처리 순서가 어긋나면  
  시스템에 오동작할 수 있다. 다른 서비스가 _주문 생성됨_ 메시지를 처리하기도 전에 _주문 취소됨_  
  메시지를 처리하게 될 수도 있다는 것이다.

- 그래서 Apache Kafka, AWS Kinesis 등의 요즘 메시지 브로커는 Sharding된 채널을 이용한다.

- 솔루션은 아래 세 부분으로 구성된다.

  - Sharding된 채널은 복수의 Shard로 구성되며, 각 Shard는 채널처럼 작동한다.
  - 송신자는 메시지 헤더에 Shard Key(보통 무작위 문자열 또는 바이트)를 지정한다.  
    메시지 브로커는 메시지를 Shard Key별로 Shard에 배정한다. 예를 들어 Shard Key 해시 값을  
    Shard의 개수로 나눈 나머지를 계산해서 Shard를 선택하는 방식이다.
  - 메시징 브로커는 여러 수신자 인스턴스를 묶어 마치 동일한 논리 수신자처럼 취급한다.  
    (이를 Apache Kafka에서는 Consumer Group이라 한다.) 메시지 브로커는 각 Shard를 하나의  
    수신자에 배정하고, 수신자가 시동/종료하면 shard를 재배정한다.

> Sharding: Partitioning과 동일한 의미로, 이 문맥에서는 채널을 partitioning한다고 생각하면 된다.

- 예를 들어, 위에서 본 3개의 주문 관련 이벤트는 동일한 OrderId를 가질 것이다.  
  이 OrderId를 각 주문 이벤트 메시지의 Shard Key로 사용하면, 주문별 이벤트는 각각 동일한 Shard에  
  발행되고, 어느 한 consumer 인스턴스만 메시지를 읽기 때문에 메시지 처리 순서가 보장된다.

<hr/>

<h2>중복 메시지 처리</h2>

- 중복 메시지 처리 문제도 골칫거리이다. 메시지 브로커가 각 메시지를 꼭 한번만 전달하면 좋겠지만  
  그렇게 강제하려면 그만큼 값비싼 대가를 치러야 한다. 그래서 메시지 브로커는 보통 **적어도 한 번 이상**  
  메시지를 전달하겠노라 약속한다.

- 시스템이 정상일 때 _적어도 한 번 전달_ 을 보장하는 메시지 브로커는 각 메시지를 한 번만 전달한다.  
  그러나 클라이언트나 네트워크 또는 브로커 자신이 실패할 경우, 같은 메시지를 여러 번 전달할 수도 있다.  
  메시지 처리 후 DB 업데이트까지 마쳤는데, 메시지를 ACK 하기 전에 클라이언트가 갑자기 멎었다고 해보자.  
  클라이언트가 재시동하면 메시지 브로커는 ACK 안된 메시지를 다시 보내거나, 다른 클라이언트 replica에  
  전송할 것이다.

- 메시지 브로커가 메시지를 재전송할 때 원래 순서까지 유지하면 이상적이다.  
  클라이언트가 _주문 생성됨_ 이벤트 => _주문 취소됨_ 이벤트를 순서로 처리하는데, 뭔가 문제가 발생해서  
  _주문 생성됨_ 이벤트의 ACK를 못 받았다고 하자. 나중에 메시지 브로커가 _주문 생성됨_ 이벤트만  
  재전송하면 클라이언트가 주문 취소를 Undo할 가능성이 있기 때문에 _주문 생성됨_, _주문 취소됨_ 이벤트를  
  모두 재전송해야 한다.

- 중복 메시지를 처리하는 방법은 아래 두 가지이다.

  - 멱등한(Idempotent) 메시지 핸들러를 작성한다.
  - 메시지를 추적하고 중복을 솎아 낸다.

<h3>멱등한 메시지 핸들러 작성</h3>

- 동일한 입력값을 반복 호출해도 아무런 부수 효과가 없을 때 _멱등하다(Idempotent)_ 고 말한다.  
  애플리케이션의 메시지 처리 로직이 멱등하면 중복 메시지는 전혀 해롭지 않다. 가령 이미 취소된 주문을  
  다시 취소하는 작업도 그렇고, 클라이언트가 전달한 ID로 주문을 생성하는 작업도 멱등하다.  
  메시지 재전송 시 메시지 브로커가 순서를 유지한다는 전제하에 멱등한 메시지 핸들러는 여러 번  
  실행해도 별 문제가 없다.

- 그러나 이렇게 멱등한 애플리케이션 로직은 실제로 별로 없다.  
  메시지를 다시 전송하면 순서를 보장하지 않는 메시지 브로커를 사용 중일지도 모른다.  
  중복 메시지와 순서가 맞지 않는 메시지는 오류를 일으키기 때문에 중복 메시지를 솎아내는  
  메시지 핸들러가 필요하다.

<h3>메시지 추적과 중복 메시지 솎아내기</h3>

- 소비자 신용카드를 승인하는 메시지 핸들러가 있다고 해보자.  
  주문별로 정확히 1회 신용카드를 승인해야 할 것이다.  
  이런 종류의 애플리케이션 로직은 호출될 때마다 영향을 미치므로 중복 메시지 때문에 같은 로직이  
  여러 번 실행되면 문제가 심각해진다. 따라서 반드시 메시지 핸들러가 중복 메시지를 걸러 내서  
  멱등하게 동작하도록 만들어야 한다.

- Consumer가 메시지 ID를 이용하여 메시지 처리 여부를 추적하면서 중복 메시지를 솎아 내면 간단히 해결된다.  
  이를테면 Consumer가 소비하는 메시지 ID를 무조건 DB 테이블에 저장하면 될 것이다.

- Consumer는 메시지를 처리할 때 비즈니스 엔티티를 생성/수정하는 트랜잭션의 일부로 메시지 ID를  
  DB 테이블에 기록한다. 이 테이블을 `PROCESSED_MESSAGES` 이라 해보자.  
  그럼 consumer는 `PROCESSED_MESSAGES` 테이블에 메시지 ID가 포함된 row를 삽입할 것이다.  
  중복된 메시지라면 INSERT 쿼리가 실패하고 조용히 무시될 것이다.

- 전용 테이블 대신 일반 애플리케이션 테이블에 메시지 ID를 기록하는 방법도 있다.  
  한 DB 트랜잭션으로 두 테이블을 업데이트하는 일이 불가능한, 트랜잭션 모델이 제한적인 NoSQL DB를  
  사용할 때 유용한 방법이다.

<hr/>

<h2>트랜잭셔널 메시징</h2>

- 서비스는 보통 DB를 업데이트하는 트랜잭션의 일부로 메시지를 발행한다.  
  DB 업데이트와 메시지 전송을 한 트랜잭션으로 묶지 않으면, DB 업데이트 후 메시지는  
  아직 전송되지 않은 상태에서 서비스가 중단될 수 있기 때문에 문제가 된다.  
  이 두 작업이 서비스에서 원자적으로 수행되지 않으면 시스템이 실패할 경우  
  아주 불안정한 상태가 될 것이다.

- 예전에는 DB와 메시지 브로커에 분산 트랜잭션을 적용했었지만, 요즘 애플리케이션에  
  분산 트랜잭션은 더 이상 어울리지 않는다. 더구나 현대 메시지 브로커(Apache Kafka 등)는  
  대부분 분산 트랜잭션을 지원하지도 않는다.

- 애플리케이션에서 메시지를 확실하게 발행하려면 어떻게 해야 할지 알아보자.

<h3>DB 테이블을 메시지 큐로 활용</h3>

- RDBMS 기반의 애플리케이션이라면 DB 테이블을 임시 메시지 큐로 사용하는  
  *트랜잭셔널 아웃박스 패턴*이 가장 알기 쉬운 방법이다. 메시지를 보내는 서비스에 `OUTBOX`라는  
  DB 테이블을 만들고, 비즈니스 객체에 대해 CUD 작업을 하는 트랜잭션의 일부로 `OUTBOX` 테이블에  
  메시지를 삽입한다. 로컬 ACID 트랜잭션이기 때문에 원자성은 자동 보장된다.

- `OUTBOX` 테이블은 임시 메시지 큐 역할을 한다. 메시지 relay는 `OUTBOX` 테이블을 읽어  
  메시지 브로커에 메시지를 발행하는 컴포넌트이다.

> 트랜잭셔널 아웃박스 패턴: 이벤트나 메시지를 DB에 있는 아웃박스에 저장해서  
> DB 트랜잭션의 일부로 발행한다.

- NoSQL DB도 방법은 비슷하다. DB에 레코드로 적재된 비즈니스 엔티티에 발행할 메시지 목록을 가리키는  
  속성이 있는데, 서비스가 DB 엔티티를 업데이트할 때 바로 이 목록에 메시지를 덧붙이면 된다.  
  단일 DB 작업이므로 원자적이지만, 문제는 이벤트를 가진 비즈니스 엔티티를 효과적으로 찾아  
  발행하는 일이다.

- 메시지를 DB에서 메시지 브로커로 옮기는 방법에는 두 가지가 있다.

<h3>이벤트 발행: 폴링 발행기 패턴</h3>

- RDBMS를 사용하는 애플리케이션에서 `OUTBOX` 테이블에 삽입된 메시지를 발행하는 가장 간단한 방법은  
  메시지 relay로 테이블을 polling해서 미발행 메시지를 조회하는 것이다.  
  단지 아래와 같은 쿼리를 주기적으로 실행하면 된다.

```sql
SELECT * FROM OUTBOX ORDER BY ... ASC;
```

- 메시지 relay는 이렇게 조회한 메시지를 하나씩 각자의 목적지 채널로 보내서 메시지 브로커에 발행한다.  
  그리고 나중에 `OUTBOX` 테이블에서 메시지를 삭제한다.

```sql
BEGIN;
DELETE FROM OUTBOX WHERE ID IN (...);
COMMIT;
```

> 폴링 발행기 패턴: DB에 있는 아웃박스를 폴링해서 메지시를 발행한다.

- DB Polling은 규모가 작을 경우 쓸 수 있는 단순한 방법이다.  
  하지만 DB를 자주 polling하면 비용이 유발되고 NoSQL DB는 쿼리 능력에 따라 사용 가능 여부가 결정된다.  
  애플리케이션이 `OUTBOX` 테이블을 쿼리하는 대신 비즈니스 엔티티를 쿼리해야하는 경우도 있는데,  
  이런 일이 효율적으로 가능할 수도 있고, 불가능할 수도 있기 때문이다.  
  이런 단점과 한계가 있기 때문에 어떤 경우에는 유용할 수 있지만 DB 트랜잭션 로그 테일링이 좀 더  
  정교하고 성능이 좋은 방법이다.

<h3>이벤트 발행: 트랜잭션 로그 테일링 패턴</h3>

- 메시지 Relay로 DB 트랜잭션 로그(커밋 로그)를 tailing하는 방법이다.  
  애플리케이션에서 commit된 업데이트는 각 DB의 트랜잭션 로그 항목(log entry)로 남는다.  
  트랜잭션 로그 마이너(Transaction log miner)로 트랜잭션 로그를 읽어 변경분을 하나씩 메시지로  
  메시지 브로커에 발행하는 것이다.

- 트랜잭션 로그 마이너는 트랜잭션 로그 항목을 읽고, 삽입된 메시지에 대응하는 각 로그 항목을  
  메시지로 전환하여 메시지 브로커에 발행한다. RDBMS의 `OUTBOX` 테이블에 출력된 메시지 또는  
  NoSQL DB에 레코드로 추가된 메시지를 이런 식으로 발행할 수 있다.

> 트랜잭션 로그 테일링 패턴: 트랜잭션 로그를 테일링하여 DB에 반영된 변경분을 발행한다.

- 트랜잭션 로그는 MySQL의 경우에는 모든 CUD 작업을 로깅하는 binlog, PostgreSQL의 경우에는  
  WAL(Write-Ahead Logging) 등을 말한다. 이 로그를 polling하는 방법을 응용한다.

<hr/>

<h2>메시징 라이브러리/프레임워크</h2>

- 서비스가 메시지를 주고받으려면 라이브러리가 필요하다.  
  메시지 브로커에도 클라이언트 라이브러리가 있지만, 직접 사용하면 아래와 같은 문제들이 있다.

  - 메시지 브로커 API에 메시지를 발행하는 비즈니스 로직이 클라이언트 라이브러리와 결합된다.
  - 메시지 브로커의 클라이언트 라이브러리는 대부분 저수준이고, 메시지를 주고 받는 코드가 꽤  
    긴 편이다. Boilerplate 코드를 계속 복사 후 붙여넣기 하게된다.
  - 메시지 브로커의 클라이언트 라이브러리는 기본적인 메시지 소통 수단일 뿐, 고수준의  
    상호 작용 스타일은 지원하지 않는다.

- 따라서 저수준 세부를 감추고 고수준의 상호 작용 스타일을 직접 지원하는 고수준 라이브러리 또는  
  프레임워크가 필요하다. 이 예시에서는 Eventuate Tram 프레임워크를 사용한다.  
  이 프레임워크는 메시지 브로커의 사용 복잡성을 캡슐화한 간단하고 이해하기 쉬운 API이다.  
  메시지를 주고받는 API 외에도 비동기 요청/응답 및 도메인 이벤트 발행 등 고수준의  
  상호 작용 스타일도 함께 지원한다.

- Eventuate Tram에는 중요한 메커니즘 두 개가 구현되어 있다.

  - 트랜잭셔널 메시징: 메시지를 DB 트랜잭션의 일부로 발행한다.
  - 중복 메시지 감지: Eventuate Tram의 메시지 consumer는 중복 메시지를 걸러낸다.  
    Consumer가 메시지를 한 번만 처리하도록 보장하려면 이런 장치가 꼭 필요하다.

- Eventuate Tram API를 사용해보자.

<h3>기초 메시징</h3>

- 기초 메시징 API는 `MessageProducer`, `MessageConsumer` 두 인터페이스로 구성된다.  
  Producer 서비스는 아래 코드처럼 `MessageProducer` 인터페이스를 통해 메시지를 메시지 채널에 발행한다.

```java
MessageProducer messageProducer = /*.. */;
String channel = /*.. */;
String payload = /*.. */;
messageProducer.send(destination, MessageBuilder.withPayload(payload).build());
```

- Consumer 서비스는 `MessageConsumer` 인터페이스를 통해 메시지를 구독한다.

```java
MessageConsumer messageConsumer;
messageConsumer.subscribe(subscriberId, Collections.singleton(destination), message -> {/*..*/});
```

- 이 두 인터페이스는 비동기 요청/응답 및 도메인 이벤트 발행에 관한 핵심 고수준 API 이다.

<h3>도메인 이벤트 발행</h3>

- Eventuate Tram은 도메인 이벤트를 발행/구독하는 API를 제공한다.  
  도메인 이벤트란 비즈니스 객체를 생성, 수정, 삭제 시 Aggregate(비즈니스 객체)가 발생시킨 이벤트이다.  
  서비스는 `DomainEventPublisher` 인터페이스를 이용하여 도메인 이벤트를 발행한다.

```java
DomainEventPublisher domainEventPublisher;
String accountId = /*.. */;
DomainEvent domainEvent = new AccountDebited(/*.. */);
domainEventPublisher.publish("Account", accountId, Collections.singletonList(domainEvent));
```

- 서비스는 `DomainEventDispatcher` 클래스로 도메인 이벤트를 소비한다.

```java
DomainEventHandlers domainEventHandlers =
    DomainEventHandlersBuilder.forAggregateType("Order")
	.onEvent(AccountDebited.class, domainEvent -> {/*..*/}).build();

new DomainEventDispatcher("eventDispatcherId", domainEventHandlers, messageConsumer);
```

- Eventuate Tram은 이벤트는 물론 커맨드/응답 기반의 메시징 등 고수준의 메시징 패턴도 지원한다.

<h3>커맨드/응답 메시징</h3>

- 클라이언트는 `CommandProducer` 인터페이스를 이용하여 커맨드 메시지를 서비스에 보낸다.

```java
CommandProducer commandProducer = /*.. */;

Map<String, String> extraMessageHeaders = Collections.emptyMap();

String commandId = commandProducer.send("CustomerCommandChannel", new DoSomethingCommand(), "ReplyToChannel", extraMessageHeaders);
```

- 서비스는 `CommandDispatcher` 클래스로 커맨드 메시지를 소비한다.  
  아래 코드처럼 `CommandDispatcher`는 `MessageConsumer` 인터페이스를 통해 특정 이벤트를 구독하고  
  각 커맨드 메시지를 적절한 핸들러 메소드로 디스패치한다.

```java
CommandHandlers commandHandlers =
    CommandHandlersBuilder.fromChannel(commandChannel)
	.onMessage(DoSomethingCommand.class, (command) -> {
	    /*..*/;
	    return withSuccess();
	}).build();

CommandDispatcher dispatcher = new CommandDispatcher("subscribeId", commandHandlers, messageConsumer, messageProducer);
```

- Eventuate Tram 프레임워크는 Java 애플리케이션용 트랜잭셔널 메시징을 기본 지원하며,  
  트랜잭션이 걸린 상태에서 메시지를 주고받을 수 있는 저수준 API도 함께 제공한다.  
  또 도메인 이벤트를 발행/소비하고 커맨드를 전송/처리하는 고수준 API도 있다.

<hr/>
