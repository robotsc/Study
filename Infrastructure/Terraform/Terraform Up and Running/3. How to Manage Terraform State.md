# How to Manage Terraform State

- `terraform apply` 또는 `terraform plan`을 수행할 때마다 Terraform은 자동으로 이전에 자신이 생성한 리소스를  
  확인하고, 해당 내용에 바탕으로 갱신 사항들을 만들어 보여줬다. 어떻게 이를 알 수 있을까? AWS에 직접 콘솔로, Terraform으로,  
  혹은 CLI 등의 다양한 방법으로 생성한 리소스들이 있을 것인데, Terraform은 어떻게 자신이 책임져야 하는 리소스를 구분지을 수 있을까?

- 이번 장에서는 Terraform이 인프라의 상태를 어떻게 관리하는지 파악해볼 것이다.

## What is Terraform state?

- Terraform을 실행할 때마다 Terraform은 생성된 인프라에 대한 정보를 _Terraform state file_ 에 저장한다.  
  만약 Terraform을 `/foo/bar` 폴더에서 실행한다면, Terraform은 `/foo/bar/terraform.tfstate` 파일을 생성한다.  
  이 파일은 JSON 형식으로, configuration file 내의 Terraform 리소스들과 실제로 배포된 리소스의 매핑 관계를 나타낸다.

- `terraform plan` 명령의 결과는 컴퓨터에 있는 state와 실제 클라우드 리소스의 state 사이의 diff 이다.

> State file은 Terraform 내부에서 사용되기 위한 private API 형식으로, 절대로 직접 해당 파일의 내용을 수정해서는 안된다.  
> 물론 이 상태 파일을 수정해야 할 경우도 있을 것이다. 주로 `terraform import` 또는 `terraform state` 명령을 사용할 때이다.

- Terraform을 개인적인 프로젝트에서 사용할 때 모든 상태를 로컬 컴퓨터에 하나의 `terraform.tfstate` 파일에 저장해도 무방하다.  
  하지만 만약 실제 프로덕트에 대해 Terraform을 팀 단위로 활용할 때 이렇게 진행하면 아래의 문제점들을 만날 수 있다.

  - Shared storage for state files: 팀원 각각이 동일한 Terraform state file을 사용할 수 있어야 한다.  
    즉, 로컬 컴퓨터에 저장해서는 안되고 공유 스토리지에 저장해야 한다.

  - Locking state files: 데이터가 공유되는 순간, locking 문제에 직면하게 된다. Locking이 없다면 팀원 두 명이  
    동일한 시점에 Terraform을 실행할 경우 Terraform이 동시적으로 리소스를 갱신하려는 등의 상황이 발생하면서  
    race condition이 발생할 수 있다.

  - Isolating state files: 인프라에 변경 사항을 적용할 때, 좋은 방법은 환경을 격리하는 것이다.  
    예를 들어, 개발 환경에 변경 사항을 만들 때 상용 환경에는 전혀 영향이 없을 것임을 보장해야 한다.

---

## Shared Storage for State Files

- 여러 명의 사람들이 동일한 코드를 사용할 때 가장 많이 사용되는 방법은 Git 등의 VCS를 사용하는 것이다.  
  하지만 Terraform state 파일을 VCS에 저장해 공유하는 것은 다음의 문제들을 야기할 수 있다.

  - Manual error: Terraform을 실행하기 전 최신 상태를 pull하는 것을 까먹는 것은 너무나 흔한 일이다.  
    또한 변경 후 push하는 것을 까먹을 수도 있다. 즉, 이렇게 human error가 발생할 여지가 너무나 많다.

  - Locking: 대부분의 VCS는 두 명 이상의 사람들이 동시에 `terraform apply`를 실행하는 것을 방지하기 위한 locking  
    기능을 제공하지 않는다.

  - Secrets: Terraform state 파일의 모든 데이터는 plain text로 저장된다. 이는 일부 Terraform 리소스들이 민감 정보를  
    담고 있을 수도 있기에 보안 문제가 된다.

- 따라서 state file을 공유하기 위해서는 VCS보다 Terraform이 built-in으로 제공하는 remote backend를 사용하는 것이 좋다.  
  Terraform _backend_ 는 Terraform이 상태를 어떻게 불러오고, 저장하는지를 정의한다. Default backend는 지금까지 우리가  
  사용해왔던 _local backend_ 로, 모든 상태 파일을 로컬 디스크에 저장한다. _Remote backend_ 는 state file을 Amazon S3,  
  GCS, Azure Storage, Terraform Cloud 등 state file을 원격의 공유 저장소에 저장한다.

- Remote backend를 활용하는 것은 위에서 봤던 local backend의 세 가지 문제점들을 아래처럼 해결한다.

  - Manual error: Remote backend를 설정하면 Terraform은 자동으로 `plan` 또는 `apply`를 수행할 때 remote storage로부터  
    가장 최신 상태 파일을 불러오고, `apply` 후에는 자동으로 remote storage에 업데이트한다.

  - Locking: 대부분의 remote backend는 locking을 기본 기능으로 제공한다. `terraform apply`를 수행하면 Terraform이  
    자동으로 lock을 획득하게 되고, 만약 동시에 다른 누군가가 `apply`를 이미 하고 있다면 대기하게 된다.  
    `terraform apply`에 `-lock-timeout=<TIME>` 파라미터를 사용하면 Terraform이 lock을 획득할 때까지 기다리는 시간을  
    지정할 수 있다.

  - Secrets: 대부분의 remote backend는 encryption-in-transit과 encryption-at-rest를 기본적으로 지원한다.  
    여기에 더해 대부분의 remote storage는 접근 권한을 지정할 수 있기 때문에 state file을 안전하게 보호할 수 있다.

- Amazon S3를 remote backend로 활용해보자.  
   첫 번째로는 S3 bucket을 생성해야 한다. 아래처럼 bucket, bucket versioning 설정, server-side encryption, 그리고  
   public access block 설정을 모두 지정해주자.

```tf
provider "aws" {
  region = "us-east-2"
}

resource "aws_s3_bucket" "terraform_state" {
  bucket = "terraform-up-and-running-state-roy-ra"
  lifecycle {
    prevent_destroy = true
  }
}

resource "aws_s3_bucket_versioning" "enabled" {
  bucket = aws_s3_bucket.terraform_state.id
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_server_side_encryption_configuration" "default" {
  bucket = aws_s3_bucket.terraform_state.id
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

resource "aws_s3_bucket_public_access_block" "public_access" {
  bucket                  = aws_s3_bucket.terraform_state.id
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}
```

- 다음으로는 locking을 위해 사용할 DynamoDB table을 생성해보자.  
  DynamoDB를 Terraform을 위해 활용할 때는 primary key가 무조건 `LockID`여야 한다.

```tf
resource "aws_dynamodb_table" "terraform_locks" {
  name         = "terraform-up-and-running-locks-roy-ra"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "LockID"
  attribute {
    name = "LockID"
    type = "S"
  }
}
```

- 이 상태에서 `terraform init`으로 provider code를 받고, `terraform apply`를 수행해 S3 Bucket과 DynamoDB table이  
  생성되어도, Terraform state 파일은 여전히 local에 저장될 것이다. 즉, S3 bucket에 state 파일을 저장하게끔 하기 위해서는  
  별도의 설정이 필요하다. 바로 `backend` configuration이다. 이 설정은 Terraform 자체를 위한 설정이기 때문에 `terraform`  
  block에 아래의 문법으로 지정한다.

  ```tf
  terraform {
  	backend "<BACKEND_NAME>" {
  		[CONFIG...]
  	}
  }
  ```

  - `BECKEND_NAME`: 사용할 backend
  - `CONFIG`: backend에 따라 다르지만 대부분은 `bucket`, `key`, `region`, `dynamodb_table` 등이 있다.

- S3, DynamoDB table을 backend로 활용하기 위한 설정은 아래와 같다.

```tf
terraform {
  backend "s3" {
    bucket         = "terraform-up-and-running-state-roy-ra"
    key            = "global/s3/terraform.tfstate"
    region         = "us-east-2"
    dynamodb_table = "terraform-up-and-running-locks-roy-ra"
    encrypt        = true
  }
}
```

- 이제 `terraform init`을 수행하면 backend 관련 설정이 진행되고 있다는 문구가 나오고, 바로 S3에 state 파일이 저장되는 것을 확인할 수 있다.

- 이 상태에서 `terraform apply`, `terraform plan` 등을 실행하면 Terraform은 자동으로 S3에서 최신 상태를 가져오고, 변경 사항을  
  반영한 후 S3에 업데이트한다. 이 과정을 보고 싶다면 아래의 output variable들을 작성해보자.

```tf
output "s3_bucket_arn" {
  value       = aws_s3_bucket.terraform_state.arn
  description = "The ARN of the S3 bucket used to store Terraform state"
}

output "dynamodb_table_name" {
  value       = aws_dynamodb_table.terraform_locks.name
  description = "The name of the DynamoDB table used to store Terraform state locks"
}
```

- 이제 `terraform apply`를 수행하면 아래와 같이 출력된다.

  ```sh
  > terraform apply
  Acquiring state lock. This may take a few moments...
  ...
  Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

  Releasing state lock. This may take a few moments...

  Outputs:

  dynamodb_table_name = "terraform-up-and-running-locks-roy-ra"
  s3_bucket_arn = "arn:aws:s3:::terraform-up-and-running-state-roy-ra"
  ```

- 위 결과를 통해 Terraform이 apply 전에 lock을 획득하고, apply 후에 해제하는 것을 확인할 수 있다.

- S3 Bucket의 bucket versioning이 활성화되어 있기 때문에 state 파일이 바뀔 때마다 새로운 버전이 적용되고, 이는 이후에  
  디버깅, rollback 등을 쉽게 수행하도록 도와준다.

---

## Limitations with Terraform's Backends

- Terraform backend는 알아둬야 할 몇 가지 한계점들이 존재한다.  
  첫 번째 한계점은 Terraform을 사용해 Terraform state 파일을 관리할 bucket을 만들었다는 점에 있다.  
  우리는 이를 위해 아래 두 단계를 수행했다.

  - (1) S3 bucket, DynamoDB table 생성을 위한 Terraform code 작성 및 local backend로 배포
  - (2) Terraform code를 수정해 backend configuration 도입 후 `terraform init` 수행

- 만약 S3 bucket 혹은 DynamoDB table을 삭제하고 싶다면, 위 과정을 반대로 수행해야 한다.

  - (1) Terraform code의 backend 설정 제거 후 `terraform init`을 수행해 Terraform state를 local disk에 저장
  - (2) `terraform destroy`를 수행해 S3 bucket, DynamoDB table 삭제

- 이 두 단계 과정은 어색할 수 있지만, Terraform code의 상태를 관리하기 위해 S3 bucket과 DynamoDB table을 공유할 수 있기에  
  단순하다고 할 수도 있다.

- 두 번째 한계점은 `backend` block에서 변수 혹은 참조를 사용할 수 없다는 것이다. 즉, 아래와 같은 코드는 불가능하다.

```tf
terraform {
  backend "s3" {
    bucket         = var.bucket
    key            = var.key
    region         = var.region
    dynamodb_table = var.dynamodb_table
    encrypt        = true
  }
}
```

- 이는 곧 이후에 배울 Terraform module 각각에 대해 S3 bucket 이름, DynamoDB table 이름 등을 일일히 복붙해야 한다는  
  것을 의미한다. 거기에 더해 key는 module마다 달라야하기 때문에 key는 _주의해서_ 복붙해야 한다는 점도 있다.

- 이러한 복붙 단점을 해결하기 위한 한 가지 방법으로 _partial configuration_ 을 활용할 수 있는데, 이는 `backend` 설정의  
  일부 파라미터들을 CLI의 `-backend-config` 옵션으로 잔달하는 방법을 의미한다. 예를 들어 반복되는 `backend` 값들을  
  `backend.hcl`이라는 별도의 파일로 분리할 수 있다.

```hcl
bucket         = "terraform-up-and-running-state-roy-ra"
region         = "us-east-2"
dynamodb_table = "terraform-up-and-running-locks-roy-ra"
encrypt        = true
```

- 그리고 Terraform code에는 key만을 남겨둔다.

```tf
terraform {
  backend "s3" {
    key = "global/s3/terraform.tfstate"
  }
}
```

- 이제 `terraform init -backend-config=backend.hcl`을 수행하면 Terraform이 partial configuration 값들을  
  Terraform code에 병합해 필요한 모든 값들이 구성되어 있는 configuration을 구성해 적용한다.

---
