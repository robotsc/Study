# Testing

## Testing 기초

- Go에서 테스트는 라이브러리와 도구 부분으로 지원된다. 표준 라이브러리의 `testing` 패키지는 테스트를 위한 타입과 함수를 제공하고,  
  Go와 함께 사용되는 `go test` 도구는 테스트를 실행하고 보고서를 생성한다. 그리고 다른 언어와는 달리, Go 테스트 코드는 production  
  코드와 같은 디렉토리, 패키지에 배치된다. 이렇게 테스트가 같은 패키지에 배치되기 때문에 테스트는 노출되지 않은 함수들과 변수들에도  
  접근할 수 있다.

- 모든 테스트는 이름이 `_test.go`로 끝나는 파일에 작성되어야 한다. 예를 들어 `foo.go`라는 파일의 테스트를 작성하고 싶다면  
  `foo_test.go`라는 파일에 작성한다.

- 테스트 함수는 `Test`라는 단어로 시작해야 하고, 단일 파라미터로 `*testing.T`를 받는다. 관례적으로 이 파라미터의 이름은 t로 한다.  
  그리고 테스트 함수는 어떠한 값도 반환하지 않는다.

- 테스트를 실행하는 `go test` 명령어는 어떤 패키지를 테스트할지 지정할 수 있다. 예를 들어 `go test ./...`를 수행하면 현재 디렉토리와  
  현재 디렉토리의 모든 하위 디렉토리에서 테스트를 실행하도록 지정하는 것이다.

### 테스트 실패 보고

- `*testing.T`에는 테스트 실패를 보고하기 위한 몇 가지 메소드가 있다.

  - `t.Errorf()`: `fmt.Printf()`와 같은 형식으로 오류 보고
  - `t.Error()`: `fmt.Print()`와 같은 형식으로 오류 보고
  - `t.Fatalf()`: 오류 보고 후 테스트 강제 종료
  - `t.Fatal()`: 오류 보고 후 테스트 강제 종료

### 설정, 해제

- 때로는 모든 테스트의 수행 전에 설정되거나 테스트가 완료되거 나서 제거되어야 하는 몇 몇의 일반적인 상태를 가질 수 있다.  
  이는 `TestMain()` 함수를 사용해 관리하고 테스트를 수행할 수 있다.

```go
var testTime time.Time

func TestMain(m *testing.M) {
	fmt.Println("setup stuff for test here")
	testTime = time.Now()
	exitVal := m.Run()
	fmt.Println("cleanup stuff for test here")
	os.Exit(exitVal)
}

func TestFirst(t *testing.T) {
	fmt.Println("TestFirst uses stuff setup in TestMain", testTime)
}

func TestSecond(t *testing.T) {
	fmt.Println("TestSecond uses stuff setup in TestMain", testTime)
}
```

- `TestFirst()`, `TestSecond()`는 모두 package-level 변수인 testTime을 참조한다. 그리고 `*testing.M` 타입의 파라미터를  
  가지는 `TestMain`이라는 함수를 선언했다. `TestMain()`이 있는 패키지에서 `go test`를 실행하는 것은 각 테스트 메소드들을 호출하는  
  것 대신, 해당 함수를 호출한다. `Run()` 메소드는 종료 코드를 반환하는데, 0은 모든 테스트가 통과했다는 것을 의미한다.  
  마지막으로 `Run()`에서 반환된 종료 코드와 함께 `os.Exit()`을 반드시 호출해야 한다.

- `go test` 수행 결과는 아래와 같다.

```
❯ go test
setup stuff for test here
TestFirst uses stuff setup in TestMain 2022-08-11 15:27:29.768412 +0900 KST m=+0.000373126
TestSecond uses stuff setup in TestMain 2022-08-11 15:27:29.768412 +0900 KST m=+0.000373126
PASS
cleanup stuff for test here
ok      PlaygroundGo    0.091s
```

- `TestMain()`은 개별 테스트 이전과 이후에 호출되는 것이 아니라, 한 번만 실행된다는 점에 주의해야 한다.  
  또한 `TestMain()`은 패키지별로 단 하나만 가질 수 있다.

- `TestMain()`이 유용한 두 가지 일반적인 상황이 있다.

  - 데이터베이스와 같은 외부 저장소에 있는 데이터 설정이 필요한 경우
  - 초기화될 필요가 있는 package-level 변수에 의존적인 코드가 테스트될 경우

- `*testing.T`의 `Cleanup()` 메소드는 단일 테스트를 위해 생성된 임시 자원을 정리하기 위해 사용한다. 이 메소드는 단일 파라미터인  
  입력 파라미터와 반환값이 없는 함수를 가진다. 이 함수는 테스트가 완료되면 수행된다. 간단한 테스트를 할 경우에는 defer문을 사용해 같은  
  결과를 얻을 수 있지만, `Cleanup()`은 테스트가 아래 코드와 같이 sample 데이터를 설정하기 위한 helper function에 의존적일 때  
  유용하다. `Cleanup()`은 여러 번 호출되어도 괜찮으며 defer와 같이 마지막에 추가된 것이 가장 먼저 호출되는 순서로 실행된다.

### testdata

- `go test`는 소스 코드 tree를 탐색할 때, 현재 패키지의 디렉토리를 작업 디렉토리로 사용한다. 패키지의 테스트 함수에 sample 데이터를  
  사용하고 싶다면 해당 데이터를 저장할 `testdata`라는 하위 디렉토리를 생성한다. Go는 테스트 파일을 갖고 있는 위치로 해당 디렉토리를  
  예약한다. `testdata`에서 읽을 때는 항상 상대 경로로 파일 참조를 진행한다.

### 테스트 결과 caching

- Go는 여러 패키지에 걸쳐 테스트를 수행할 때 이미 통과했고 코드의 변경사항이 없다면 해당 결과를 caching한다.  
  테스트는 패키지의 어떤 파일이나 `testdata` 디렉토리가 변경된 경우에만 다시 컴파일하고 다시 실행한다.  
  테스트 실행을 강제하려면 `go test`에 `-count=1` flag를 넘기면 된다.

### 공용 API 테스트

- 앞서 봤듯이 테스트 코드는 production 코드와 같은 패키지에 위치해있다. 따라서 테스트 코드에서 노출되거나, 그렇지 않은 함수나  
  변수 모두에 대해 테스트를 할 수 있다.

- 하지만 패키지의 공용 API만 테스트하고 싶은 경우도 있다. Go는 이를 처리하기 위한 기능을 제공하는데, 테스트 코드의 패키지명을  
  `packagename_test`로 지정하면 노출되지 않은 항목들에 대한 접근이 허용되지 않는다.

### 테스트 결과 비교

- 복합 타입의 두 인스턴스는 `reflect.DeepEqual()`을 사용해 비교할 수도 있지만, `go-cmp`라는 3rd party 패키지를 사용하면  
  훨씬 더 쉽게 구현할 수 있다.

---
