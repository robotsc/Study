# 실행 시 제네릭의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

## 실행 시점의 제네릭: 타입 검사와 캐스트

- Java와 마찬가지로 코틀린 제네릭 타입 인자 정보는 runtime에 지워진다. 이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인  
  타입 인자에 대한 정보를 유지하지 않는다는 뜻이다. 예를 들어 `List<String>` 객체를 만들고 그 안에 문자열을 여럿 넣더라도  
  실행 시점에는 그 객체를 오직 `List`로만 볼 수 있다. 그 `List` 객체가 어떤 타입의 원소를 저장하는지는 실행 시점에 알 수 없다.

- 아래 코드를 실행할 때 두 개의 리스트에 어떤 일이 벌어지는지 생각해보자.

```kt
val list1: List<String> = listOf("a", "b")
val list2: List<Int> = listOf(1, 2, 3)
```

- 컴파일러는 두 리스트를 서로 다른 타입으로 인식하지만, 실행 시점에 그 둘은 완전히 같은 타입의 객체다.  
  그럼에도 불구하고 보통은 `List<String>`에는 문자열만 들어있고 `List<Int>`에는 정수만 들어있다고 가정할 수 있는데,  
  이는 컴파일러가 타입 인자를 알고 올바른 타입의 값만 각 리스트에 넣도록 보장해주기 때문이다.

- 다음으로 타입 소거로 인해 생기는 한계를 살펴보자. 타입 인자를 따로 저장하지 않기 때문에, 실행 시점에 타입 인자를 검사할 수 없다.  
  예를 들어 어떤 리스트가 문자열로 이뤄진 리스트인지, 다른 객체로 이뤄진 리스트인지를 실행 시점에 검사할 수 없다.  
  일반적으로 말하자면 `is` 검사에서 타입 인자로 지정한 타입을 검사할 수는 없다.  
  아래 코드는 컴파일 오류를 발생시킨다.

```kt
if(value is List<String>) { /* ... */ }
// ERROR: Cannot check for instance of erased type
```

- 실행 시점에 어떤 값이 `List`인지의 여부는 확실히 알아낼 수 있지만, 그 리스트가 `String`의 리스트인지, `Person`의 리스트인지,  
  혹은 다른 어떤 타입의 리스트인지는 알 수가 없다. 그런 정보는 지워진다. 다만 저장해야 하는 타입 정보의 크기가 줄어들어서 전반적인  
  메모리 사용량이 줄어든다는 제네릭 타입 소거 나름의 장점이 있다.

- 앞서 본대로 코틀린에서는 타입 인자를 명시하지 않고 제네릭 타입을 사용할 수 없다.  
  그렇다면 어떤 값이 set이나 map이 아니라 list라는 사실을 어떻게 확인할 수 있을까?  
  이때 바로 **star projection** 을 사용하면 된다.

```kt
if (value is List<*>) { /* ... */ }
```

- 타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 `*`를 포함시켜야 한다. Star projection에 대해서는 후에 더 자세히 다룬다.  
  지금은 인자를 알 수 없는 제네릭 타입을 표현할 때(Java의 `List<?>`와 유사) star projection을 사용한다고만 알아두자.  
  위 예시 코드에서는 value가 `List`임을 알 수는 있지만, 그 원소 타입은 알 수 없다.

- `as`나 `as?` 캐스팅에도 여전히 제네릭 타입을 사용할 수 있다. 하지만 기저 클래스는 같지만 타입 인자가 다른 타입으로 캐스팅해도 여전히  
  캐스팅에 성공한다는 점을 조심해야 한다. 실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로, 캐스팅은 항상 성공할 수밖에 없다.  
  그런 타입 캐스팅을 사용하면 컴파일러가 "unchecked cast" 라는 경고를 준다. 하지만 컴파일러는 단순히 경고만 하고, 컴파일을 진행하므로  
  아래 코드처럼 값을 원하는 제네릭 타입으로 캐스팅해 사용할 수 있다.

```kt
fun printSum(c: Collection<*>) {
	val intList = c as? List<Int> ?: throw IllegalArgumentException("List is expected")
	println(intList.sum())
}

printSum(listOf(1, 2, 3)) // 6
```

- 컴파일러가 캐스팅 관련 경고를 한다는 점을 제외하면, 모든 코드가 문제없이 컴파일된다.  
  정수 리스트나 정수 set에 대해 `printSum()`을 호출하면 예상처럼 작동한다. 정수 리스트에 대해서는 합계를 출력하고, 정수 set에  
  대해서는 `IllegalArgumentException`이 발생한다. 하지만 잘못된 타입의 원소가 들어 있는 리스트를 전달하면  
  실행 시점에 `ClassCastException`이 발생한다.

```kt
printSum(setOf(1, 2, 3)) // IllegalArgumentException: List is expected
printSum(listOf("a", "b", "c")) // ClassCastException
```

- 문자열 리스트를 `printSum()`에 전달하면 발생하는 예외에 대해 좀 더 보자.  
  어떤 값이 `List<Int>`인지 검사할 수는 없으므로 `IllegalArgumentException`이 발생하지는 않는다.  
  따라서 `as?` 캐스트가 성공하고, 문자열 리스트에 대해 `sum()`이 호출된다. 예외는 `sum()`이 실행되는 도중에 발생한다.  
  `sum()`은 `Number` 타입의 값을 리스트에서 가져와 서로 더하려고 시도하기 때문이다.

- 코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 `is` 검사를 수행하게 허용할 수 있을 정도로 똑똑하다.

```kt
fun printSum(c: Collection<Int>) {
	if (c is List<Int>) {
		println(c.sum())
	}
}
```

- 위 코드에서는 컴파일 시점에 c가 `Int` 값을 저장한다는 사실이 알려져 있으므로 c가 `List<Int>` 인지 검사할 수 있다.

- 일반적으로 코틀린 컴파일러는 안전하지 못한 검사와 수행할 수 있는 검사를 알려주기 위해 최대한 노력하므로, 컴파일러 경고의 의미와  
  어떤 연산이 안전한지에 대해 알아야 한다.

## 실체화한 타입 파라미터를 사용한 함수 선언

- 이전에 봤듯이 코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워진다. 따라서 제네릭 클래스의 인스턴스가 있어도, 그 인스턴스를  
  만들 때 사용한 타입 인자를 알아낼 수 없다. 제네릭 함수의 타입 인자도 마찬가지다. 제네릭 함수가 호출되어도 그 함수의 본문에서는  
  호출 시 쓰인 타입 인자를 알 수 없다.

```kt
fun <T> isA(value: Any) = value is T
// ERROR: Cannot check for instance of erased type: T
```

- 이는 일반적으로는 사실이지만, 이러한 제약을 피할 수 있는 단 하나의 경우가 있다.  
  **인라인 함수의 타입 파라미터는 실체화되므로, 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.**

- 위에서 본 `isA()`를 인라인 함수로 만들고, 타입 파라미터를 reified로 지정하면 value의 타입이 `T`의 인스턴스인지를 실행 시점에 검사할 수 있다.

```kt
inline fun <reified T> isA(value: Any) = value is T
println(isA<String>("abc")) // true
println(isA<String>(123)) // false
```

- 실체화한 타입 파라미터를 사용하는 예를 보자. 가장 간단한 예시 중 하나는 표준 라이브러리 함수인 `filterIsInstance()`이다.  
  이 함수는 인자로 받은 컬렉션의 원소들 중, 타입 인자로 지정한 클래스의 인스턴스들만을 모아서 만든 리스트를 반환한다.

```kt
val items = listOf("one", 2, "three")
println(items.filterIsInstance<String>()) // [one, three]
```

- `filterIsInstance()`의 타입 인자로 `String`을 지정함으로써 문자열만 필요하다는 사실을 기술한다.  
  따라서 이 함수의 반환 타입은 `List<String>`이다. 여기서는 타입 인자를 실행 시점에 알 수 있고, `filterIsInstance()`는 그 타입 인자를  
  사용해 리스트의 원소들 중 타입 인자와 타입이 일치하는 원소들만을 추려낼 수 있다.

```kt
inline fun <reified T> Iterable<*>.filterIsInstance(): List<T> {
	val destination = mutableListOf<T>()
	for (element in this) {
		if (element is T) {
			destination.add(element)
		}
	}
	return destination
}
```

### 인라인 함수에서만 실체화한 타입 파라미터를 쓸 수 있는 이유

- 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입한다.  
  컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다.  
  따라서 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있다.  
  결과적으로 위에서 본 `filterIsInstance<String>()`은 아래와 동등한 코드를 만들어낸다.

```kt
for (element in this) {
	if (element is String) {
		destination.add(element)
	}
}
```

> 타입 파라미터가 아니라 구체적인 타입을 사용하므로, 만들어진 바이트코드는 실행 시점에 벌어지는 타입 소거의 영향을 받지 않는다.
>
> Java 코드에서는 reified 타입 파라미터를 사용하는 inline 함수를 호출할 수 없다. Java에서는 코틀린 인라인 함수를  
>  다른 보통 함수처럼 호출한다. 그런 경우, 인라인 함수를 호출해도 실제로 inlining이 되지 않는다. 실체화한 타입 파라미터가 있는  
>  함수의 경우, 타입 인자 값을 바이트코드에 넣기 위해 일반 함수보다 더 많은 작업이 필요하고, 항상 inlining돼야만 한다.  
>  따라서 실체화한 타입 파라미터가 있는 inlining함수를 일반 함수처럼 Java에서 호출할 수는 없다.

- 인라인 함수에는 실체화한 타입 파라미터가 여러 개 있거나, 실체화한 타입 파라미터와 실체화하지 않은 타입 파라미터가 함께 있을 수도 있다.  
  람다를 파라미터로 받지 않지만 `filterInstance()`를 인라인 함수로 정의했다는 점에 유의하자. 이전에 _함수의 파라미터 중에 함수 타입인_  
  _파라미터가 있고, 그 파라미터에 해당하는 인자(람다)를 함께 inlining함으로써 얻는 이익이 더 큰 경우에만 함수를 인라인 함수로 만들라고_ 했는데,  
  이 경우에는 성능 향상이 아니라, 실체화한 타입 파라미터를 사용하기 위해서 함수를 inline으로 정의한 것이다.

- 성능을 좋게 하려면 인라인 함수의 크기를 계속 관찰해야 한다. 함수가 커지면 실체화한 타입에 의존하지 않는 부분을 별도의 일반 함수로 뽑아내는 것이 낫다.

---

## 클래스 참조보단 실체화된 타입 파라미터

- `java.lang.Class` 타입 인자를 파라미터로 받는 API에 대한 코틀린 adapter를 구축하는 경우, 실체화한 타입 파라미터를 자주 사용한다.  
  `java.lang.Class`를 사용하는 API로는 예를 들어 JDK의 `ServiceLoader`가 있다. `ServiceLoader`는 어떤 추상 클래스나  
  인터페이스를 표현하는 `java.lang.Class`를 받아 그 클래스나 인스턴스를 구현한 인스턴스를 반환한다.  
  실체화한 타입 파라미터를 활용해 이런 API를 쉽게 호출할 수 있게 만드는 방법을 살펴보자.

- 표준 Java API인 `ServiceLoader`를 사용해 서비스를 읽어들이려면, 아래처럼 호출해야 한다.

```kt
val serviceImpl = ServiceLoader.load(Service::class.java)
```

- `::class.java` 구문은 코틀린 클래스에 대응하는 `java.lang.Class` 참조를 얻는 방법을 보여준다.  
  `Service::class.java`라는 코드는 `Service.class`라는 Java 코드와 완전히 동일하다.

- 이제 위 코드를 구체화된 타입 파라미터를 사용해 다시 작성해보자.

```kt
val serviceImpl = loadService<Service>()
```

- 훨씬 짧다. 읽어들일 서비스 클래스를 `loadService()`의 타입 인자로 지정해보자.

```kt
inline fun <reified T> loadService() {
	return ServiceLoader.load(T::class.java)
}
```

- 일반 클래스에 사용할 수 있는 `::class.java` 구문을 이 경우에도 사용할 수 있다.  
  이를 통해 타입 파라미터로 지정된 클래스에 따른 `java.lang.Class`를 얻을 수 있고, 그렇게 얻은 클래스 참조를 보통 때와  
  마찬가지로 사용할 수 있다.

---

## 실체화한 타입 파라미터의 제약

- 실체화한 타입 파라미터는 유용한 도구지만, 몇 가지 제약이 있다. 일부는 실체화의 개념으로 인해 생기는 제약이며, 나머지는 현재 코틀린이  
  실체화를 구현하는 방식에 의해 생기는 제약으로, 향후 완화될 가능성이 있다.

- 더 구체적으로 말하면, 아래와 같은 경우에 실체화한 타입 파라미터를 사용할 수 있다.

  - 타입 검사와 캐스팅(`is`, `as`, `as?`)
  - Kotlin reflection API(`::class`)
  - 코틀린 타입에 대응하는 `java.lang.Class` 얻기(`::class.java`)
  - 다른 함수를 호출할 때 타입 인자로 사용

- 하지만 아래와 같은 일들은 할 수 없다.

  - 타입 파라미터 클래스의 인스턴스 생성하기
  - 타입 파라미터 클래스의 동반 객체 메소드 호출하기
  - 실체화한 타입 파라미터를 요구하는 함수를 호출하면서, 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
  - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기

- 마지막 제약으로 인해 한 가지 흥미로운 파급 효과가 생긴다. 실체화한 타입 파라미터를 인라인 함수에만 사용할 수 있으므로  
  실체화한 타입 파라미터를 사용하는 함수는 자신에게 전달되는 모든 람다와 함께 인라이닝된다. 람다 내부에서 타입 파라미터를  
  사용하는 방식에 따라서는 람다를 인라이닝 할 수 없는 경우가 생기기도 하고, 성능 문제로 람다를 인라이닝하고 싶지 않을 수도 있다.  
  그런 경우, noinline 변경자를 함수 타입 파라미터에 붙여 인라이닝을 금지할 수 있다.

---
