# 동기 RPI 패턴 응용 통신

- RPI(Remote Programming Interface)는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC이다.  
  응답 대기 중에 블로킹하는 클라이언트도 있고, reactive한 non-blocking 아키텍쳐를 가진 클라이언트도  
  있지만, 어쨋든 메시징을 통신하는 클라이언트와는 달리 응답이 제때 도착하리라 가정한다.

- RPI의 작동 원리를 살펴보자. 우선 클라이언트의 비즈니스 로직은 프록시 인터페이스를 호출한다.  
  이 프록시 인터페이스는 RPI 프록시 어댑터 클래스로 구현한다. RPI 프록시가 서비스에 전달한 요청은  
  RPI 서비스 어댑터 클래스가 접수하고, 이 클래스는 다시 서비스 인터페이스를 통해 비즈니스 로직을 호출한다.  
  비즈니스 로직 처리를 마친 서비스는 다시 RPI 프록시로 응답을 돌려주고 최종 결과는 클라이언트의  
  비즈니스 로직에 반환된다.

- 프록시 인터페이스는 하부(underlying) 통신 프로토콜을 캡슐화한다. 프로토콜의 종류는 다양하지만  
  REST와 gRPC만 살펴보자. 부분 실패를 적절히 처리해서 서비스 가용성을 높이는 방법과 RPI를 사용하는  
  마이크로서비스 애플리케이션에서 서비스 디스커버리 메커니즘이 필요한 이유를 살펴보자.

## 동기 RPI 패턴: REST

- REST는 거의 항상 HTTP로 소통하는 IPC이다. 현재 API 개발은 REST 스타일이 대세이다.  
  아래는 창시자인 Roy Fielding이 쓴 논문에서 인용한 단락이다.

> REST는 컴포넌트 상호 작용의 확장성, 인터페이스 일반화, 컴포넌트의 독립적 배포,  
> 상호 작용 지연을 줄이기 위해 중간 컴포넌트, 보안 강화, 레거시 시스템의 캡슐화에  
> 역점을 둔 아키텍쳐 제약 조건 세트를 제공한다.

- 리소스는 REST의 핵심 개념이다. `Consumer`, `Product` 같은 비즈니스 객체들을 의미한다.  
  REST는 HTTP Verb를 사용해서 URL로 참조되는 리소스를 가공(조작)한다.  
  GET 요청은 대부분 XML문서나 JSON객체 포맷으로 리소스를 표현하여 반환하고,  
  POST 요청은 새로운 리소스를 생성하며 PUT은 기존 리소스를 업데이트한다.

- 개발자는 대부분 자신의 HTTP API가 RESTful하다 하지만, 실제로 그렇지 않는 API도 많다.  
  그 이유를 이해하기 위해 먼저 REST 성숙도 모델을 알아보자.

### REST 성숙도 모델

- REST 성숙도 모델은 Leonard Richardson이 제시한 모델로, REST가 얼마나 성숙했는지 판단하는 유용한 모델이다.  
  이 모델에 따르면 REST의 성숙도는 아래 4 단계로 구분된다.

  - **레벨 0**: 클라이언트는 서비스별로 유일한 URL Endpoint에 HTTP POST 요청을 하여 서비스를 호출한다.  
    요청을 할 때마다 어떤 액션을 수행할지, 그 대상은 무엇인지 지정한다. 필요한 매개변수도 함께 전달한다.
  - **레벨 1**: 서비스는 리소스 개념을 지원한다. 클라이언트는 수행할 액션과 매개변수가 지정된 POST 요청을 한다.
  - **레벨 2**: 서비스는 HTTP Verb를 이용하여 액션을 수행하고(GET은 조회, POST는 생성 등), 요청 쿼리  
    매개변수 및 본문, 필요 시 매개변수를 지정한다. 덕분에 서비스는 GET 요청을 캐싱하는 등 웹 인프라를 사용할 수 있다.
  - **레벨 3**: 서비스를 HATEOAS(Hypertext As The Engine Of Application State) 원칙에 기반하여  
    설계한다. HATEOAS는 GET 요청으로 반환된 리소스 표현형에 그 리소스에 대한 액션의 링크도 함께 태워 보내자는  
    생각이다. 가령 클라이언트는 GET 요청으로 주문 데이터를 조회하고 이때 반환된 표현형 내부 링크를 이용해서  
    해당 주문을 취소할 수도 있다. HATEOAS를 사용하면 하드 코딩한 URL을 클라이언트 코드에 욱여넣지 않아도 된다.

### REST API

- API는 IDL로 정의해야 한다고 했다. COBRA, SOAP 등 오래된 통신 프로토콜과 달리 REST는 원래 IDL이 없다.  
  하지만 REST API에도 IDL이 필요하다는 공감대가 형성되었고 Swagger를 발전시켜 Open API Specification이  
  REST IDL로서 널리 보급되었다.

#### 요청 한 번으로 많은 리소스를 가져오기 어렵다

- REST 리소스는 `Consumer`, `Order` 같은 비즈니스 객체 중심이다. 따라서 REST API 설계 시 어떻게 하면  
  클라이언트가 요청 한 번으로 연관된 객체를 모두 가져올 수 있을지 고민하게 된다. 예를 들어 특정 주문과 주문한 소비자를  
  REST로 조회하는 클라이언트가 있다고 해보자. 순수 REST API라면 클라이언트는 적어도 2회의 요청(주문 1회, 소비자 1회)을  
  해야 한다. 시나리오가 복잡해지면 왕복 횟수가 증가하고 지연시간이 급증에서 곤란해질 것이다.

- 이 문제를 해결하는 한 가지 방법은 클라이언트가 리소스를 획득할 때 연관된 리소스도 함께 조회하도록 API가  
  허락하는 것이다. 예를 들어 GET `/orders/13?expand=consumer`처럼 쿼리 매개변수로 주문과 함께 반환될  
  연관 리소스(consumer)를 지정하면 주문, 소비자를 한번에 조회할 수 있다.  
  그러나 시나리오가 복잡해지면 효율이 떨어지고 구현 시간이 많이 소요되는 문제도 있다.  
  이런 이유 때문에 데이터를 효율적으로 조회할 수 있게 셜계된 GraphQL이나 Netflix Falcor 등  
  대체 API 기술이 각광받기 시작했다.

#### 작업을 HTTP 동사에 매핑하기 어렵다

- 비즈니스 객체에 수행할 작업을 HTTP Verb에 어떻게 매핑할지도 고민거리이다.  
  REST API는 데이터를 수정할 때 대개 PUT을 사용하지만, 가령 주문 데이터만 하더라도 이 데이터를 업데이트하는 경로는  
  주문 취소/변경 등 다양할 수 있다. 또 PUT 사용 시 필수 요건인 멱등성(idempotency)이 보장되지 않는  
  업데이트도 있다. 한 가지 해결 방법은 리소스의 특정 부위를 업데이트하는 하위 리소스(sub-resource)를 정의하는 것이다.  
  가령 주문 서비스에 주문 취소 endpoint(`POST /orders/{orderId}/cancel`), 주문 변경 endpoint
  (`POST /orders/{orderId}/revise`)를 두는 것이다. 동사를 URL 쿼리 매개변수로 지정하는 방법도 있지만  
  RESTful 하지 않아 gRPC 같은 REST 대체 기술이 점점 인기를 끌고 있는 추세이다.

#### REST의 장단점

- REST는 아래와 같은 장점이 있다.

  - 단순하고 익숙하다.
  - curl, 다른 툴로 HTTP API를 간편하게 테스트할 수 있다.
  - 요청/응답 스타일의 통신을 직접 지원한다.
  - HTTP는 Firewall-Friendly 하다.
  - 중간 브로커가 필요 없기에 시스템 아키텍쳐가 단순하다.

- 아래와 같은 단점도 있다.

  - 요청/응답 스타일의 통신만 지원한다.
  - 가용성이 떨어진다. 중간에서 메시지를 버퍼링하는 매개자 없이 클라이언트/서비스가 직접  
    통신하기 때문에 교환이 일어나는 동안에 항상 양쪽 다 실행중이어야 한다.
  - 서비스 인스턴스들의 URL을 클라이언트가 알고 있어야 한다. 요즘 애플리케이션은 서비스 디스커버리 메커니즘을  
    이용해서 클라이언트가 서비스 인스턴스의 위치를 찾을 수 있으므로 큰 단점은 아니다.
  - 요청 한 번으로 여러 리소스를 가져오기 어렵다.
  - 다중 업데이트 작업을 HTTP Method로 매핑하기 어려울 때가 많다.

- REST는 사실상 API 표준이지만, 요즘은 흥미로운 대체 기술이 많다.  
  유연하고 효율적인 데이터 조회 기능을 자랑하는 GraphQL도 있고, gRPC도 있다.

---

## 동기 RPI 패턴: gRPC

- HTTP는 한정된 Method만 지원하기에 다양한 업데이트 작업을 지원하는 REST API를 설계하기 쉽지 않다.  
  그래서 등장한 기술이 바로 gRPC이다. gRPC는 다양한 언어로 클라이언트/서버를 작성할 수 있는  
  프레임워크이다. 또 gRPC는 이진 메시지 기반의 프로토콜이므로 서비스를 API 우선 방식으로 설계할 수  
  밖에 없다. gRPC API는 Protocol Buffer(구조화 데이터를 직렬화하는 Google의 언어 중립적 메커니즘)  
  기반의 IDL로 정의하며, Protocol Buffer 컴파일러로 클라이언트 쪽 stub 및 서버 쪽 skeleton을  
  생성할 수 있다. 이 컴파일러를 이용하면 Java, C#, Node.js, Go 언어 등 다양한 언어의 코드를  
  생성할 수 있다. 클라이언트/서버는 Protocol Buffer 포맷의 이진 메시지를 HTTP/2를 통해 교환한다.

- gRPC API는 하나 이상의 서비스와 요청/응답 메시지 definition으로 구성된다.  
  Java Interface와 비슷한 Service Definition은 정적 타입 메소드를 모아 놓은 것이다.  
  gRPC는 단순 요청/응답 RPC는 물론 스트리밍 RPC도 지원하므로 서버가 클라이언트에 Message Stream을  
  응답하는 것도 가능하다. 반대로 클라이언트가 서버로 Message Stream을 보낼 수도 있다.

- gRPC는 Protocol Buffer 메시지 포맷을 사용한다. Protocol Buffer는 간결하고 효율적인  
  이진 포맷이다. Protocol Buffer 메시지는 각 필드마다 번호가 매겨지고 타입 코드가 할당된다.  
  메시지 수신자는 자신이 필요한 필드만 추출하고 모르는 필드는 그냥 건너뛸 수 있기에 하위 호환성을 유지하며  
  API를 발전시킬 수 있다.

- 아래 코드는 주문 서비스의 gRPC API 코드이다. `CreateOrderRequest`를 매개변수로 받아  
  `CreateOrderReply`를 반환하는 `createOrder()` 등의 메소드가 정의되어 있다.

```proto
service OrderService {
  rpc CreateOrder(CreateOrderRequest) returns (CreateOrderReply) {}
  rpc cancelOrder(CancelOrderRequest) returns (CancelOrderReply) {}
  rpc replaceOrder(ReplaceOrderRequest) returns (ReplaceOrderReply) {}

  //...
}

message CreateOrderRequest {
  int64 restaurantId = 1;
  int64 consumerId = 2;
  repeated LineItem lineItems = 3;

  //...
}

message LineItem {
  string menuItemId = 1;
  int32 quantity = 2;
}

message CreateOrderReply {
  int64 orderId = 1;
}

//...

```

- `CreateOrderRequest`와 `CreateOrderReply`는 타입이 정해진 메시지(typed message)이다.  
  `CreateOrderRequest`를 보니 int64형 retaurantId 필드가 있고 태그 값은 1이다.

- gRPC는 아래와 같은 장점이 있다.

  - 다양한 업데이트 작업이 포함된 API를 설계하기 쉽다.
  - 특히 큰 메시지를 교환할 때 효율적인 IPC 이다.
  - 양방향 streaming 덕분에 RPI, Messaging 두 가지 통신 방식 모두 가능하다.
  - 다양한 언어로 작성된 클라이언트/서버 간 연동이 가능하다.

- 아래와 같은 단점도 있다.

  - JS 클라이언트가 하는 일이 REST/JSON 기반 API보다 더 많다.
  - 구형 방화벽은 HTTP2를 지원하지 않는다.

- gRPC는 REST를 대체할 만한 유력한 방안이지만, REST처럼 동기 통신하는 메커니즘이라서  
  부분 실패는 아직 풀지 못한 숙제이다.

---

## 부분 실패 처리: 서킷 프레이커(회로 차단기) 패턴<

- 분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 항상 존재한다.  
  클라이언트/서비스는 모두 개별 프로세스로 동작하기 때문에 서비스가 클라이언트의 요청에 제때 응답하지  
  못하거나, 유지보수 또는 기술적 오류 때문에 서비스가 내려갈 수도 있다. 또한 서비스에 과부하가 걸려  
  응답이 매우 늦어지는 경우도 있다.

- 클라이언트는 응답 대기 도중 블로킹되기 때문에 서비스 실패는 클라이언트의 클라이언트로 거슬러  
  올라가면서 전체 시스템의 중단을 초래할 수도 있다.

> Circuit Breaker Pattern: 연속 실패 횟수가 임계치를 초과하면 일정 시간 동안 호출을  
> 즉시 거부하는 RPI Proxy이다.

- API 클라이언트가 애플리케이션에 진입하는 관문인 API Gateway에 모바일 클라이언트가 REST 요청을 하지만  
  API Gateway가 요청을 위임한 주문 서비스는 묵묵부답인 상태를 생각해보자.

- API Gateway가 주문 서비스에게 요청을 위임할 때 사용하는 주문 서비스 프록시(`OrderServiceProxy`)를 그냥  
  곧이곧대로 구현하면 응답을 기다리며 무한정 블로킹할 것이다. 이는 UX 측면에서도 좋지 않지만, 스레드 같은  
  주요 리소스가 고갈되어서 결국 API Gateway가 요청을 처리할 수 없게 될 것이다.  
  당연히 전체 API는 사용 불능 상태가 될 것이다.

- 따라서 부분 실패가 애플리케이션 전체에 전파되지 않도록 서비스를 설계해야 한다.  
  해결책은 두 부분으로 나뉜다.

  - 무응답 원격 서비스를 처리하기 위해 `OrderServiceProxy`같은 견고한 RPI Proxy를 설계한다.
  - 원격 서비스가 실패하면 어떻게 조치해야 할지 결정한다.

### 견고한 RPI Proxy 설계

- 서비스가 다른 서비스를 동기 호출할 때 자기 스스로를 방어하는 방법들은 아래와 같다.

  - **네트워크 타임아웃** : 응답 대기중에 무한정 블로킹하지 않고 항상 timeout을 걸어둔다.  
    이렇게 해야 리소스가 마냥 붙잡히지 않는다.
  - **미처리 요청(Outstanding request) 개수 제한** : 클라이언트가 특정 서비스에 요청 가능한  
    미처리 요청의 최대 개수를 설정한다. 이 개수에 이르면 더 이상의 요청은 무의미하므로 즉시 실패 처리하는  
    것이 타당하다.
  - **Circuit Breaker** : 성공/실패 요청 개수를 지켜보다가 에러율이 주어진 임계치를 초과하면  
    그 이후의 시도는 바로 실패 처리한다. 실패된 요청이 많다는 것은 서비스가 불능 상태이고 더 이상의  
    요청은 무의미하다는 뜻이다. Timeout 시간 이후 클라이언트가 재시도해서 성공한다면 회로 차단기는 닫힌다.

- Netflix Hystrix는 이와 같은 다양한 패턴이 구현된 오픈소스 라이브러리이다.  
  JVM 환경이라면 hystrix를 이용하여 RPI Proxy를 구현해 봄직하다.

### 불능 서비스 복구

- Hystrix 같은 라이브러리는 부분적인 솔루션에 불과하다. 무응답 원격 서비스를 어떻게 복구하면 좋을지는  
  그때그때 상황에 맞게 판단해야 한다. 앞서 본 예시 상황처럼 주문 생성 요청이 실패하는 상황에서는 그냥  
  알기 쉽게 서비스가 클라이언트에 에러를 반환하는 것이 낫다. API Gateway가 할 수 있는 것은 모바일  
  클라이언트에게 에러를 반환하는 것 뿐이다.

- 부분 실패 시 미리 정해진 기본값이나 캐시된 응답 등 대체 값(Fallback value)을 반환할 수도 있다.  
  API Gateway가 필요한 API들을 조합해서 `GET /orders/{orderId}` endpoint를 구현한다 하자.  
  이 endpoint는 주문 서비스, 주방 서비스, 배달 서비스 등을 호출해서 그 결과를 조합한다.

- 물론 모든 서비스의 데이터가 클라이언트에게 똑같이 중요하지는 않다.  
  이 상황에서는 주문 서비스 데이터가 가장 중요하다. 서비스가 불능 상태가 되어도 다른 서비스 데이터는  
  상대적으로 덜 중요하기 때문에 API Gateway는 캐시된 버전의 데이터 또는 에러를 반환한다.  
  예를 들어 배달 서비스가 불능 상태가 될 경우, API Gateway가 캐시된 버전의 데이터를 반환하거나  
  아예 해당 데이터를 응답에서 제거해도 클라이언트는 유용한 정보를 사용자에게 표시할 수 있을 것이다.

- 부분 실패를 처리하도록 서비스를 설계하는 것 외에도 RPI 사용 시 해결해야할 이슈가 많다.  
  어떤 서비스가 다른 서비스를 RPI로 호출할 때 해당 서비스 인스턴스의 네트워크 위치를 알고 있어야 하는 것도  
  문제다. 이를 해결해주는 것이 Service Discovery이다.

---

## 서비스 디스커버리(Service Discovery)

- REST API가 있는 어떤 서비스를 호출하는 코드를 개발한다 해보자.  
  이 서비스를 호출하는 코드는 서비스 인스턴스의 네트워크 위치(IP주소 및 포트)를 알고 있어야  
  요청을 할 수 있다. 물리적인 하드웨어를 기반으로 실행되는 기존 애플리케이션은 서비스 인스턴스의  
  네트워크 위치가 대부분 정적이다. 어쩌다 한 번 업데이트 되는 구성 파일에서 네트워크 위치를  
  읽어 오면 된다. 하지만 요즘 클라우드 기반의 마이크로서비스 애플리케이션은 네트워크 위치가  
  훨씬 동적이기 때문에 이를 식별하는 일이 결코 간단하지 않다.

- 서비스 인스턴스마다 네트워크 위치가 동적 배정되고, 서비스 인스턴스는 자동 확장, 실패,  
  업그레이드 등 여러 가지 사유로 계속 달라지므로 클라이언트 코드는 서비스 디스커버리를  
  사용할 수 밖에 없다.

### 서비스 디스커버리 개요

- 서비스 IP 주소가 정적으로 구성된 클라이언트 대신 디스커버리 메커니즘을 사용해야 한다.  
  개념은 아주 간단하다. 핵심은 애플리케이션 서비스의 인스턴스화 네트워크 위치를 DB화한  
  **서비스 레지스트리(Service Registry)** 이다.

- 서비스 인스턴스가 시작/종료할 때마다 서비스 레지스트리가 업데이트된다.  
  클라이언트가 서비스를 호출하면 우선 서비스 디스커버리가 서비스 레지스트리에서 가용 서비스의  
  인스턴스 목록을 가져오고, 그 중 한 서비스로 요청을 라우팅한다.

- 서비스 디스커버리는 주로 아래 두 가지 방법으로 구현한다.

  - 클라이언트/서비스가 직접 서비스 레지스트리와 상호 작용한다.
  - 배포 인프라로 서비스 디스커버리를 처리한다.

### 애플리케이션 수준의 서비스 디스커버리 패턴 적용

- 이 방법은 애플리케이션 클라이언트/서비스가 서비스 레지스트리와 직접 통신하는 방법이다.  
  서비스 인스턴스는 자신의 네트워크 위치를 서비스 레지스트리에 등록하고, 서비스 클라이언트는 이 서비스  
  레지스트리로부터 전체 인스턴스 목록을 가져와 그중 한 인스턴스로 요청을 라우팅한다.

- 이는 두 가지 패턴을 조합한 서비스 디스커버리 방식이다.  
  첫째로 **자가 등록(Self Registration) 패턴** 이다. 서비스 인스턴스는 자신의 네트워크 위치를  
  서비스 레지스트리 등록 API를 호출하여 등록한다. Health Check API를 제공하는 서비스도 있다.

> 자가 등록 패턴: 서비스 인스턴스는 서비스 레지스트리에 자기 자신을 등록한다.

- 둘째, **클라이언트 쪽 서비스 레지스트리 패턴** 이다. 클라이언트는 서비스를 호출할 때 먼저  
  서비스 레지스트리에 서비스 인스턴스 목록을 요청해서 넘겨받는다.(캐싱하면 성능 개선이 가능하다.)  
  그런 다음 서비스 클라이언트는 Round-Robin이나 Random같은 부하 분산 알고리즘을 이용하여  
  서비스 인스턴스를 선택한 후 요청을 전송한다.

> 클라이언트쪽 디스커버리 패턴: 서비스 클라이언트는 서비스 레지스트리에 있는 가용 서비스 인스턴스  
> 목록을 조회하고 부하 분산한다.

- 애플리케이션 수준의 서비스 디스커버리는 Netflix와 Pivotal 덕분에 대중화되었다.  
  Netflix는 Eureka라는 고가용성 서비스 레지스트리, Eureka Java Client, Ribbon 등  
  여러 가지 컴포넌트를 개발하고 오픈소스화 했다. Pivotal은 이 Netflix 컴포넌트를 아주 쉽게  
  사용할 수 있게끔 Spring Cloud라는 Spring기반의 프레임워크를 개발했다.  
  Spring Cloud 기반의 서비스는 Eureka에 자동 등록되며, Spring Cloud 기반의 클라이언트는  
  Eureka를 기본 서비스 디스커버리로 사용한다.

- 애플리케이션 수준의 서비스 디스커버리는 다양한 플랫폼에 서비스가 배포된 경우에도 처리 가능하다는  
  장점이 있다. 가령 일부 서비스만 K8S에 배포하고 나머지는 레거시 환경에서 실행하고 싶을 때도 있을 것이다.  
  K8S에 기반한 서비스 디스커버리는 K8S 내부에서만 동작하지만, Eureka를 사용하는 애플리케이션  
  수준의 디스커버리는 두 환경 모두 잘 동작한다.

- 그러나 사용하는 언어에 맞는 서비스 디스커버리 라이브러리가 필요한 단점이 있다.  
  예를들어 Spring Cloud는 Spring 개발자에게는 도움이 되겠지만, 다른 Java 프레임워크나 비 JVM 언어를  
  사용하는 개발자는 다른 서비스 디스커버리 프레임워크를 찾아봐야 할 것이다.  
  서비스 레지스트리를 직접 설정/관리하는 업무가 가중되는 부담도 있다. 따라서 배포 인프라 업체가 제공한  
  서비스 디스커버리 메커니즘을 활용하는 것이 좋다.

### 플랫폼에 내장된 서비스 디스커버리 패턴 적용

- Docker, K8S 등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 메커니즘에 탑재되어 있다.  
  배포 플랫폼은 DNS명, 가상 IP 주소(VIP), VIP 주소로 해석되는 DNS명을 각 서비스마다 부여한다.  
  서비스 클라이언트가 DNS명/VIP명을 요청하면 배포 플랫폼이 알아서 가용 서비스 인스턴스 중 하나로 요청을  
  라우팅한다. 배포 플랫폼이 서비스 등록, 서비스 디스커버리, 요청 라우팅을 전부 관장하는 것이다.

- 서비스 IP 주소를 추적하는 서비스 레지스트리는 배포 플랫폼에 내장되어 있다.

- 이 방식은 아래 두 패턴을 접목시킨 것이다.

  - **서드파티 등록 패턴**: 서비스가 자신을 서비스 레지스트리에 등록하는 것이 아니라, 배포 플랫폼의 일부인  
    등록기(Registrar)라는 서드 파티가 이 작업을 대행한다.
  - **서버 쪽 디스커버리 패턴**: 클라이언트가 서비스 레지스트리를 질의하지 않고 DNS명을 요청한다.  
    그러면 서비스 레지스트리를 쿼리하고 요청을 부하 분산하는 요청 라우터로 해석된다.

- 플랫폼에서 기본 제공된 서비스 디스커버리를 사용하면 서비스 디스커버리를 모두 배포 플랫폼이 알아서 처리하므로  
  아주 편리하다. 서비스 디스커버리 관련 코드는 클라이언트/서비스 어느 쪽에도 없기 때문에 서비스 개발 언어와  
  상관없이 모든 클라이언트/서비스에 곧바로 적용할 수 있다.

- 물론 해당 플랫폼으로 배포한 서비스 디스커버리만 지원되는 단점도 있다.  
  가령 K8S에 기반한 디스커버리는 오직 K8S로 배포한 서비스에만 적용된다.

---
