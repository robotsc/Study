# 오류

- 다른 언어와 Go의 오류 처리 방식은 매우 다르다. 예외(exception)에 익숙한 사람들에게는 Go의 접근 방식이 매우 낯설 수 있다.  
  하지만 Go의 접근법에는 견고한 소프트웨어 엔지니어링 원칙이 있다. 이번에는 Go에서 오류를 처리하는 방식을 살펴보자.  
  또한 실행을 중지해야 하는 오류를 처리하기 위핸 Go 시스템의 panic, recover도 알아보자.

## 오류 처리 방법: 기초

- 이전에 봤듯이, Go는 함수에 마지막 반환 값으로 error 타입의 값을 반환해 오류를 처리한다. 이는 전적으로 관례에 의한 것이지만, 절대 위반해서는  
  안되는 강력한 관례이다. 함수가 예상했던대로 수행되면 error로는 nil이 반환된다. 만약 문제가 있었다면 오류 값이 반환된다.  
  호출 함수는 오류 반환값이 nil인지를 확인해 오류 처리를 하거나 해당 값을 그냥 반환한다.

```go
func calcRemainderAndMod(numerator, denominator int) (int, int, error) {
	if denominator == 0 {
		return 0, 0, errors.New("denominator is 0")
	}
	return numerator / denominator, numerator % denominator, nil
}
```

- 새로운 오류는 `error` 패키지에 있는 `New()` 함수를 호출하면서 문자열과 함께 생성된다. 오류 메시지는 대문자를 사용하거나 구두점, 혹은  
  줄 바꿈으로 마무리되어서는 안된다. 대부분의 경우에는 nil이 아닌 오류를 반환할 때 다른 반환 값은 zero-value로 설정한다.  
  Sentinel error를 볼 때 이 규칙에 대한 예외를 볼 수 있다.

- 예외(exception)가 있는 언어들과는 달리, Go는 오류가 반환되는 것을 검출하는 특별한 구문이 없다. 함수가 반환될 때마다 if문을 사용해  
  오류 변수가 nil인지 아닌지 확인한다.

```go
func main() {
	numerator := 20
	denominator := 3
	remainder, mod, err := calcRemainderAndMod(numerator, denominator)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Println(remainder, mod)
}
```

- `error`는 단일 메소드를 정의하는 내장 인터페이스이다.

```go
type error interface {
	Error() string
}
```

- 해당 인터페이스를 구현하는 모든 것은 오류로 간주된다. 오류가 발생하지 않았음을 나타내기 위해 함수에서 nil을 반환하는 이유는 nil이 모든 인터페이스 타입에  
  대한 zero-value이기 때문이다.

- Go가 예외를 발생시키는 것 대신에 반환된 오류를 사용하는 두 가지 좋은 이유가 있다. 첫 번째로 코드에 하나 이상의 새로운 코드 경로를 추가한다.  
  이 경로는 특히 함수가 예외가 가능하다는 선언이 포함되지 않은 언어에서 명확하지 않은 경우가 있다. 이는 예외가 알맞게 처리되지 않았을 때 놀라운 방법으로  
  crash가 나는 코드를 만들거나 더 심각한 경우에는 crash는 나지만 데이터가 제대로 초기화, 수정, 저장되지는 않는 코드를 만들게 된다.

- 두 번째 이유는 Go의 기능이 동작하는 방법을 보여준다는 것이다. Go 컴파일러는 모든 변수들을 반드시 읽을 수 있어야 한다. 반환 값으로 오류를 만드는 것은  
  개발자에게 오류 조건을 확인하고 처리하는 것을 강제하거나 오류 값으로 `_`를 사용해 오류를 명시적으로 무시하도록 한다.

- 예외 처리는 더 짧은 코드를 생성할 수 있도록 하지만, 더 적은 코드를 사용한다고 해서 코드를 더 쉽게 이해하거나 유지 관리할 수 있는 것은 아니다.  
  앞서 봤듯이 관용적 Go는 코드 라인이 더 많이 생성되더라도 명확한 코드를 선호한다.

- 주목해야 하는 또 다른 사항은 Go에서 코드 흐름의 방식이다. 오류 처리는 if문 내에 들여 작성된다. 하지만 비즈니스 로직은 그렇지 않다.  
  이는 어떤 코드가 _golden path_ 를 따르고, 어떤 코드가 예외적인 조건인지에 대한 빠른 시각적 단서를 제공한다.

---
