# Reflect, Unsafe, Cgo

## Reflection: Runtime에 동적으로 타입 제어

- Go는 정적 타입 언어이고, 대부분 변수, 타입 및 함수를 선언하는 것은 꽤나 직관적이다.

```go
type Foo struct {
	A int
	B string
}

var x Foo

func DoSomething(f Foo) {
	fmt.Println(f.A, f.B)
}
```

- 하지만 때로는 텀파일 시점의 정보에만 의존하기 어려울 때가 있다. 예를 들어, 프로그램이 작성되는 시점에 존재하지 않는 정보를 사용해 runtime에  
  변수로 작업할 필요가 있다. 파일 혹은 네트워크 요청에서 데이터를 변수로 mapping하려 하거나, 다른 타입에서 동작하는 단일 함수를 빌드하려  
  할 수 있다. 이런 상황에서 **reflection** 을 사용할 수 있다. Reflection은 runtime에 타입을 점검할 수 있도록 한다. 또한 runtime에  
  변수, 함수 및 구조체를 검증, 수정, 생성하는 기능을 제공한다.

- 그렇다면 이 기능은 언제 사용할까? Go 표준 라이브러리를 보고 이에 대한 해답을 얻을 수 있다.

  - Database 읽기 및 쓰기: `database/sql` 패키지는 record에서 database로 전송 및 읽어오기 위해 reflection을 사용한다.
  - Go의 내장 템플릿 라이브러리: `test/template`, `html/template`은 템플릿으로 전달된 값을 처리하기 위해 reflection을 사용한다.
  - `fmt.Println()` 및 관련 함수: 제공된 파라미터의 타입 검증을 위해 reflection을 사용한다.
  - `errors` 패키지: `errors.Is()`, `errors.As()`의 구현을 위해 reflection을 사용한다.
  - `sort`: `sort.Slice()`, `sort.SliceStable()`, `sort.SliceIsSorted()` 에서 모든 타입의 slice를 평가하고  
    정렬하는 함수를 구현하기 위해 reflection을 사용한다.
  - 다양한 `encoding` 패키지에 정의된 서로 다른 데이터 format과 함께 JSON 및 XML로 data marshalling 및 unmarshalling을  
    수행할 때: 구조체 태그는 reflection을 통해 접근되고 구조체의 항목 또한 reflection을 사용해 읽기, 쓰기가 수행된다.

> Go 표준 라이브러리 중 하나인 `reflect` 패키지는 testing을 위한 용도로도 사용된다.  
> `reflect.DeepEqual()`은 reflection을 이용해 작업을 수행하기에 `reflect` 패키지에 있는 것이다. 이 함수는 두 값이 _"내부적으로"_  
> 같은지를 확인한다. 이는 두 값의 비교를 위해 `==`를 사용하는 것 보다 훨씬 더 철저하게 비교하게 되며, 테스트 결과를 검증하기 위한 방법으로  
> 표준 라이브러리에서 사용된다. 또한 sice, map과 같이 `==`로는 비교할 수 없는 것들을 비교할 수 있다.

### 타입, 종류 및 값

- 표준 라이브러리의 `reflect` 패키지는 Go에서 reflection을 사용해 구현된 함수와 타입들이 대부분 담겨 있다.  
  그리고 reflection은 타입, 종류, 및 값의 3개 주요 개념으로 구성된다.

#### 타입, 종류

- 타입은 변수의 속성은 무엇을 가지는지, 어떻게 해당 타입과 상호작용하는지 등을 정의한다.

- `reflect` 패키지의 `TypeOf()` 함수를 사용하면 변수 타입의 reflection 표현을 얻을 수 있다.

```go
vType := reflect.TypeOf(v)
```

- `reflect.TypeOf()`는 전달된 변수의 타입을 알아내기 위해 `reflect.Type` 타입의 값을 반환한다. 이 타입은 변수의 타입에 대한  
  정보과 함께 메소드를 정의한다. 메소드들 중 일부를 보자.

```go
var x int
xt := reflect.TypeOf(x)
fmt.Println(xt.Name()) // "int"
f := Foo{}
ft := reflect.TypeOf(f)
fmt.Println(ft.Name()) // "Foo"
xpt := reflect.TypeOf(&x)
fmt.Println(xpt.Name()) // ""
```

- 위에서 볼 수 있듯이 `reflect.TypeOf()`로 반환된 `reflect.Type` 타입은 타입의 이름을 반환해주는 `Name()` 메소드를 가진다.

- `reflect.Type`의 `Kind()` 메소드는 타입이 무엇으로(slice, map, 포인터, 구조체, 인터페이스, 문자열, 배열, 함수, 정수 또는  
  다른 기본 타입)만들어져 있는지를 알려주는 상수인 `reflect.Kind` 타입의 값을 반환한다.

- 종류와 타입의 차이는 이해하기 어려울 수 있다. `Foo`라는 struct가 있을 때 종류는 `reflect.Struct`이고 타입은 `"Foo"`이다.

- Reflection을 사용할 때 한 가지 주의할 점은 `reflect` 패키지에 있는 모든 것은 개발자가 무엇을 하는지 알고 있다고 가정한 채로 구현되어  
  있다는 것이다. 한 가지 예시로 `reflect.Type`에 정의된 몇 가지 메소드와 `reflect` 패키지에 있는 다른 타입은 특정 종류에만 의미가  
  있다. 예를 들어 `reflect.Type`에는 `NumIn()`이라는 메소드가 있고, 이 함수는 `reflect.Type`이 함수를 나타낸다면 해당 함수의  
  입력 파라미터 개수를 반환한다. 만약 함수를 나타내지 않는데 `NumIn()`을 호출하면 panic에 빠질 것이다.

- `reflect.Type`의 또다른 중요한 메소드로 `Elem()`이 있는데, 이는 어떤 타입이 다른 타입을 참조할 때 참조하는 타입을 반환한다.

```go
func main() {
	var x int = 10
	xpt := reflect.TypeOf(&x)
	fmt.Println(xpt.Name())        // ""
	fmt.Println(xpt.Kind())        // ptr
	fmt.Println(xpt.Elem().Name()) // int
	fmt.Println(xpt.Elem().Kind()) // int
}
```

- `reflect.Type`이 구조체를 나타낸다면 항목 수를 얻기 위한 `NumField()` 메소드와 `Field()`와 index로 구조체의 항목을  
  얻을 수 있다.

```go
type Foo struct {
	A int    `myTag:"value"`
	B string `myTag:"value2"`
}

func main() {
	var f Foo
	ft := reflect.TypeOf(f)
	for i := 0; i < ft.NumField(); i++ {
		curField := ft.Field(i)
		fmt.Println(curField.Name, curField.Type.Name(), curField.Tag.Get("myTag"))
	}

	/**
	A int value
	B string value2
	*/
}
```

### 값

- 변수의 타입을 검사하는 것 뿐만 아니라, 변수의 값을 읽고 값을 설정하거나 처음부터 새로운 값을 생성할 때도 reflection을 사용할 수 있다.

- 변수의 값을 나타내는 `reflect.Value` 인스턴스를 생성하기 위해서는 `reflect.ValueOf()` 함수를 사용할 수 있다.

```go
vValue := reflect.ValueOf(v)
```

- Go에서 모든 변수는 타입을 갖기에 `reflect.Value`는 `reflect.Value`의 `reflect.Type`을 반환하는 `Type()` 메소드를 가진다.  
  그리고 `Kind()`도 가진다.

```go
func main() {
	s := []string{"a", "b", "c"}
	sv := reflect.ValueOf(s) // sv의 타입: reflect.Value
	s2 := sv.Interface().([]string) // s2의 타입: []string
}
```

- 모든 종류의 값을 포함하는 `reflect.Value` 인스턴스를 얻기 위해 `Interface()`를 호출할 수 있지만, 변수의 종류가 내장 타입이나  
  기본 타입 중 하나이 경우에 사용할 수 있는 특별한 경우의 메소드인 `Bool()`, `Complex()`, `Int()`, `Uint()`, `Float()`,  
  `String()`이 있다. 또한 변수의 타입이 byte slice일 때 동작하는 `Bytes()` 메소드도 있다. 만약 `reflect.Value`의 타입과  
  잋리하지 않는 메소드를 사용하면 panic이 발생한다.

- Reflection으로 변수의 값도 설정할 수 있는데, 아래의 3단계를 거친다.

```go
// (1) 변수를 가리키는 포인터를 reflect.ValueOf()로 전달
i := 10
iv := reflect.ValueOf(&i)

// (2) 설정하려는 값을 가져온다.
// reflect.ValueOf()로 전달했던 포인터가 가리키는 값을 얻기 위해 Elem()을 사용한다.
ivv := iv.Elem()

// (3) 값을 설정하기 위해 사용되는 메소드를 호출한다.
ivv.SetInt(20)
fmt.Println(i) // 20
```

- 값을 설정할 때는 기본 타입을 읽기 위한 `Bool()`, `Int()`가 있는 것처럼 `SetBool()`, `SetInt()`, `SetFloat()`,  
  `SetString()`, `SetUint()`가 있다. 모든 타입을 설정하려면 `Set()`을 사용하면 된다.

- 값을 변경할 때 `reflect.ValueOf()`에 포인터를 전달하는 이유는 Go의 다른 모든 함수와 같이 파라미터의 값을 수정하기 위함이다.  
  즉, 포인터를 역참조해 값을 설정할 수 있기 때문이다.
