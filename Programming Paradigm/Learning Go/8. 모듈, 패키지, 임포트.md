# 모듈, 패키지, 임포트

- 최신 프로그래밍 언어는 namespace나 라이브러리로 코드를 구성하기 위한 시스템을 갖고 있고, Go도 예외는 아니다.  
  다른 기능을 살펴보면서 봤듯이 Go는 이 오랜 아이디어에 대한 몇 가지 새로운 접근 방식을 소개한다.  
  이번에는 패키지와 모듈로 코드를 구성해 가져오는 import 방법, 3rd-party 라이브러리와 동작하는 방법, 그리고 자신만의  
  라이브러리를 만드는 방법을 살펴보자.

## 저장소, 모듈, 패키지

- Go에서 라이브러리 관리는 저장소, 모듈, 패키지라는 개념에 기반한다. 저장소는 모든 개발자에게 익숙한 것으로, 프로젝트를 위한 소스코드가 저장된  
  VCS의 공간이다. 모듈은 저장소에 저장된 Go 라이브러리나 응용 프로그램의 최상위 루트이다. 모듈은 모듈 구성 및 구조를 제공하는 하나 이상의 패키지로  
  구성되어 있다.

> 저장소에 하나 이상의 모듈을 저장할 수는 있지만, 권장되지는 않는다. 모듈 내에 있는 모든 것은 함께 버전 지정이 되기 때문이다.  
> 하나의 저장소에 두 개 이상의 모듈을 관리한다는 것은 단일 저장소에 다른 두 개 이상의 프로젝트를 위한 분리된 버전을 만들어야함을 의미한다.

- 표쥰 라이브러리의 외부 패키지에서 가져온 코드를 사용하기 전에, 우리의 프로젝트가 모듈로 선언되었는지 확인할 필요가 있다.  
  모든 모듈은 전역적으로 유일한 식별자를 가지고 있어야 한다. 이는 Go에서만 적용되는 사항은 아닌데, 예를 들어 Java는 `com.organization.library`와  
  같이 전역적으로 유일한 패키지명을 사용한다.

- 보통 Go에서는 모듈이 있는 곳의 모듈 저장소 경로를 사용한다. 예를 들어, Go에서 RDBMS의 접근을 간소화하는 Proteus라는 모듈은 Github에서 볼 수 있다.

---

## `go.mod`

- Go 소스 코드의 컬렉션은 해당 루트 디렉토리에 유효한 `go.mod` 파일이 있을 때 모듈이 된다. 해당 파일을 수동으로 생성하는 것보다, 모듈을 관리하기 위한  
  `go mod` 명령의 하위 명령어를 사용하는 것이 좋다. `go mod init $MODULE_PATH` 명령어는 현재 디렉토리를 모듈의 root로 만드는 `go.mod`  
  파일을 생성한다. `MODULE_PATH`는 해당 모듈을 식별하기 위한 전역적으로 유일한 이름이다. 모듈 경로는 대소문자를 구분하며, 혼선을 줄이기 위해  
  대문자를 사용하지 않는다.

- 아래는 `go.mod` 파일의 간단한 내용이다.

```mod
module github.com/daangn/minimemcached

go 1.15

require (
	github.com/benbjohnson/clock v1.3.0
	github.com/bradfitz/gomemcache v0.0.0-20220106215444-fb4bf637b56d
	github.com/rs/zerolog v1.26.1
)
```

- 모든 `go.mod` 파일은 module이라는 단어와 모듈의 유일한 경로로 구성되는 module 선언으로 시작된다. 다음으로는 Go의 최소 호환 버전을 지정하고,  
  마지막으로 require 섹션에 해당 모듈이 의존하는 다른 모듈과 각 모듈에 필요한 최소 버전이 나열된다. 만약 모듈이 다른 어떠한 모듈에도 의존하지 않는다면  
  require 섹션은 생략할 수 있다.

- 추가적으로 두 가지 선택적 섹션이 있는데, replace 섹션은 의존성 있는 모듈이 있는 위치를 재정의할 수 있고, exclude 섹션은 특정 버전의 모듈의  
  사용을 막을 수 있다.

---
