# 산술 연산자 오버로딩

- 코틀린에서 관례를 사용하는 가장 단순한 예는 **산술 연산자**다. Java에서는 원시 타입에 대해서만 산술 연산자를  
  사용할 수 있고, 추가적으로 `String`에 대해서는 `+` 연산자를 사용할 수 있다. 그러나 다른 클래스에서도  
  산술 연산자가 유용한 경우가 있다. 예를 들어 `BigInteger`를 다룬다면 `add()`를 명시적으로 호출하기보다는  
  `+` 연산을 사용하는 편이 더 낫다. 컬렉션에 원소를 추가하는 경우에도 `+=` 연산자를 사용할 수 있으면 더 좋다.  
  코틀린에서는 이런 일이 가능하다.

## 이항 산술 연산 오버로딩

- 점을 표현하는 `Point` 클래스를 보자. 이 클래스에서 두 점을 더하는 연산을 지원하고 싶다 하자.  
  아래 코드는 `+` 연산자 구현을 보여준다.

```kt
data class Point(val x: Int, val y: Int) {
  operator fun plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
  }
}


// client
val point1 = Point(1, 2)
val point2 = Point(2, 3)
val point3 = point1 + point2
println(point3)
// Point(x=3, y=5)
```

- `plus()` 함수 앞에 operator 키워드를 붙여야 한다. **연산자를 오버로딩하는 함수 앞에는 operator가 꼭 있어야 한다.**  
  operator 키워드를 붙임으로써 어떤 함수가 관례를 따르는 함수임을 명확히 할 수 있다. operator가 없는데 실수로 관례에서  
  사용하는 함수명을 쓰고 우연히 그 이름에 해당하는 기능을 사용한다면 오류가 나며, 이 오류 메시지를 통해 이름이 겹쳤다는 사실을  
  알고 문제를 해결할 수 있다.

- operator 변경자를 추가해 `plus()`를 선언하면 `+` 기호로 두 `Point` 객체를 더할 수 있다.

- 아래처럼 연산자를 멤버 함수로 만드는 대신, 확장 함수로 정의할 수도 있다.

```kt
operator fun Point.plus(other: Point): Point {
  return Point(x + other.x, y + other.y)
}
```

- 위 구현도 앞의 구현과 동일하다. 외부 함수의 클래스에 대한 연산자를 정의할 때는 관례를 따르는 이름의 확장 함수로 구현하는 게  
  일반적인 패턴이다. 프로젝트 내에서 직접 작성한 클래스에 대해 관례를 따르는 확장 함수를 만들어도 역시 잘 작동한다.

- 다른 언어와 비교할 때 코틀린에서 오버로딩한 연산자를 정의하고 사용하기가 더 쉽다. 코틀린에서는 프로그래머가 직접 연산자를  
  만들어 사용할 수 없고, 언어에서 미리 정해둔 연산자만 오버로딩할 수 있으며, 관례에 따르기 위해 클래스에서 정의해야 하는  
  이름이 연산자별로 정의되어 있다. 아래 표를 보자.

| 식     | 함수 이름             |
| ------ | --------------------- |
| a \* b | `times`               |
| a / b  | `div`                 |
| a % b  | `rem`(이전에는 `mod`) |
| a + b  | `plus`                |
| a - b  | `minus`               |

- 직접 정의한 함수를 통해 구현하더라도, 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선순위와 같다.

> - **연산자 함수와 Java**
>
> - 코틀린 연산자를 Java에서 호출하기는 쉽다. 모든 오버로딩한 연산자는 함수로 정의되며, 긴 이름(FQN)을 사용하면  
>   일반 함수로 호출할 수 있다. Java를 코틀린에서 호출하는 경우에는 함수명이 코틀린의 관례에 맞아 떨어지기만 하면  
>   항상 연산자 식을 사용해 그 함수를 호출할 수 있다. 다만 Java에서는 따로 연산자에 표시를 할 수 없으므로 operator 변경자를  
>   사용해야 한다는 요구 사항을 Java 메소드에는 적용할 수 없다. 따라서 이름과 파라미터의 개수만 문제가 된다.  
>   Java 클래스에 이미 원하는 연산자 기능을 제공하는 메소드가 있지만, 이름만 다르다면 관례에 맞는 이름을 가진 확장 함수를  
>   작성하고, 연산을 기존 Java 메소드에 위임하면 된다.

- 연산자를 정의할 때 두 피연산자(연산자 함수와 두 파라미터)가 같은 타입일 필요는 없다. 예를 들어, 어떤 점의 비율에 따라  
  확대, 축소하는 연산자를 정의해보자. 이를 사용해 여러 다른 좌표계 사이에 점을 변환할 수 있다.

```kt
operator fun Point.times(scale: Double): Point {
  return Point((x * scale).toInt(), (y * scale).toInt())
}

// client
val p = Point(10, 20)
println(p * 1.5)
// Point(15, 30)
```

- 코틀린 연산자가 자동으로 교환 법칙(`a op b == b op a`)을 지원하지는 않음에 유의하자. 사용자가 `p * 1.5` 외에  
  `1.5 * p`라고도 쓸 수 있어야 한다면 `p * 1.5`와 같은 식에 대응하는 연산자 함수를 `Double`에 확장 함수로  
  따로 정의해야 한다.

- 연산자 함수의 반환 타입이 꼭 두 피연산자 중 하나와 일치해야만 하는 것도 아니다.

```kt
operator fun Char.times(count: Int): String {
  return toString().repeat(count)
}
```

- 위 연산자는 `Char`를 좌항으로 받고, `Int`를 우항으로 받아서 `String`을 돌려준다. 이런 식의 피연산자와  
  결과 타입 조합도 완전히 합법적인 연산자 오버로딩이다.

- 일반 함수와 마찬가지로 operator 함수도 오버로딩할 수 있다. 따라서 이름은 같지만, 파라미터 타입이 서로 다른  
  연산자 함수를 여러 개 만들 수 있다.

---

## 복합 대입 연산자 오버로딩

- `plus()`와 같은 연산자를 오버로딩하면 코틀린은 `+` 연산자뿐 아니라 그와 관련 있는 연산자인 `+=`도  
  함께 지원한다. `+=`, `-=` 등의 연산자는 **복합 대입 연산자**라 불린다.

```kt
var point = Point(1, 2)
point += Point(3, 4)
println(point)
// Point(4, 6)
```

- `point += Point(3, 4)`는 `point = point + Point(3, 4)`라고 쓴 식과 같다. 물론 변수가 변경  
  가능한 상태인 경우에만 복합 대입 연산자를 사용할 수 있다.

- 경우에 따라 `+=` 연산이 객체에 대한 참조를 다른 참조로 바꾸기보다, 원래 객체의 내부 상태만 변경하게 만들고  
  싶을 때가 있다. 변경 가능한 컬렉션에 원소를 추가하는 경우가 대표적인 예시이다.

```kt
val numbers = ArrayList<Int>()
numbers += 42
println(numbers[0])
// 42
```

- 반환 타입이 `Unit`인 `plusAssign()` 함수를 정의하면, 코틀린은 `+=` 연산자에 그 함수를 사용한다.  
  다른 복합 대입 연산자 함수도 비슷하게 `minusAssign()`, `timesAssign()` 등의 이름을 사용한다.

- 코틀린 표준 라이브러리는 변경 가능한 컬렉션에 대해 `plusAssign()`을 정의하며, 앞서 본 예시 코드는  
  그 `plusAssign()`을 사용한다.

- 이론적으로는 코드에 있는 `+=`를 `plus()`와 `plusAssign()` 양쪽 모두로 컴파일할 수 있다.  
  따라서 어떤 클래스가 이 두 함수를 모두 정의하고 둘다 `+=`에 사용 가능한 경우, 컴파일러는 오류를 보고한다.  
  일반 연산자를 사용하면 이를 해결할 수 있다. 다른 방법으로 var를 val로 바꿔서 `plusAssign()`의  
  적용이 불가하게 할 수도 있다. 하지만 일반적으로는 새로운 클래스를 일관성 있게 설계하는 게 가장 좋다.  
  **`plus()`와 `plusAssign()` 연산을 동시에 정의하지 말자.** 클래스가 앞서 본 `Point`와 같이  
  변경 불가능하다면 `plus()`와 같이 새로운 값을 반환하는 연산만을 추가해야 한다. 빌더와 같이 변경 가능한  
  클래스를 설계한다면 `plusAssign()`이나 그와 비슷한 연산만을 제공하자.

- 코틀린 표준 라이브러리는 컬렉션에 대해 두 가지 접근 방법을 함께 제공한다. `+`와 `-`는 항상 새로운  
  컬렉션을 반환하며, `+=`와 `-=` 연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를  
  변화시킨다. 또한 읽기 전용 컬렉션에서 `+=`와 `-=`는 변경을 적용한 복사본을 반환한다.  
  따라서 var로 선언한 변수가 가리키는 읽기 전용 컬렉션에서만 `+=`와 `-=`를 적용할 수 있다.  
  이런 연산자의 피연산자로는 개별 원소를 사용하거나, 원소 타입이 일치하는 다른 컬렉션을 사용할 수 있다.

```kt
val list = arrayListOf(1, 2, 3)
list += 4
val newList = list + listOf(5, 6)
println(list) // [1, 2, 3, 4]
println(newList) // [1, 2, 3, 4, 5, 6]
```

---

## 단항 연산자 오버로딩

- 지금까지는 `a + b`와 같이 두 값에 대해 적용하는 이항(binary) 연산에 대해 봤지만, 코틀린은  
  `-a`와 같이 한 값에만 작용하는 단항(unary) 연산자도 제공한다.

- 단항 연산자를 오버로딩하는 절차도 이항 연산자와 마찬가지다. 미리 정해진 이름의 함수를 멤버나 확장 함수로  
  선언하면서 operator로 표시하면 된다.

```kt
operator fun Point.unaryMinus(): Point {
  return Point(-x, -y)
}

// client
val p = Point(10, 20)
println(-p) // (-10, -20)
```

- 단항 연산자를 오버로딩하기 위해 사용하는 함수는 인자를 취하지 않는다.  
  아래 표는 코틀린에서 오버로딩할 수 있는 모든 단항 연산자를 보여준다.

| 식         | 함수명         |
| ---------- | -------------- |
| `+a`       | `unaryPlus()`  |
| `-a`       | `unaryMinus()` |
| `!a`       | `not()`        |
| `a++, ++a` | `inc()`        |
| `a--, --a` | `dec()`        |

- `inc()`나 `dec()` 함수를 정의해 증가/감소 연산자를 오버로딩하는 경우, 컴파일러는 일반적인 값에 대한  
  전위와 후위 증가/감소 연산자와 같은 의미를 제공한다. 아래는 `BigDecimal`의 `++`를 오버로딩하는 예시다.

```kt
operator fun BigDecimal.inc() = this + BigDecimal.ONE

// client
val bigDecimal = BigDecimal.ZERO
println(bigDecimal++) // 0
println(++bigDecimal) // 2
```

- 후위 `++` 연산은 먼저 현재의 bigDecimal 값을 반환한 다음, bigDecimal의 값을 증가시킨다.  
  반면 전위 `++`는 그 반대 순서로 작동한다.

---
