# 보안 서비스 개발

- 애플리케이션 개발자는 주로 아래의 4가지 보안 요소를 구현해야 한다.

  - **인증(authentication)** : 애플리케이션에 접근하는 다른 애플리케이션이나 사람(주체, principal)의 신원을 확인한다.  
    일반적으로 사용자 ID/PW나 애플리케이션 API key/secret 등의 주체가 자격 증명으로 확인된다.

  - **인가(authorization)** : 주체가 어떤 데이터에 어떤 작업을 요청해 수행할 수 있는 권한이 있는지 확인한다.  
    보통 역할 기반(role-based) ACL(Access Control List)을 함께 사용한다. 역할 기반 보안은 사용자마다 하나 이상의  
    역할을 배정해 특정 작업의 호출 권한을 부여하고, ACL은 사용자 또는 역할을 대상으로 특정 비즈니스 객체나 aggregate에  
    작업할 권한을 부여한다.

  - **감사(auditing)** : 보안 이슈 탐지, compliance 시행, 고객 지원을 위해 주체가 수행하는 작업을 추적한다.

  - **보안 IPC** : 모든 서비스를 드나드는 통신이 TLS를 경유하는 것이 가장 이상적이다. 서비스 간 통신은 인증이 필요한 경우도 있다.

## 기존 모놑리틱 애플리케이션의 보안

- 예제 애플리케이션은 소비자, 배달원, 음식점 직원 등 다양한 사용자가 브라우저, 모바일 앱을 통해 접속한다. 누구나 애플리케이션에 접근하려면  
  먼저 로그인을 해야 한다. 아래 그림은 예제 애플리케이션의 클라이언트가 인증을 받고 요청을 하는 과정을 보여준다.

  ![picture 101](/images/MSAP_PRSD_1.png)

- 그림과 같이 사용자가 ID/PW를 입력하면 클라이언트는 사용자 자격 증명을 서버에 POST 요청한다. 서버는 자격 증명이 맞으면 해당 클라이언트에게  
  세션 토큰을 반환한다. 클라이언트는 이후 모든 요청에 이 세션 토큰을 포함시켜 전송한다.

- 아래 그림은 예제 애플리케이션에 구현된 보안을 고수준에서 바라본 모습을 나타낸다.

  ![picture 102](/images/MSAP_PRSD_2.png)

- 위 그림의 보안 아키텍쳐에서 핵심은 session이다. 주체의 ID와 역할이 세션에 보관된다. 세션은 세션 토큰으로 식별하며, 클라이언트는  
  요청할 때마다 세션 토큰을 함께 넣어 보낸다. 세션 토큰은 보통 암호학적으로 강력한 무작위 숫자 등으로 알아보기 어렵게 생성된다.

- Security context(보안 context) 역시 이 아키텍쳐의 주요 오소이다. 여기에는 현재 요청을 보낸 사용자의 정보가 담긴다.

- 이러한 모놀리틱 애플리케이션의 설계는 사실 보안을 구현할 수 있는 유일한 수단이다. 이러한 in-memory session의 한 가지 단점은 특정  
  세션의 요청을 모두 동일한 애플리케이션 인스턴스로 routing해야 한다는 것이다. 이러한 요건은 load balancing 및 작업을 복잡하게  
  만든다. 예를 들어 특정 애플리케이션 인스턴스를 종료하려면 session draining 메커니즘을 직접 구현해야 한다.  
  DB에 세션을 저장시키는 우회책도 있다.

- 서버 쪽 세션을 아예 없애버릴 수도 있다. 실제로 매 요청마다 API key/secret 등의 자격 증명을 제공하는 API 클라이언트가 있기 때문에  
  서버 쪽의 세션을 유지할 필요가 없는 애플리케이션도 많다. 아니면 세션 토큰에 세션 상태를 저장하는 방법도 있다. 그런데 MSA에서 왜  
  보안을 구현하기가 어려운걸까?

---
