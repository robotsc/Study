# 매개변수가 유효한지 검사하라

- 메소드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다.  
  예를 들어 인덱스 값은 음수일 수 없으며, 객체 참조는 null이 아니어야 하는 등이 있다.  
  이런 제약은 반드시 문서화해야 하며 메소드 몸체가 시작되기 전에 검사해야 한다.  
  이는 _"오류는 가능한 한 빨리 잡아야 한다."_ 는 일반 원칙의 한 사례이기도 하다.  
  오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기  
  어려워진다.

- 메소드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어올 때 즉각적이고 깔끔한  
  방식으로 예외를 던질 수 있다. 매개변수를 제대로 하지 못하면 몇 가지 문제가 발생할 수 있다.  
  첫째, 메소드가 수행되는 중간에 모호한 에러를 던지며 실패할 수 있다. 더 나쁜 상황은 메소드가 잘  
  수행되지만 잘못된 결과를 반환할 때다. 한층 더 나쁜 상황은 메소드는 문제없이 수행됐지만, 어떤 객체를  
  이상한 사태로 만들어 놓아서 미래의 알 수 없는 시점에 이 메소드와는 관련 없는 오류를 낼 때다.  
  다시 말해 매개변수 검사에 실패하면 실패 원자성(failure atomicity)을 어기는 결과를 낳을 수 있다.

- public, protected 메소드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.  
  Javadoc 태그 중 `@throws`를 사용하면 된다. 보통은 `IllegalArgumentException`, NPE,  
  `IndexOutOfBoundsException` 중 하나가 될 것이다. 매개변수의 제약을 문서화한다면 그 제약을  
  어겼을 때 발생하는 예외도 함께 기술해야 한다. 이런 간단한 방법으로 API 사용자가 제약을 지킬 가능성을  
  크게 높일 수 있다. 아래는 전형적인 예시다.

```java
/**
 * (현재 값 mod m) 값을 반환한다.
 * 이 메소드는 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메소드와 다르다.
 *
 * @param m 계수(양수여야 한다.)
 * @return 현재 값 mod m
 * @throws java.lang.ArithmeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
  if(m.signum() <= 0)
    throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
  //..
}
```

- 이 메소드는 m이 null이면 `m.signum()`을 호출할 때 NPE를 던진다.  
  그런데 _"m이 null이면 NPE를 던진다."_ 라는 말은 메소드 설명 어디에도 없다. 그 이유는 이 설명을  
  개별 메소드가 아닌 `BigInteger` 클래스 수준에서 기술했기 때문이다. 클래스 수준 주석은 그 클래스의  
  모든 public 메소드에 적용되므로 각 메소드에 일일이 기술하는 것보다 훨씬 깔끔한 방법이다.  
  `@Nullable`이나 이와 비슷한 어노테이션을 사용해 특정 매개변수는 null이 될 수 있다고 알려줄 수도 있지만,  
  표준적인 방법은 아니다. 그리고 같은 목적으로 사용할 수 있는 어노테이션도 여러 가지다.

- **Java7에 추가된 `java.util.Objects.requireNonNull` 메소드는 유연하고 사용하기도 편하니,**  
  **더 이상 null 검사를 수동으로 하지 않아도 된다.** 원하는 예외 메시지도 지정할 수 있다. 또한 입력을  
  그대로 반환하므로 값을 사용하는 동시에 null 검사를 수행할 수 있다.

```java
this.strategy = Objects.requireNonNull(strategy, "전략");
```

- 반환값은 그냥 무시하고 필요한 곳 어디서든 순수한 null 검사 목적으로 사용해도 된다.

- Java9에서는 `Objects`에 범위 검사 기능도 더해졌다. `checkFromIndexSize()`, `checkFromToIndex()`,  
  `checkIndex()`라는 메소드들인데, null 검사 메소드만큼 유연하지는 않다. 예외 메시지를 지정할 수 없고,  
  리스트와 배열 전용으로 설계됐다. 또한 닫힌 범위(closed range; 양 끝단 값을 포함하는)는 다루지 못한다.  
  그래도 이런 제약이 걸림돌이 되지 않는 상황에서는 아주 유용하고 편하다.

- 공개되지 않은 메소드라면 패키지 제작자가 메소드가 호출되는 상황을 통제할 수 있다. 따라서 오직 유효한 값만이  
  메소드에 넘겨지리라는 것을 직접 보증할 수 있고, 그렇게 해야 한다. 다시 말해 public이 아닌 메소드라면  
  단언문(assert)을 사용해 매개변수의 유효성을 검증할 수 있다.

```java
private static void sort(long a[], int offset, int length() {
  assert a != null;
  assert offset >= 0 && offset <= a.length;
  assert length >= 0 && length <= a.length - offset;
  //..
}
```

- 여기서의 핵심은 이 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다.  
  이 메소드가 포함된 패키지를 클라이언트가 어떤 식으로 지지고 볶든 상관 없다. 단언문은 몇 가지 면에서  
  일반적인 유효성 검사와 다르다. 첫째, 실패하면 `AssertionError`를 던진다. 둘째, 런타임에 아무런  
  효과도, 아무런 성능 저하도 없다.(단, java 실행 시 명렬줄에 `-ea` 혹은 `--enableassertions` 플래그를  
  설정하면 런타임에 영향을 준다.)

- 메소드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경써서 검사해야 한다.
  이전에 봤던 코드를 다시 보자.

```java
static List<Integer> intArrayAsList(int[] a) {
  Objects.requireNonNull(a);

  return new AbstractList<Integer>() {
    @Override public Integer get(int i) {
      return a[i];  // Auto-Boxing
    }

    @Override public Integer set(int i, Integer val) {
      int oldVal = a[i];
      a[i] = val;  // Auto-Unboxing
      return oldVal;  // Auto-Boxing
    }

    @Override public int size() {
      return a.length;
    }
  }
}
```

- 위 코드는 입력받은 int 배열의 `List` view를 반환하는 메소드이다. 이 메소드는  
  `Objects.requireNonNull()`을 이용해 null 검사를 수행하므로 클라이언트가 null을 건네면 NPE를 던진다.  
  만약 이 검사를 생략했다면 새로 생성한 `List` 인스턴스를 반환하는데, 클라이언트가 돌려받은 `List`를  
  사용하려 할 때 비로소 NPE가 발생한다. 이때가 되면 이 `List`를 어디서 가져왔는지 추적하기 어려워 디버깅이  
  상당히 괴로워질 수 있다.

- 생성자는 _"나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"_ 는 원칙의 특수한 사례다. 생성자 매개변수의 유효성  
  검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.

- 메소드 몸체 실행 전에 매개변수의 유효성을 검사해야 한다는 규칙에도 예외는 있다. 유효성 검사 비용이 지나치게  
  높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다. 예를 들어 `Collections.sort(List)`처럼  
  객체 리스트를 정렬하는 메소드를 생각해보자. 리스트 안의 객체들은 모두 상호 비교될 수 있어야 하며, 정렬 과정에서  
  이 비교가 이뤄진다. 만약 상호 비교될 수 없는 타입의 객체가 들어있다면 그 객체와 비교할 때 `ClassCastException`을  
  던질 것이다. 따라서 비교하기 앞서 리스트 안의 모든 객체가 상호 비교될 수 있는지 검사해봐야 별다른 실익이 없다.  
  하지만 암묵적 유효성 검사에 너무 의존했다가는 실패 원자성을 해칠 수 있으니 주의하자.

- 때로는 계산 과정에서 필요한 유효성 검사가 이뤄지지만, 실패했을 때 잘못된 예외를 던지기도 한다.  
  달리 말하면 계산 중 잘못된 매개변수 값을 사용해 발생한 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다는 뜻이다.  
  이런 경우에는 예외 번역(exception translate) 관용구를 사용해 API 문서에 기재된 예외로 번역해줘야 한다.

- 이번 아이템을 _"매개변수에 제약을 두는 게 좋다."_ 라고 해석해서는 안된다. 사실은 그 반대다.  
  메소드는 최대한 범용적으로 설계해야 한다. 메소드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면  
  매개변수 제약은 적을수록 좋다. 하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 드물지 않다.

---

## 핵심 정리

- 메소드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다. 그 제약들을 문서화하고  
  메소드 코드 시작 부분에서 명시적으로 검사해야 한다. 이런 습관을 반드시 기르도록 하자. 그 노력은  
  유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상받을 것이다.

---
