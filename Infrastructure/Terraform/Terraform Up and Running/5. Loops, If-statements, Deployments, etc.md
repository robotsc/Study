# Loops, If-statements, Deployments, etc.

- Terraform은 선언적 언어이다. 1장에서 다뤘던 것처럼 선언적으로 구성된 IaC는 절차적 방식보다 실제로 배포된 인프라를  
  더욱 쉽게 파악할 수 있게 해준다. 하지만 특정 작업들은 절차적 방식보다 복잡하게 해야 한다.

- 예를 들어, 보통의 선언적 언어들은 for-loop을 지원하지 않기 때문에 코드 조각을 반복하는 경우가 생길 때 적절한 방법을  
  찾아야 한다. If-statement도 마찬가지이며, 다운타임이 없는 배포 등을 선언적 언어로 표현하기란 까다롭다.

- 다행이도 Terraform은 일부 primitive들을 지원하는데, `count`라는 meta-parameter, `for_each`와 `for`문,  
  ternary operator, `create_before_destroy`라는 lifecycle block, 그리고 수많은 함수들이 있다.

## Loops

- Terraform은 looping을 위해 다양한 방법을 지원하는데, 각각은 적절한 쓰임새가 있다.

  - `count` parameter: 리소스와 모듈을 순회하기 위함
  - `for_each` expression: 리소스, 리소스 내의 inline block, 그리고 모듈을 순회하기 위함
  - `for` expression: list, map을 순회하기 위함
  - `for` string directive: 문자열 내에 존재하는 list, map을 순회하기 위함

### Loops with the count parameter

- Terraform을 처음 구성할 때는 Terraform이 리소스를 만들어내기 위한 IAM user를 콘솔을 통해 발급받을 수 있다.  
  그리고 그 후 부터는 해당 IAM user를 통해 추가적인 IAM user들을 Terraform으로 생성하고, 관리할 수 있다.

- 아래의 Terraform 코드를 보자.

```tf
# live/global/iam/main.tf

provider "aws" {
  region = "us-east-2"
}

resource "aws_iam_user" "example" {
  name = "neo"
}
```

- 위 코드는 `aws_iam_user` 리소스를 사용해 하나의 IAM user를 생성해낸다.  
  만약 3명의 IAM user를 생성해야 한다면 어떻게 해야할까?  
  GPL을 사용하면 for-loop를 활용할 수 있을 것이다.

- 하지만 Terraform은 for-loop을 지원하지 않는다. 대신, 모든 Terraform 리소스는 `count`라는 meta-parameter를  
  가질 수 있다. `count`는 Terraform의 가장 오래되고, 단순하고, 가장 한정적인 순회 메커니즘을 제공하는데,  
  단지 해당 리소스의 복사본을 몇 개 만들지를 지정하는 것에 불과하다.  
  이를 사용해 3명의 IAM user를 생성하는 코드는 아래와 같다.

```tf
resource "aws_iam_user" "example" {
  count = 3
  name  = "neo"
}
```

- 위 코드의 한 가지 문제점은 세 명의 IAM user들이 모두 동일한 이름을 가지게 된다는 것이고, 이는 IAM username이 unique해야  
  한다는 AWS의 규칙을 위반하게 된다. 이를 해결하기 위해 아래처럼 `count.index`를 사용해 loop 내의 각 순회 단계를 가져올 수 있다.

```tf
resource "aws_iam_user" "example" {
  count = 3
  name  = "neo-${count.index}"
}
```

- 위 코드를 apply하면 `neo-0`, `neo-1`, `neo-2`라는 세 개의 IAM user가 생성된다.

- 물론 `neo-0`과 같은 사용자 이름은 의미가 없고, 실용성도 떨어진다.  
  만약 `count.index`를 Terraform이 제공하는 built-in function들과 결합하면 loop 내의 각 순회를 더욱 유용하게 사용할 수 있다.

```tf
variable "user_names" {
  description = "Create IAM users with these names"
  type        = list(string)
  default     = ["neo", "trinity", "morpheus"]
}
```

- 위 변수를 선언하고, loop가 돌면서 list 내의 각 순회 번호에 맞는 원소를 가져오도록 할 수 있다.  
  아래의 내용들을 사용해야 한다.

  - _Array lookup syntax_ : Terraform에서 배열 내의 원소들을 찾아내는 방법은 일반적인 프로그래밍 언어 문법과 비슷하다.

    - `ARRAY[<INDEX>]`

    - 예를 들어, `var.user_names`의 1번 index 원소를 찾는 코드는 `var.user_names[1]`이다.

  - `length()` _function_ : Terraform은 아래의 형식을 따르는 `length()`라는 built-in function이 있다.

    - `length(<ARRAY>)`

    - 알 수 있듯이 `length()` 함수는 주어진 `ARRAY`의 원소 개수를 반환한다. 문자열 및 map에도 사용할 수 있다.

- 위의 두 가지를 활용해 작성된 코드는 아래와 같다.

```tf
resource "aws_iam_user" "example" {
  count = length(var.user_names)
  name  = var.user_names[count.index]
}
```

- 이제 neo, trinity, 그리고 morpheus라는 이름을 가진 3명의 IAM user가 생성된다.

- 한 가지 유의할 점은 리소스 내부에 `count`를 사용하면, 해당 리소스는 단일 리소스가 아닌 리소스들의 배열이 된다.  
  따라서 만약 참조하려면 아래와 같이 사용해야 한다.

```tf
output "first_arn" {
  value       = aws_iam_user.example[0].arn
  description = "The ARN for the first user"
}
```

- 만약 모든 IAM user들의 ARN을 원한다면, index를 지정하는 대신 `*`(splat expression)을 사용할 수 있다.

```tf
output "all_arns" {
  value       = aws_iam_user.example[*].arn
  description = "The ARNs for all users"
}
```

- Terraform 0.13부터는 module에도 `count`를 사용할 수 있다.  
  예를 들어, `modules/landing-zone/iam-user/main.tf`에 아래와 같이 하나의 IAM user를 생성하는 코드가 있다고 하자.

```tf

provider "aws" {
  region = "us-east-2"
}

resource "aws_iam_user" "example" {
  name = var.user_name
}
```

- 이 모듈을 사용하는 쪽에서 username을 input variable로 전달한다.

```tf
variable "user_name" {
  description = "The username to use"
  type        = string
}
```

- 그리고 module은 생성된 IAM user의 ARN을 output variable로 내보낸다.

```tf
output "user_arn" {
  value       = aws_iam_user.example.arn
  description = "The ARN of the created IAM user"
}
```

- 이제 위 코드를 module로 불러와 아래처럼 3명의 IAM user들을 생성하도록 할 수 있다.

```tf
provider "aws" {
  region = "us-east-2"
}

variable "user_names" {
  description = "Create IAM users with these names"
  type        = list(string)
  default     = ["neo", "trinity", "morpheus"]
}

module "users" {
  source = "../../../../modules/landing-zone/iam-user"

  count     = length(var.user_names)
  user_name = var.user_names[count.index]
}

output "all_arns" {
  value       = aws_iam_user.example[*].arn
  description = "The ARNs for all users"
}
```

- 하지만 `count`는 사용성을 급격히 떨어뜨리는 두 가지의 한계점이 존재한다.  
  첫째로, 전체 리소스를 순쇠하기 위해 `count`를 사용할 수 있음에도 리소스 내의 inline block을 순회하기 위해서는 사용할 수 없다.

- 예를 들어, 아래의 `aws_autoscaling_group` 리소스에 tag가 어떻게 지정되는지 보자.

```tf
resource "aws_autoscaling_group" "example" {
  launch_configuration = aws_launch_configuration.example.name
  vpc_zone_identifier  = data.aws_subnets.default.ids
  target_group_arns    = [aws_lb_target_group.asg.arn]
  health_check_type    = "ELB"

  min_size = var.min_size
  max_size = var.max_size

  tag {
    key                 = "Name"
    value               = var.cluster_name
    propagate_at_launch = true
  }
}
```

- `tag`는 `key`, `value`, `propagate_at_launch`를 위한 값들을 가진 inline block을 사용해야 한다.  
  위의 코드는 하나의 태그만을 하드코딩하지만, 사용자들이 custom tag를 넣을 수 있게 하고 싶다면 어떻게 해야할까?  
  `count` parameter를 사용해 tag를 순회하고 동적으로 inline `tag` block을 만들어내고 싶다는 생각을 할 것이다.  
  하지만 inline block에 대해서는 `count`를 사용할 수 없다.

- `count`의 두 번째 한계점으로는 값을 바꾸려고 할 때 등장한다.  
  이전에 생성한 IAM user들을 보자.

```tf
variable "user_names" {
  description = "Create IAM users with these names"
  type        = list(string)
  default     = ["neo", "trinity", "morpheus"]
}
```

- 여기서 `trinity`를 제거하고 `plan`을 수행하면 어떻게 될까?  
  우리가 기대하는 것은 trinity만 삭제되는 것이지만, 실제 결과는 trinity의 이름을 morpheus로 바꾸고, morpheus를 제거하는 것이다.  
  이렇게 되는 이유는 리소스에 대해 `count`를 사용하게 되면 해당 리소스가 리소스들의 배열이 되어버리기 때문이다.  
  불행히도 Terraform은 배열 내의 리소스를 index를 사용해 식별한다. 즉, 3명의 IAM user를 생성했을 때 Terraform은 내부적으로  
  아래 정보를 저장한다.

  ```
  aws_iam_user.example[0] = neo
  aws_iam_user.example[1] = trinity
  aws_iam_user.example[2] = morpheus
  ```

- 그리고 trinity를 제거하는 순간, 아래처럼 바뀐다.

  ```
  aws_iam_user.example[0] = neo
  aws_iam_user.example[1] = morpheus
  ```

- morpheus가 2번에서 1번으로 index가 바뀌었기 때문에, Terraform은 trinity가 morpheus로 바뀌었다고 인식하게 된다.  
  그래서 위와 같은 `plan` 결과가 나왔던 것이다.

- 위의 두 가지 한계점을 극복하기 위해서, Terraform 0.12에 `for_each` 표현식이 등장했다.

---

### Loops with `for_each` expressions

- `for_each` 표현식은 list, set, map을 순회해 아래 내용을 수행할 수 있다.

  - 전체 리소스의 복사본 생성
  - 리소스 내의 inline block의 복사본 생성
  - 모듈의 복사본 생성

- 처음으로 `for_each`를 사용해 전체 리소스의 복사본을 생성하는 방법을 보자. 문법은 아래와 같다.

```tf
resource "<PROVIDER>_<TYPE>" "<NAME>" {
  for_each = <COLLECTION>

  [CONFIG...]
}
```

- `COLLECTION`: 순회할 set 혹은 map
- `CONFIG`: 해당 리소스가 사용하는 하나 이상의 파라미터

- `CONFIG` 내에서는 `each.key`와 `each.value`를 사용해 `COLLECTION`을 순회할 때의 현재 원소의 key, value를 사용할 수 있다.

- 아래는 `for_each`를 리소스에 적용해 3명의 IAM user를 만드는 코드이다.

```tf
resource "aws_iam_user" "example" {
  for_each = toset(var.user_names)
  name     = each.value
}
```

- 위에서 `toset()`은 `var.user_names` list를 set으로 변경해주기 위해 사용했는데, 이는 `for_each`가 set 혹은 map에 대해서만  
  사용 가능하기 때문이다. Map을 순회할 때 `each.key`는 원소의 key, `each.value`는 원소의 value를 나타내고, set을 순회할 때는  
  `each.key`와 `each.value`가 동일하게 원소의 value를 나타낸다.

- `for_each`를 리소스에 사용하는 순간, 해당 리소스는 리소스들로 이뤄진 map이 된다.  
  이를 확인하기 위해 기존에 있던 `all_users` output variable을 아래처럼 수정해보자.

```tf
output "all_users" {
  value = aws_iam_user.example
}
```

- `terraform apply`를 수행하면 output에 3명의 IAM user가 나타난다.  
  key는 각 IAM user의 name이고, value는 해당 IAM user의 정보이다.

- 이전에 있던 `all_arns` output variable은 아래와 같이 `values()` built-in function과 splat expression을  
  함께 사용해 구할 수 있다.

```tf
output "all_arns" {
  value = values(aws_iam_user.example)[*].arn
}
```

- 이렇게 `count`를 사용할 때 리소스가 배열이 되었던 것과 달리, `for_each`를 사용할 때 리소스가 map이 되는 것은 큰 이점을  
  가져다준다. Collection의 중간에 있는 원소(리소스)를 안전하게 제거할 수 있기 때문이다. 이전과 마찬가지로 trinity를 제거하고  
  `plan`을 수행하면, 우리가 원하는대로 trinity user만 제거될 것임을 확인할 수 있다.

- `for_each`는 모듈에 대해서도 사용할 수 있다. 이전에 만들었던 `iam-user` module에 대해서 아래처럼 `for_each`를  
  사용해 3명의 IAM user를 만들 수 있다.

```tf
module "users" {
  source = "../../../../modules/landing-zone/iam-user"

  for_each  = toset(var.user_names)
  user_name = each.value
}

output "all_arns" {
  value       = values(module.users)[*].user_arn
  description = "The ARNs for all users"
}
```

- 이제 `for_each`의 또다른 장점 중 하나인 리소스 내에 여러 개의 inline block을 만들 수 있는 장점에 대해 살펴보자.  
  예를 들어, `for_each`를 사용해 `webserver-cluster` module내의 ASG에 `tag` inline block들을 동적으로  
  만들어낼 수 있다. 우선 아래처럼 사용자들의 custom tag를 정의하도록 하기 위해 `custom_tags`라는 새로운 map 타입의  
  input variable을 선언해보자.

```tf
# modules/services/webserver-cluster/variables.tf
variable "custom_tags" {
  description = "Custom tags to set onthe Instances in the ASG"
  type        = map(string)
  default     = {}
}
```

- 그리고 아래처럼 module을 사용하는 쪽에 `custom_tags`를 정의해보자.

```tf
module "webserver_cluster" {
  source = "../../../modules/services/webserver-cluster"

  cluster_name           = "webservers-prod"
  db_remote_state_bucket = "terraform-up-and-running-state-roy-ra"
  db_remote_state_key    = "prod/data-stores/mysql/terraform.tfstate"

  instance_type = "t3.medium"
  min_size      = 2
  max_size      = 10

  custom_tags = {
    Owner     = "team-foo"
    ManagedBy = "terraform"
  }
}
```

- 위 코드는 2개의 tag를 지정하는데, 하나는 해당 ASG의 소유자가 누구인지이고, 다른 하나는 리소스 관리 주체를 표현한다.

- 이제 custom tag들을 받아왔는데, 실제로 이를 적용하는 방법은 어떻게 될까?  
  여기서 필요한 것은 `var.custom_tags`를 순회할 수 있는 for-loop이다. 이를 위해 `for_each` 표현식을 사용할 수 있다.  
  `for_each` 표현식을 사용해 동적으로 inline block을 만들어내는 문법은 아래와 같다.

  ```tf
  dynamic "<VAR_NAME>" {
    for_each = <COLLECTION>

    content {
      [CONFIG...]
    }
  }
  ```

  - `VAR_NAME`: 순회할 때마다의 값을 담는 변수 이름
  - `COLLECTION`: 순회할 list 또는 map
  - `content`: 각 순회에서 만들어낼 inline block, `content` 내에서는 `<VAR_NAME>.key`와 `<VAR_NAME>.value`를 사용해  
    `COLLECTION`을 순회할 때의 현재 원소의 key, value를 사용할 수 있다. 한 가지 유의할 점은 list에 대해 `for_each`를  
    사용할 때 `key`는 index 번호, `value`는 실제 원소의 값이다.

- 이를 모두 종합해 아래처럼 `for_each`를 사용해 `tag` inline block을 동적으로 만들어낼 수 있다.

```tf
resource "aws_autoscaling_group" "example" {
  launch_configuration = aws_launch_configuration.example.name
  vpc_zone_identifier  = data.aws_subnets.default.ids
  target_group_arns    = [aws_lb_target_group.asg.arn]
  health_check_type    = "ELB"

  min_size = var.min_size
  max_size = var.max_size

  tag {
    key                 = "Name"
    value               = var.cluster_name
    propagate_at_launch = true
  }

  dynamic "tag" {
    for_each = var.custom_tags

    content {
      key                 = tag.key
      value               = tag.value
      propagate_at_launch = true
    }
  }
}
```

#### Enforcing Tagging Standards

- 하나의 Terraform module이 정의하는 모든 리소스가 같은 tag를 가지도록 강제하는 방법 중 하나로 `default_tags`를 사용할 수 있다.

```tf
provider "aws" {
  region = "us-east-2"

  default_tags {
    tags = {
      Owner     = "team-foo"
      ManagedBy = "terraform"
    }
  }
}
```

---

### Loops with `for` expressions

- 지금까지 loop를 활용해 리소스를 여러 개 만들고, inline block을 동적으로 만들어내는 방법을 보았다.  
  그렇다면 단 하나의 variable 혹은 parameter를 순회하고자 할 땐 어떻게 해야 할까?

- 아래와 같은 list 변수가 있다고 해보자.

```tf
variable "names" {
  description = "Create IAM users with these names"
  type        = list(string)
  default     = ["neo", "trinity", "morpheus"]
}
```

- name의 원소들을 모두 대문자로 변환하고 싶다면 어떻게 해야할까? Python같은 GPL은 아래처러 for loop를 사용할 수 있다.

```py
names = ["neo", "trinity", "morpheus"]

upper_case_names = []
for name in names:
    upper_case_names.append(name.upper())

print(upper_case_names)

upper_case_names_2 = [name.upper() for name in names]
print(upper_case_names_2)

upper_case_name3 = [name.upper() for name in names if len(name) < 5]
print(upper_case_name3)
```

- Terraform은 위와 유사한 기능을 _for_ 표현식으로 제공한다. 기본 문법은 아래와 같다.

```tf
[for <ITEM> in <LIST> : <OUTPUT>]
```

- `LIST`: 순회할 list
- `ITEM`: `LIST`내의 각 원소를 할당할 지역 변수명
- `OUTPUT`: `ITEM`을 특정 방식으로 변환하는 표현식

- 예를 들어, list 내 각 원소들을 대문자로 변환하는 코드는 아래와 같다.

```tf
output "upper_names" {
  value = [for name in var.names : upper(name)]
}

output "upper_names_2" {
  value = [for name in var.names : upper(name) if length(name) < 5]
}
```

- `for` 표현식으로 map을 순회하는 기본 문법은 아래와 같다.

```tf
[for <KEY>, <VALUE> in <MAP> : <OUTPUT>]
```

- 아래의 `hero_thousand_faces` 라는 map 변수가 있다고 해보자.

```tf
variable "hero_thousand_faces" {
  description = "map"
  type        = map(string)
  default = {
    neo      = "hero"
    trinity  = "love interest"
    morpheus = "mentor"
  }
}

output "bios" {
  value = [for name, role in var.hero_thousand_faces : "${name} is a ${role}"]
}
```

- 위 코드에 대해 `apply`를 수행하면, 아래의 출력 결과가 나온다.

```
bios = [
  "morpehus is a mentor",
  "neo is a hero",
  "trinity is a love interest",
]
```

- 아래처럼 `for` 표현식으로 list 대신 map을 반환하도록 할 수 있다.

```tf
# Loop over a list and output a map
{for <ITEM> in <LIST>: <OUTPUT_KEY> => <OUTPUT_VALUE>}

# Loop over a map and output a map
{for <KEY>, <VALUE> in <MAP>: <OUTPUT_KEY> => <OUTPUT_VALUE>}
```

- 유일한 차이점은 표현식을 `[]` 대신 `{}`로 감싼다는 것이고, 각 순회마다 하나의 값을 반환하지 않고 key, value를 함께  
  반환한다는 것이다. 아래는 map을 순회해 key, value를 모두 대문자로 변환하는 코드이다.

```tf
output "upper_roles" {
  value = {for name, role in var.hero_thousand_faces : upper(names) => upper(role)}
}
```

- 결과는 아래와 같다.

```tf
upper_roles = {
  "MORPHEUS" = "MENTOR"
  "NEO" = "HERO"
  "TRINITY" = "LOVE INTEREST"
}
```

### Loops with the `for` string directive

- 이 책의 앞부분에서 string interpolation, 즉 아래처럼 문자열 내에서 Terraform 코드를 참조하는 방식을 보았다.

```tf
"Hello, ${var.name}"
```

- _String directive_ 는 for-loop 와 if문 등의 기능을 문자열 내에서 string interpolation과 비슷한 문법으로 사용하도록 해준다.  
  String interpolation은 `${}`의 형식을 가졌다면, string directive는 `%{}`의 형식을 가진다.

- Terraform은 두 가지 종류의 string directive를 지원하는데, 하나는 for-loop이고 다른 하나는 조건문이다.  
  여기서는 for-loop만 보고, 조건문은 이 장의 마지막 부분에서 다시 볼 것이다.

- `for` string directive는 아래의 형식을 따른다.

```tf
%{for <ITEM> in <COLLECTION> }<BODY>%{endfor}
```

- `COLLECTION`: 순회할 list 혹은 map
- `ITEM`: `COLLECTION`을 순회할 때마다의 원소를 할당할 지역 변수명
- `BODY`: 각 순회마다 출력할 내용

```tf
variable "names" {
  description = "Create IAM users with these names"
  type        = list(string)
  default     = ["neo", "trinity", "morpheus"]
}

output "for_directive" {
  value = "%{for name in var.names}${name}, %{endfor}"
}
```

- `apply` 결과는 아래와 같다.

```
for_directive = "neo, trinity, morpheus, "
```

- `for` string directive에서는 for-loop의 index 번호를 가져와 사용할 수도 있다.

```tf
output "for_directive_index" {
  value = %{for i, name in var.names }(${i}) ${name}, %{endfor}
}
```

- `apply` 결과는 아래와 같다.

```
for_directive_index = "(0) neo, (1) trinity, (2) morpheus, "
```

- 위 두 예제 모두 마지막에 `,`가 있음을 보자. 이는 다음에 살펴볼 조건문, 특히 `if` string directive로 고칠 수 있다.

---
