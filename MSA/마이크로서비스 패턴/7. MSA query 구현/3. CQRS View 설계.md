# CQRS View 설계

- CQRS view 모듈에는 하나 이상의 query 작업으로 구성된 API가 있다. 이 API들은 다른 서비스들이 발행한 이벤트를 구독해 최신 상태로  
  유지된 DB를 조회하는 query API이다. View 모듈은 view DB와 세 개의 하위 모듈로 구성된다.

![picture 12](/images/MSAP_7_10.png)

- 이벤트 핸들러, query API 모듈은 데이터 접근 모듈을 통해 DB를 조회, 수정한다. 이벤트 핸들러 모듈은 이벤트를 구독해 DB를 수정하고  
  query API 모듈은 데이터를 조회한다.

- View 모듈을 개발할 때는 몇 가지 중요한 설계 결정을 해야 한다.

  - DB 선정 및 스키마 설계
  - 데이터 접근 모듈을 설계할 때 멱등성, 동시성 업데이트 등의 다양한 문제 고려
  - 기존 애플리케이션에 새로운 view를 구현하거나 기존 스키마를 바꾸는 경우, view를 효율적으로 빌드할 수 있는 수단 강구
  - View 클라이언트에서 복제 시차 처리 방안에 대한 모색

## DB 선정 및 스키마 설계

- DB는 신중하게 결정해야 하며 스키마도 잘 설계해야 한다. DB와 데이터 모델의 주 목적은 view 모듈의 query 작업을 효율적으로 구현하는 것이다.  
  DB를 선택할 때 이런 query 작업의 특성이 주된 검토 항목이지만, DB 역시 이벤트 핸들러가 수행하는 업데이트 작업을 효율적으로 지원할 수 있어야 한다.

### SQL vs NoSQL database

- 최근 NoSQL DB의 사용성이 급증하고 있다. NoSQL DB는 대부분 transaction 기능이 제한적이고 범용적인 질의 능력은 없지만, 특정 use case에서는  
  유연한 데이터 모델, 우수한 성능과 확정성 등 SQL 기반의 RDBMS보다 더 낫다.

- NoSQL DB는 CQRS view와 잘 맞는 편이다. NoSQL DB의 풍성한 데이터 모델과 우수한 성능이 CQRS view에 유리하기 때문이다. 또한 CQRS  
  view는 단순 transaction만 사용하고 고정된 query만 실행하므로 NoSQL DB의 제약 사항도 거의 영향을 받지 않는다.

- 물론 SQL DB를 사용해 CQRS view를 구현하는 것이 타당한 경우도 있다.

- 아래 표는 SQL, NoSQL DB 중 어느 것을 사용할지를 고민할 때 참고할 정도의 사항들을 나타낸다.

| ~가 필요하면                | ~를 사용한다                                              |
| --------------------------- | --------------------------------------------------------- |
| JSON 객체를 PK로 검색       | Document store(MongoDB, DynamoDB), key-value store(redis) |
| Query 기반의 JSON 객체 검색 | Document store                                            |
| 텍스트 query                | 텍스트 검색 엔진(ElasticSearch, Solr)                     |
| 그래프 query                | Graph DB(Neo4j)                                           |
| 전통적인 SQL 리포팅/BI      | RDBMS                                                     |

### 업데이트 작업 지원

- View 데이터 모델에서는 query 뿐만 아니라 이벤트 핸들러가 실행하는 업데이트 작업 역시 효율적으로 구현되어야 한다. 이벤트 핸들러는 대부분  
  view DB에 있는 레코드를 PK로 찾아 수정/삭제할 것이다.

- 하지만 FK를 이용해 레코드를 수정/삭제해야 하는 경우도 있다. 일부 DB 자료형은 FK 기반의 업데이트 작업을 효율적으로 지원한다.  
  가령 RDBMS나 MongoDB를 사용 중이라면 필요한 column의 index를 생성하면 되지만, 다른 NoSQL DB에서는 PK가 아닌 key를 기반으로  
  업데이트를 수행하기가 결코 쉽지 않다. 애플리케이션이 업데이트할 레코드를 결정하려면 FK에서 PK로 mapping 가능한 데이터를 DB에 갖고 있어야 한다.  
  예를 들어 PK 기반의 수정, 삭제만 지원하는 DynamoDB를 사용 중이라면 먼저 DynamoDB의 secondary index를 사용해 query를 수행한 후  
  수정, 삭제할 항목의 PK를 결정해야 한다.

## 데이터 접근 모듈 설계
