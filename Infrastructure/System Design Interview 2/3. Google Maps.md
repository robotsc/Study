# Google Maps

- 이번에는 Google Maps의 간단한 버전을 설계해보자. Google Map은 2005년에 Google에 시작된 프로젝트로, web mapping service이다.  
  인공위성 사진, 거리 지도, 실시간 교통량, 경로 탐색 등 많은 기능을 제공한다.

- Google Maps는 사용자가 도착지까지 갈 수 있는 경로를 탐색하는 데 도움을 준다. 2021년 3월부로 Google Maps의 DAU는 10억명이고,  
  전 세계의 99%를 다루며 하루에 정확하고 실시간 위치 정보 제공을 위해 대략 2500만 건의 정보 갱신을 수행한다.

## 문제 이해 및 설계 범위 확정

- 이번에 설계할 시스템의 요구사항은 아래와 같다.

  - DAU는 10억명이다.
  - 위치 갱신, 내비게이션, ETA, 지도 렌더링 기능에 집중한다.
  - 도로 정보의 raw data는 TB 단위이다.
  - 정확한 ETA 계산을 위해 교통량 정보가 필요하다.
  - 도보, 차량, 대중교통 이동 등 다양한 이동수단으로 경로 탐색을 지원해야 한다.
  - 도착지가 여러 곳인 경우는 고려하지 않는다.
  - 특정 장소에 대한 사진 등의 추가 정보는 고려하지 않는다.

- 추가적으로 아래의 요구사항 및 제약사항들이 있다.

  - Accuracy: 사용자에게 잘못된 경로를 제공하면 안된다.
  - 부드러운 내비게이션: 클라이언트단에서 사용자에게 _부드럽게_ 지도가 렌더링되어야 한다.
  - 데이터, 배터리 사용: 클라이언트는 최소한의 데이터와 배터리를 사용해야 한다. 특히 모바일 기기에서 이는 매우 중요하다.
  - 일반적인 availability, scalability 요구사항들

- 설계에 들어가기 전에 Google Maps의 설계에 도움이 될만한 몇 가지 기본 개념과 기술들을 알아보자.

### Positioning System

- 전세계는 하나의 축을 기준으로 자전하는 구이다. 최상위에는 북극이 있고, 최하위에는 남극이 있다.

  ![picture 1](/images/SDI2_GM_1.png)

  - Latitude(위도): 얼마나 북쪽, 남쪽에 있는지를 나타낸다.
  - Longitude(경도): 얼마나 서쪽, 동쪽에 있는지를 나타낸다.

### 3D에서 2D로

- 3D의 구를 2D로 변환하는 작업을 "Map Projection"이라 한다.

- Map projection을 하는 방법은 여러 가지가 있으며 각각의 방법은 장단점이 있다. 거의 대부분의 방식들은 실제 지리 정보를 왜곡한다.  
  아래는 일부 예시들이다.

  ![picture 2](/images/SDI2_GM_2.png)

### Geocoding

- Geocoding은 주소를 지리적인 위치(위도, 경도)로 변환하는 것을 말한다. 반대로 위도, 경도의 쌍을 사람이 읽기 쉬운 주소로 변환하는 작업을 reverse  
  geocoding이라 한다. Geocoding을 하는 하나의 방법은 interpolation이다. 이 방식은 GIS(Geographic Information Systems) 등으로부터  
  데이터를 가져와 주소를 위도, 경도 공간으로 매핑한다.

### Geohashing

- Geohashing은 인코딩 시스템으로 지리적 영역을 숫자와 문자로 이뤄진 작은 문자열로 인코딩한다. 지구를 납작한 평면으로 펼치고, 재귀적으로 grid를  
  sub-grid로 계속 나눠가며, grid는 정사각형 또는 직사각형 모양이다.예를 들어 아래 그림은 각 grid를 재귀적으로 만들어지는 0과 3 사이의 숫자로 나타낸다.

  ![picture 3](/images/SDI2_GM_3.png)

- 처음 펼쳐진 표면의 크기가 `20000km * 20000km`이라 해보자. 첫 번째 분할 이후에는 `10000km * 5000km`짜리의 4개 grid가 생길 것이다.  
  이를 각각 `00`, `01`, `10`, `11`으로 위에서 표현했다. 동일한 네이밍 전략을 사용해 각 grid를 또다시 4개의 grid로 나눈다. 이렇게 되면  
  각 grid의 크기는 `5000km * 2500km`이 된다. 이렇게 특정 조건을 만족할 때까지 grid를 계속해서 분할해 나간다.

### Map Rendering

- 지금 지도의 렌더링 관련해 깊게 다루지는 않을 것이지만, 그래도 기본은 알고 있는게 좋다. Map rendering의 가장 기본적인 접근법은 tiling이다.  
  즉 하나의 거대한 이미지로 지도를 렌더링하는 것이 아니라, 전 세계를 작은 tile(조각)들로 쪼개고, 클라이언트는 오직 자신에게 필요한 tile에 대한  
  정보만 가져와 렌더링하게 된다.

- 얼마나 사용자가 zoom을 했느냐에 따라 각각 다른 tile의 집합이 사용된다. 이렇게 지도를 확대한 수준에 따라 tile을 다르게 하면, 확대한 수준에 따라  
  적절히 필요한 정보만을 보여주게 되므로 network bandwidth도 적게 소모하게 된다. 조금 극단적인 예시를 들어보자. 만약 사용자가 모든 세계가 보일  
  정도로 zoom out을 했다면, 높은 zoom level에 대한 모든 tile 전혀 필요 없다. 이를 받더라도, 상세 정보는 결국 보여주지 않을 것이기 때문에  
  쓸모없어진다. 대신 클라이언트는 가장 낮은 zoom level에서 전세계를 `256 * 256` 픽셀 사진으로 보여주는 하나의 tile을 받아 렌더링할 것이다.

### 내비게이션 알고리즘을 위한 교통 데이터 처리

- 대부분의 길찾기 알고리즘은 Dijkstra 또는 A\* 길찾기 알고리즘의 변형이다. 정확히 어떤 알고리즘이 사용되는지는 복잡한 주제이고, 이 장에서  
  깊게 다루지도 않을 것이다. 중요한 것은 이 알고리즘들이 모두 그래프 자료구조에서 수행된다는 것이다. 그래프에서 모든 교차로는 node가 되고,  
  도로는 그래프의 edge가 된다. 아래 그림을 보자.

  ![picture 4](/images/SDI2_GM_4.png)

- 이러한 대부분의 알고리즘의 성능은 그래프의 크기에 의해 많이 좌지우지된다. 예를 들어 전세계에 있는 도로들을 하나의 그래프에 표현하면  
  매우 많은 메모리를 차지할 것이고, 이들 알고리즘들이 효율적으로 수행되기 어려울 것이다. 따라서 지금 설계하려는 규모의 애플리케이션에서 알고리즘이  
  효율적으로 수행하도록 하기 위해서는 각 그래프를 manageable한 단위로 분할해야 한다.

- 전세계의 도로들을 작은 그래프로 분할하는 방법들 중 하나의 방법은 이전에 Map Rendering 때 봤던 것처럼 tile을 이용하는 것이다. Geohashing과  
  비슷한 분해 전략을 사용해 세계를 작은 grid로 분할해보자. 각 grid 내에서는 해당 grid 내의 도로들을 작은 그래프 자료구조로 표현하게 된다.  
  (교차로: node, 도로: edge) 이 grid를 **routing tile**이라 한다. 각 routing tile은 해당 tile이 연결할 수 있는 인접한 다른 tile에 대한  
  참조를 갖고 있는다. 이 참조를 사용해 도로의 그래프가 더욱 큰 범위에 대해 경로 탐색을 수행할 수 있게 되는 것이다.

- 이렇게 도로망을 필요할 때마다 각각 로딩될 수 있는 작은 routing tile로 분리함으로써 알고리즘이 한 번에 작은 routing tile 집합에 대해서만  
  수행되도록 하고, 결과적으로 메모리 사용량을 줄이고 성능을 높일 수 있다.

  ![picture 5](/images/SDI2_GM_5.png)

> 위 그림에서 grid를 _routing tile_ 이라 했다. Routing tile은 map tile과 둘 다 특정 지리적 영역을 나타내는 grid라는 점에서 동일하다.  
> 하지만 map tile은 PNG 사진인 반면, routing tile은 해당 grid 내의 도로 정보를 가진 binary file이다.

### 계층적 routing tile(Hierarchical routing tiles)

- 효율적인 내비게이션을 위해서는 적당한 정도의 상세 정보를 가지도록 도로 데이터를 구성해야 한다. 예를 들어, 두 개의 다른 나라를 이어야 하는 경우  
  street-level routing tile처럼 매우 상세한 level의 routing tile에 대해 경로 찾기 알고리즘을 수행하는 것은 시간이 오래 걸릴 것이다.  
  이렇게 detail한 routing tile들이 붙어있는 그래프는 크기가 크고, 메모리도 많이 사용할 것이다.

- 일반적으로 routing tile은 detail한 level이 총 3가지로 나뉜다. 가장 detail한 level에서 routing tile은 매우 작고 오직 지방 도로를 포함한다.  
  그 다음 단계의 tile은 더 커지고, 서로 다른 구역을 연결하는 간선 도로에 대한 정보를 갖는다. 마지막 단계에서 tile은 넓은 영역을 포함하고 오직 다른 도시를  
  잇는 고속도로에 대한 정보만 갖는다. 각 level에서는 다른 zoom level을 위해 인접한 tile을 참조하는 edge가 있을 수 있다.  
  예를 들어 일반 도로 `A`에서 고속도로 `F`를 표현하고 싶다면 `A`를 포함하는 작은 tile내의 node에서 `F`를 포함하는 big tile의 node로의 참조를  
  갖고 있을 것이다. 아래 그림처럼 routing tile은 다양한 크기를 가질 수 있다.

  ![picture 6](images/SDI2_GM_6.png)

- 다시 요구사항 파악으로 돌아가, 위의 요구사항들에 기반해 필요한 정보들을 수치화해보자.  
  수치화 전에 아래의 변환을 알아두자.

  - 1 foot = 0.3048 meters
  - 1 km = 0.6214 miles
  - 1 km = 1000m

### Storage usage

- 우리는 이 시스템을 위해 3가지의 데이터를 저장해야 한다.

  - Map of the world: 상세한 계산 결과는 아래에 있다.
  - Metadata: 각 map tile에 대한 metadata의 크기가 매우 적다고 했으니, metadata는 고려하지 않아도 된다.
  - Road Info: 이전에 요구사항에서 외부로부터 제공되는 도로 데이터가 TB 단위라고 했다. 우리는 이 dataset을 routing tile들로 변환하는데, 따라서  
    routing tile들의 데이터도 TB 단위가 될 것이다.

#### Map of the world

- 이전에 Map Tiling의 주요 개념을 살펴보았다. 각 zoom level에 따라 많은 map tile의 집합들이 존재한다. Map tile image들이 얼마나 많은 저장  
  공간을 차지하는지 알아보기 위해 우선 가장 높은 zoom level에서 필요한 저장 공간을 계산해보자. Zoom level 21에서는 대략 4조 4000만개의 tile들이  
  있으며, 각 tile은 `256 * 256` 크기의 압축된 PNG 이미지이고, 각 이미지의 크기는 100KB 정도 한다고 해보자. 그러면 가장 zoom level이 높은  
  경우에는 대략 `4조 4000만 * 100KB = 440PB`의 저장 공간이 필요하다.

- 아래 테이블은 zoom level에 따른 map tile의 개수를 보여준다.

| Zoom Level | Number of Tiles   |
| ---------- | ----------------- |
| 0          | 1                 |
| 1          | 4                 |
| 2          | 16                |
| 3          | 64                |
| 4          | 256               |
| 5          | 1,024             |
| 6          | 4,096             |
| 7          | 16,384            |
| 8          | 65,536            |
| 9          | 262,144           |
| 10         | 1,048,576         |
| 11         | 4,194,304         |
| 12         | 16,777,216        |
| 13         | 67,108,864        |
| 14         | 268,435,456       |
| 15         | 1,073,741,824     |
| 16         | 4,294,967,296     |
| 17         | 17,179,869,184    |
| 18         | 68,719,476,736    |
| 19         | 274,877,906,944   |
| 20         | 1,099,511,627,776 |
| 21         | 4,398,046,511,104 |

- 하지만 전 세계 표면의 90%는 바다, 사막, 호수 등 사람이 없는 지역임을 생각해야 한다. 이 지역들은 사진의 압축도를 매우 높일 수 있으므로 이를 고려하면  
  대략 필요한 저장 공간의 80% ~ 90%를 줄일 수 있을 것이다. 즉 기존 440PB에서 대략 44~88PB로 줄일 수 있을 것이다. 간단히 생각하기 위해 적당히  
  50PB를 선택하자.

- 다음으로는 낮은 zoom level의 map tile들이 저장 공간을 얼마나 차지할지 계산해보자. Zoom level에 하나씩 내려갈수록 남에서 북, 동에서 서 방향의  
  크기가 절반씩 줄어들 것이다. 따라서 level이 줄어들수록 필요한 tile의 개수도 4분의 1이 되고, 이는 곧 level이 줄어들면 줄어든 level이 필요한  
  용량은 줄어들기 전 level이 필요한 공간의 4분의 1이 된다는 뜻이다. 이를 수식으로 나타내 보면 아래처럼 $50+50/4+50/16+50/64+...=67PB$.  
  이 수치는 정말 대략적인 추정치이다. 이 계산에서 우리는 모든 level의 map tile을 저장하기 위해 대략 100PB의 저장 공간이 필요함을 알게 되었다.

### Server throughput

- 서버 처리량을 계산하기 위해서 서버가 지원해야 하는 요청의 종류들을 먼저 생각해보자. 크게 두 가지의 요청이 있을 것이다.  
  하나는 내비게이션 요청이다. 이는 클라이언트들이 보내는 요청으로, 네비게이션 세션을 초기화하기 위해 사용된다. 그 다음으로는 위치 정보 갱신 요청이  
  있을 것이다. 이 요청은 사용자가 네비게이션 세션 도중 움직임에 따라 클라이언트에서 사용자의 위치가 바뀌었음을 알리기 위해 사용된다.  
  이 위치 정보 데이터는 여러 개의 downstream service들에 의해 사용된다. 예를 들어 위치 정보를 사용해 실시간 교통량 데이터를 만들 수도 있을 것이다.

- 이제 내비게이션 요청을 위한 서버의 처리량을 계산해보자. DAU가 10억명 이었고, 각 사용자는 1주일에 내비게이션을 대략 35분 사용한다.  
  이를 계산하면 1주일에 내비게이션을 사용자들이 사용하는 시간이 대략 350억 분임을 알 수 있다.(== 하루에 50억 분)  
  단순한 방법으로 클라이언트가 GPS 위치 정보를 매 초마다 보낸다고 가정하면, 하루에 `50억분 * 60초 = 3000억`번의 요청이 발생함을 알 수 있다.  
  물론 클라이언트가 매 초마다 GPS 정보 갱신 요청을 보내지 않아야 할 수도 있다. 이렇게 얼마를 주기로 위치 정보 갱신 요청을 보낼지는 클라이언트단에서  
  설정할 수 있다. 예를 들어 write QPS를 줄이기 위해 15초에서 30초마다 1번씩 요청을 보내도록 할 수 있을 것이다. 물론 실제 상황에서 갱신 주기는  
  사용자가 움직이는 속도 등의 요소의 영향을 받는다. 예를 들어 교통량이 많아 막히는 상황이라면 GPS 갱신 주기를 매우 낮출 수 있을 것이다.  
  이 설계에서 우리는 GPS 갱신 요청이 15초에 한 번씩 발생할 것이라고 가정한다. 이 덕분에 QPS는 기존 300만에서 20만으로 줄어들 수 있다.

- Peak QPS를 QPS의 5배로 가정한다면 위치 정보 갱신에 대한 peak QPS는 대략 100만이 될 것이다.

---
