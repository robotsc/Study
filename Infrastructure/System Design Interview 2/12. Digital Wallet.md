# Digital Wallet

- 결제 플랫폼들은 일반적으로 클라이언트에게 돈을 저장하고 사용할 수 있도록 해주는 전자 지갑 서비스를 제공한다.  
  예를 들어 신용 카드에 연결된 전자 지갑에 돈을 저장하고, 이후 온라인으로 상품을 구매할 때 해당 전자 지갑에 있는 돈을 사용할 수 있다.  
  아래 그림은 이 프로세스를 나타낸다.

  ![picture 16](/images/SDI2_DW_1.png)

- 전자 지갑이 제공하는 기능은 돈을 사용하는 것이 전부가 아니다. PayPal과 같은 결제 플랫폼에서는 동일한 플랫폼에 있는 다른 사람의  
  전자 지갑으로 돈을 송금할 수도 있다. 은행 계좌로 송금하는 것에 비해 이 송금 방식은 더욱 빠르며 추가적인 비용(수수료)을 발생시키지 않는다.  
  아래 그림은 전자 지갑 사이의 송금 과정을 나타낸다.

  ![picture 17](/images/SDI2_DW_2.png)

- 이번 장에서는 같은 플랫폼 사이의 직접 송금이 가능한 전자 지갑 애플리케이션의 백엔드 부분을 설계해보도록 하자.

## 문제 이해 및 설계 범위 확정

- 요구사항은 아래와 같다.

  - 두 개의 전자 지갑 사이의 송금 기능에만 집중한다.
  - TPS: 1,000,000(백만)
  - 데이터를 기반으로 잔액 기록을 재생성해낼 수 있어야 한다.
  - 가용성: 99.99%
  - 안정성: 99.99%
  - 트랜잭션 지원
  - 외화 거래는 고려하지 않는다.

### 개략적 추정치 계산

- TPS를 사용할 때 일반적으로 트랜잭션을 지원하는 데이터베이스를 사용한다고 가정하게 된다. 현대의 일반적인 data center node에서  
  실행되는 RDBMS는 초당 수천개의 트랜잭션을(1000 TPS) 지원한다. 하나의 데이터베이스 node가 1000 TPS를 지원한다 해보자.  
  위 요구사항처럼 1,000,000 TPS를 지원하기 위해선 최소 이의 2배인 2,000,000 TPS까지는 지원할 수 있어야 하며, 이는 곧  
  2000개의 node들이 필요함을 의미한다.

- 아래 표는 1개의 node가 처리할 수 있는 TPS에 따라 필요한 총 node들의 개수를 나타낸다.  
  하드웨어가 동일하다고 가정했을 때 node가 초당 처리할 수 있는 트랜잭션의 수가 많으면 많을 수록 최종적으로 필요한 node의 개수는  
  줄어들며, 이는 곧 하드웨어 비용을 절감할 수 있음을 나타낸다. 따라서 우리는 이번 설계에서 하나의 node가 가능한 많은 TPS를  
  지원하도록 해야 한다.

  | node당 TPS | node 개수 |
  | ---------- | --------- |
  | 100        | 20000     |
  | 1000       | 2000      |
  | 10000      | 200       |

---

## 개략적 설계안 제시 및 동의 구하기

- 이번에는 아래의 내용들을 살펴볼 것이다.

  - API 설계
  - 3개의 개략적 설계안
    - in-memory를 사용한 방법
    - Database 기반의 분산 트랜잭션을 사용한 방법
    - Event-sourcing을 활용해 재현 가능성을 구현한 방법

### API 설계

- RESTful API 컨벤션을 사용하도록 하자. 여기서는 하나의 API만 지원하면 된다.

  | API                               | 설명                                        |
  | --------------------------------- | ------------------------------------------- |
  | `POST /v1/wallet/balance_transfer | 하나의 지갑으로부터 다른 지갑으로 송금한다. |

- 요청 파라미터는 아래와 같다.

  | 필드             | 설명                         | 타입   |
  | ---------------- | ---------------------------- | ------ |
  | `from_account`   | 송금자 계좌                  | string |
  | `to_account`     | 수취자 계좌                  | string |
  | `amount`         | 금액                         | string |
  | `currency`       | 통화                         | string |
  | `transaction_id` | 중복 제거를 위해 사용되는 ID | uuid   |

- 응답은 아래와 같다.

  ```json
  {
    "status": "success",
    "transaction_id": "0158998-2254-11ec-0493-3938ca403284"
  }
  ```

- 위에서 금액을 나타내는 `amount` 필드의 타입이 double이 아니라 string인데, 이렇게 한 이유는 이전 장에서 찾을 수 있다.

  > - `amount`가 double이면 아래와 같은 이유로 좋지 않다.
  >   - 직렬화, 역직렬화 과정이 프로토콜, 소프트웨어, 하드웨어에 따라 다를 수 있다. 이러한 차이로 인해 숫자 계산이 잘못될 수 있다.
  >   - 숫자가 매우 클 수 있거나 매우 작을 수도 있다.

- 실전에서 대부분의 사람들은 여전히 float나 double이 대부분의 프로그래밍 언어와 데이터베이스에서 지원한다는 이유로 사용한다.  
  하지만 이렇게 하면 precision(정밀도)가 낮아질 수 있다는 점을 감안해야 한다.

### In-memory sharding을 활용한 방법

- 지갑 애플리케이션은 모든 사용자 계좌마다 잔액 정보를 유지한다. 이렇게 `<user, balance>` 관계를 나타내기 좋은 자료구조로  
  map(hash table, hash map) 또는 key-value store를 활용할 수 있다.

- In-memory store 중 가장 유명한 선택지는 Redis이다. 하나의 Redis node로는 1,000,000 TPS를 감당할 수 없다.  
  따라서 Redis node들로 구성된 cluster를 생성하고, 사용자 계좌를 이 cluster 내의 node들로 고르게 분배해야 한다.  
  이 과정을 partitioning 또는 sharding이라 한다.

- Key-value 데이터를 _n_ 개의 partition들로 분산시키기 위해 key의 hash 값을 계산하고, _n_ 으로 나눌 수 있다.  
  그리고 나눈 나머지값이 해당 데이터가 저장될 partition이 된다. 아래는 이러한 sharding 과정을 나타낸 pseudo code이다.

  ```java
  String accountID = "A";
  int partitionNumber = 7;
  int myPartition = accountID.hashCode() % partitionNumber;
  ```

- Redis cluster 내 node들의 개수 및 각각의 주소는 중앙화된 공간에 저장될 수 있다. 예를 들어, 고가용성의 설정 저장소인 Zookeeper를 활용할 수 있다.

- 이렇게 in-memory sharding을 활용하는 방법의 마지막 컴포넌트는 송금 요청을 처리하는 서비스이다.  
  우리는 이 서비스를 Wallet service라 할 것이고, 이 서비스는 아래의 주요 책임을 가진다.

  - (1) 송금 요청 수신
  - (2) 송금 요청 검증
  - (3) 요청이 유효하면 송금인, 수취인의 잔액 정보를 갱신한다. Cluster 내에서 송금인과 수취인의 정보는 서로 다른 node에 저장되어 있을 수 있다.

- Wallet service는 stateless하다. 따라서 horizontal scaling(수평적 확장)이 매우 쉽다.  
  아래 그림은 in-memory sharding을 활용한 방법의 개략적 설계안을 나타낸다.

  ![picture 1](/images/SDI2_DW_3.png)

- 위 설계안에는 3개의 Redis node들이 존재한다. 그리고 A, B, C 고객의 정보가 node들에 고르게 분산되어 저장되어 있다.  
  또한 송금 요청을 처리하기 위해 2개의 Wallet service node들이 있다. 만약 하나의 Wallet service node가 $1을 A 계좌에서  
  B 계좌로 송금하라는 요청을 받으면, 이 요청을 처리하기 위해 2개의 Redis node와 상호작용해야 한다. 고객 A의 계좌 정보를 가지는  
  Redis node에서 Wallet service는 해당 계좌로부터 $1을 차감하고, 고객 B의 계좌에 $1을 입금한다.

- 하지만 이 설계는 매우 심각한 문제를 갖고 있다. 물론 동작은 하지만, Wallet service가 각 송금 과정에서 2개의 Redis node를 모두  
  정상적으로 갱신 처리할 수 있다는 보장이 없다. 만약 예를 들어 Wallet service node가 송금인의 계좌에 대한 갱신 작업을 마친 즉시  
  장애가 난다면, 수취인의 계좌 잔액은 변함이 없을 것이다. 이 두 작업은 모두 single atomic transaction(단일 원자성 트랜잭션) 내에서 수행되어야 한다.

### Database 기반의 분산 트랜잭션을 사용한 방법

#### Database sharding

- 2개의 서로 다른 node들에 대해 수행되는 작업이 어떻게 원자성을 갖도록 할 수 있을까?  
  첫 번째로 각 Redis node를 전통적인 RDBMS node로 바꿀 수 있을 것이다. 아래 그림은 이 설계를 보여준다.  
  이전과 달리 고객 A, B, C의 정보는 3개의 Redis node가 아닌 3개의 RDBMS node들에 분배되어 저장되어 있다.

  ![picture 2](/images/SDI2_DW_4.png)

- 이렇게 RDBMS를 사용하는 것은 문제의 일부분만을 해결한다. 이전에 봤듯이 하나의 송금 요청이 서로 다른 2개의 database node에 작업을  
  수행해야 하는 경우가 분명히 발생한다. 그리고 이러한 경우, 2개의 갱신 작업이 정확히 같은 시간에 정상적으로 처리될 것이라는 보장이 없다.  
  만약 송금인의 잔액 정보를 갱신한 후 Wallet service가 재시작하게 되었다면, 수취인의 잔액 정보를 이후 갱신하도록 어떻게 할 수 있을까?

#### Distributed transaction: 2PC Commit(Two-phase commit)

- 분산 시스템에서 하나의 트랜잭션은 여러 개의 node들에 거쳐 다양한 작업을 수행하게 될 수 있다. 트랜잭션이 원자성을 지니도록 하기 위해서  
  distributed transaction(분산 트랜잭션)을 활용할 수 있다. 분산 트랜잭션을 구현하는 방법으로는 low-level solution, 그리고  
  high-level solution의 2가지 방법이 있다. 이 둘 각각을 살펴보자.

- Low-level solution은 database 자체에 기대게 된다. 가장 일반적으로 활용되는 알고리즘은 2PC(two-phase commit)이다.  
  2PC는 이름에서 알 수 있듯이 2단계의 phase를 가진다.

  ![picture 3](/images/SDI2_DW_5.png)

- 각 과정을 살펴보자.

  - (1) Coordinator(이 경우 Wallet service)가 평소처럼 여러 개의 database들에 read, write 연산을 수행한다.  
    위 그림에서 알 수 있듯이 데이터베이스 A, C에 lock이 걸린다.

  - (2) 애플리케이션이 트랜잭션을 commit할 시점이 되면, coordinator는 연관된 모든 데이터베이스가 트랜잭션을 준비하도록 한다.

  - (3) 2번째 phase에서 coordinator는 연관된 모든 데이터베이스들의 응답을 모아 아래 작업을 수행한다.

    - (a) 모든 데이터베이스가 `yes`로 응답하면, coordinator는 모든 데이터베이스에게 트랜잭션을 commit하도록 요청한다.
    - (b) 하나의 데이터베이스라도 `no`라 응답하면, coordinator는 모든 데이터베이스에게 트랜잭션을 중단하도록 요청한다.

- 이 방법이 low-level solution이라 불리는 이유는 준비 단계(phase 1)를 구현하려면 데이터베이스 트랜잭션에 대해 특수한 설정이  
  들어가야 하기 때문이다. 예를 들어 서로 다른 데이터베이스가 2PC를 지원하도록 하기 위해 X/Open XA 표준이 존재한다.  
  2PC의 가장 큰 문제점은 모든 데이터베이스의 응답을 기다릴 때까지 데이터베이스에 lock이 걸리기 때문에 성능이 떨어진다는 점이다.  
  또다른 문제점으로 아래 그림처럼 coordinator가 SPOF가 될 수 있다.

  ![picture 4](/images/SDI2_DW_6.png)

#### Distributed transaction: TC/C(Try-Confirm/Cancel)

- TC/C는 보상 트랜잭션(compensating transaction)중 하나로 아래의 2개 단계로 구성되어 있다.

  - (1) 첫 번째 phase에서 coordinator는 모든 데이터베이스에게 transaction에 필요한 리소스를 예약할 것을 요청한다.
  - (2) 두 번째 phase에서 coordinator는 모든 데이터베이스의 응답을 모은다.

    - (a) 모든 데이터베이스가 `yes`로 응답하면, coordinator는 모든 데이터베이스에게 연산을 수행하도록 한다.  
      이 과정이 TC(Try-Confirm)에 해당한다.
    - (b) 하나의 데이터베이스라도 `no`라 응답하면, coordinator는 모든 데이터베이스에게 연산을 취소하라고 한다.  
      이 과정이 Try-Cancel에 해당한다.

- 참고로 2PC에서 2개 phase는 모두 하나의 트랜잭션에서 동작하는 반면, TC/C의 각 phase는 서로 다른 트랜잭션에서 수행된다.

##### TC/C 예시

- 계좌 A에서 계좌 C로 $1을 송금한다고 가정해보자. 아래 표는 TC/C가 각 phase에서 수행하는 연산을 보여준다.

  ![picture 5](/images/SDI2_DW_7.png)

- TC/C의 coordinator가 Wallet service라 가정해보자. 분산 트랜잭션이 시작될 때 계좌 A의 잔액은 $1이고, 계좌 C의 잔액은 $0이다.

- **Phase 1: Try**

  - _Try_ phase에서 coordinator로 동작하는 wallet service는 2개의 트랜잭션 명령을 2개의 데이터베이스로 보낸다.

    - (1) 계좌 A의 정보를 저장한 데이터베이스에게 coordinator는 계좌 A의 잔액을 $1 차감하는 local transaction을 시작한다.
    - (2) 계좌 C의 정보를 저장한 데이터베이스에게 coordinator는 NOP(no operation)을 전달한다.  
      NOP 명령을 받은 데이터베이스는 아무런 작업도 수행하지 않으며, 언제나 성공 메시지를 반환한다.

  - 아래 그림은 _Try_ phase를 나타낸다. 굵은 선은 트랜잭션에 의해 lock이 걸린 부분을 나타낸다.

    ![picture 6](/images/SDI2_DW_8.png)

- **Phase 2: Confirm**

  - 두 개의 데이터베이스가 모두 `yes`의 응답을 반환하면, wallet service는 _Confirm_ phase를 시작한다.

  - 계좌 A의 잔액 정보는 이미 phase 1에서 갱신되어 있다. 따라서 A의 정보는 더 이상 갱신할 필요가 없다. 하지만 phase 1에서  
    계좌 C에게 $1이 입금되지는 않았다. 따라서 _Confirm_ phase에서 wallet service는 $1만큼을 계좌 C에 입금해야 한다.

  - 아래 그림은 _Confirm_ phase의 과정을 나타낸다.

    ![picture 7](/images/SDI2_DW_9.png)

- **Phase 2: Cancel**

  - 만약 첫 번째 phase인 _Try_ phase가 실패하면 어떻게 될까? 위에서는 phase 1에서 계좌 C의 정보를 가진 데이터베이스에게  
    보내진 NOP 명령은 항상 성공한다고 가정했지만, 실전에서 이 부분이 실패할 여지는 분명히 존재한다. 예를 들어 계좌 C가 불법 계좌여서  
    관리자가 해당 계좌로의 송금을 모두 금지시켰다고 해보자. 이 경우 분산 트랜잭션은 취소되어야 할 것이다.

  - _Try_ phase에서 계좌 A의 잔액 정보가 이미 갱신되었고, wallet service는 이미 완료된 트랜잭션을 취소할 수 없다.  
    대신 _Try_ phase에서 수행된 트랜잭션을 취소시키는 과정을 담은 또다른 트랜잭션을 시작시킬 수 있다. 이 예시 상황의 경우, 이  
    트랜잭션은 계좌 A에게 $1을 다시 입금시키는 작업을 수행할 것이다.

  - _Try_ phase에서 계좌 C의 정보는 갱신되지 안핬기 때문에 계좌 C의 정보를 가진 데이터베이스에는 NOP 연산을 보내면 된다.  
    아래 그림은 이러한 _Cancel_ 과정을 나타낸다.

    ![picture 8](/images/SDI2_DW_10.png)

#### 2PC vs TC/C

- 아래 표를 보면 2PC와 TC/C는 비슷한 점도 많지만, 차이점도 많다는 것을 알 수 있다.  
  2PC에서 모든 local transaction은 두 번째 phase가 시작될 때까지 수행 중(locked)인 상태인 반면, TC/C에서 모든 local  
  transaction들은 두 번째 phase가 시작될 때 완료(unlock)되어 있다. 다른 말로 표현하자면 2PC의 두 번째 phase는 완료되지 않은  
  트랜잭션을 commit하거나 rollback해 종료시키는 반면, TC/C에서의 두 번째 phase는 이전 트랜잭션에서 에러가 발생했을 때  
  해당 트랜잭션이 수행한 작업을 rollback하는 연산을 수행하는 새로운 트랜잭션을 시작하게 된다.

  | -    | Phase 1                                              | Phase 2: 성공                          | Phase 2: 실패                                                        |
  | ---- | ---------------------------------------------------- | -------------------------------------- | -------------------------------------------------------------------- |
  | 2PC  | local transaction이 끝나지 않은 상태                 | 모든 local transaction commit          | 모든 local transaction 취소                                          |
  | TC/C | 모든 local transaction들은 성공이든 취소든 끝난 상태 | 필요하면 새로운 local transaction 시작 | phase 1에서 실행된 local transaction의 작업을 취소하는 트랜잭션 수행 |

- TC/C는 보상으로 구현한 분산 트랜잭션(distributed transaction by compensation)이라고도 불린다.  
  이 방법은 보상 작업(_"undo"_ 라고도 불린다)을 비즈니스 로직에서 구현하기 때문에 high-level solution이다.  
  이 방법의 장점은 데이터베이스에 대한 깊은 이해 또는 수정이 없이도 구현 가능하다는 것이다. 하지만 모든 세부사항과 분산 시스템의 복잡성을  
  애플리케이션 layer의 비즈니스 로직에서 처리해야 한다는 단점을 가진다.
