# 7. Coroutine Context

- 코루틴 빌더의 정의를 보면 첫 번째 파라미터가 `CoroutineContext` 임을 알 수 있다.

```kt
public fun CoroutineScope.launch(
	context: CoroutineContext = EmptyCoroutineContext,
	start: CoroutineStart = CoroutineStart.DEFAULT,
	block: suspend CoroutineScope.() -> Unit
): Job {
	// ..
}
```

- 그리고 빌더의 receiver 타입 뿐만 아니라, 마지막 인자의 receiver 타입도 `CoroutineScope` 이다.

```kt
public interface CoroutineScope {
	public val coroutineContext: CoroutineContext
}
```

- `CoroutineScope` 의 정의를 봤을 때, `CoroutineScope` 은 마치 `CoroutineContext` 를 wrapping한 것처럼 보인다.
- `Continuation` 의 정의도 다시 봐보자.

```kt
public interface Continuation<in T> {
	public val context: CoroutineContext
	public fun resumeWith(result: Result<T>)
}
```

- `Continuation` 또한 `CoroutineContext` 를 포함하고 있다.

---

## `CoroutineContext` 인터페이스

- `CoroutineContext`는 원소나 원소들의 집합을 나타내는 인터페이스이다.
  `Job`, `CoroutineName`, `CoroutineDispatcher` 와 같은 `Element` 객체들이  
  indexing된 집합이라는 점에서 `Map`, `Set` 등의 collection과 개념이 비슷하다.  
  특이한 점은 각 `Element` 또한 `CoroutineContext` 라는 점이다.
- 원소가 원소의 컬렉션이기에 아래와 같이 코드를 작성할 수 있다.

```kt
launch(CoroutineName("Name1")) { .. }
launch(CoroutineName("Name2") + Job()) { .. }
```

- context에서 모든 원소는 식별 가능한 고유 `Key` 를 가진다. 이 `Key` 는 주소로 비교된다.
- `CoroutineName`, `Job` 은 `CoroutineContext` 를 구현한 `CoroutineContext.Element` 를 구현한다.

```kt
fun main() {
	val name: CoroutineName = CoroutineName("A name")
	val element: CoroutineContext.Element = name
	val context: CoroutineContext = element

	val job: Job = Job()
	val jobElement: CoroutineContext.Element = job
	val jobContext: CoroutineContext = jobElement
}
```

---

## `CoroutineContext` 에서 원소 찾기

- `CoroutineContext` 는 컬렉션과 유사하기에 `get()` 을 사용해 유일한 key를 가진 원소를 찾을 수 있다.  
  이때, 원하는 key를 가진 원소가 context에 없으면 null이 반환된다.

```kt
fun main() {
	val ctx: CoroutineContext = CoroutineName("A name")

	val coroutineName: CoroutineName? = ctx[CoroutineName]
	println(coroutineName?.name) // A name

	val job: Job? = ctx[job]
	println(job) // null
}
```

- `CoroutineName` 을 찾기 위해서는 `CoroutineName` 을 key로 사용하면 된다.  
  `CoroutineName`은 타입이나 클래스가 아닌 companion object이다.  
  클래스의 이름이 companion object에 대한 참조로 사용되는 코틀린 언어의 특징 때문에,  
  `ctx[CoroutineName]` 은 `ctx[CoroutineName.key]` 가 된다.

```kt
data class CoroutineName(
	val name: String
): AbstractCoroutineContextElement(CoroutineName) {
	override fun toString(): String = "CoroutineName($name)"
	companion object key : CoroutineContext.Key<CoroutineName>
}
```

---

## context 더하기

- `CoroutineContext` 의 정말 유용한 기능은 두 개의 `CoroutineContext` 를 합쳐 하나로 만들 수 있다는 것이다.

```kt
fun main() {
	val ctx1: CoroutineContext = CoroutineName("Name1")
	println(ctx1[CoroutineName]?.name) // Name1
	println(ctx1[Job]?.isActive) // null

	val ctx2: CoroutineContext = Job()
	println(ctx2[CoroutineName]?.name) // null
	println(ctx2[Job]?.isActive) // true

	val ctx3 = ctx1 + ctx2
	println(ctx3[CoroutineName]?.name) // Name1
	println(ctx3[Job]?.isActive) // true
}
```

- 같은 key를 가진 또 다른 원소가 `CoroutineContext` 에 더해지면, 새로운 원소가 기존 원소를 대체한다.

```kt
fun main() {
	val ctx1: CoroutineContext = CoroutineName("Name1")
	println(ctx1[CoroutineName]?.name) // Name1

	val ctx2: CoroutineContext = CoroutineName("Name2")
	println(ctx2[CoroutineName]?.name) // Name2

	val ctx3 = ctx1 + ctx2
	println(ctx3[CoroutineName]?.name) // Name3
}
```

---

## 비어 있는 `CoroutineContext`

- `CoroutineContext` 는 컬렉션이므로, 비어있을 수 있다.  
  빈 context는 원소가 없으므로, 다른 context에 더해도 아무런 변화가 없다.

```kt
fun main() {
	val empty: CoroutineContext = EmptyCoroutineContext
	println(empty[CoroutineName]) // null
	println(empty[Job]) // null

	val ctxName = empty + CoroutineName("Name1") + empty
	println(ctxName[CoroutineName]) // CoroutineName(Name1)
}
```

---

## 원소 제거

- `minusKey()` 에 key를 넣는 방식으로 원소를 context에서 제거할 수 있다.

```kt
fun main() {
	val ctx = CoroutineName("Name1") + Job()
	println(ctx[CoroutineName]?.name) // Name1
	println(ctx[Job]?.isActive) // true

	val ctx2 = ctx.minusKey(CoroutineName)
	println(ctx2[CoroutineName]?.name) // null
	println(ctx2[Job]?.isActive) // true

	val ctx3 = (ctx + CoroutineNAme("Name2")).minusKey(CoroutineName)
	println(ctx3[CoroutineName]?.name) // null
	println(ctx3[Job]?.isActive) // true
}
```

---
