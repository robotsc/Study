# Getting started with Terraform

## Deploying a Single server

- Terraform 코드는 _HCL(HashiCorp Configuration Language)_ 로, `.tf` 확장자를 사용한다.  
  선언적 언어이기 때문에 인프라의 원하는 상태를 코드로 나타내면 된다.

- Terraform 사용의 첫 번째 단계는 cloud provider에 대한 설정을 지정하는 것이다.

  ```tf
  provider "aws" {
  	region = "ap-northeast-2"
  }
  ```

- 위 파일은 사용할 cloud provider가 AWS이고, ap-northeast-2 region을 사용할 것임을 나타낸다.

- Provider 각각에 대해서 서버, 데이터베이스 등 다양한 종류의 _리소스_ 를 사용할 수 있다.  
  Terraform에서 리소스를 생성하는 일반적인 문법은 아래와 같다.

  ```tf
  resource "<PROVIDER>_<TYPE>" "<NAME>" {
  	[CONFIG ...]
  }
  ```

  - `<PROVIDER>`: aws 등 provider의 이름
  - `<TYPE>`: 해당 provider에 만들고 싶은 리소스의 종류(instance 등)
  - `<NAME>`: Terrraform 코드에서 해당 리소스를 참조하기 위한 이름

- 예를 들어 하나의 EC2 instance를 AWS에 배포하려면 아래처럼만 하면 된다.

  ```tf
  resource "aws_instance" "example" {
  	ami 		= "ami-0fb653ca2d3203ac1"
  	instance_type 	= "t2.micro"
  }
  ```

  - `aws_instance` 리소스는 다양한 인자를 지정할 수 있지만, 위에서는 필수로 필요한 ami와 instance type만 지정했다.

- 이제 위의 내용을 `main.tf`에 담고, 해당 파일이 있는 폴더로 이동해 `terraform init` 명령어를 실행해보자.  
  `terraform` 바이너리는 Terraform의 기본적인 기능을 포함하지만, cloud provider를 사용하기 위한 코드를 포함하진 않는다.  
  따라서 Terraform을 처음 사용할 때는 `terraform init`을 수행해 Terraform이 코드를 스캔하고, 어떤 provider를 사용하는지  
  파악한 후 해당 provider를 사용하기 위한 코드를 받을 수 있게끔 해야 한다.

- `terraform init`을 수행하면 다양한 파일들이 생겨나는데, 하나씩 살펴보자.

  - `.terraform` 폴더: Terraform이 사용할 provider의 코드가 저장되는 폴더
  - `.terraform.lock.hcl`: Terraform이 다운로드한 provider의 코드에 대한 버전 정보가 저장되는 파일

- 이제 provider 코드의 준비도 끝났으니, `terraform plan` 명령어를 실행해보자.

```
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.example will be created
  + resource "aws_instance" "example" {
      + ami                                  = "ami-0fb653ca2d3203ac1"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = (known after apply)
      + availability_zone                    = (known after apply)
      + cpu_core_count                       = (known after apply)
      + cpu_threads_per_core                 = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + iam_instance_profile                 = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t2.micro"
      + ipv6_address_count                   = (known after apply)
      (...)
    }

Plan: 1 to add, 0 to change, 0 to destroy.
```

- 위에서 볼 수 있듯이 `terraform plan` 명령은 `terraform apply`를 할 때 어떤 변경 사항이 인프라에 반영될지를 보여준다.  
  이렇게 `terraform plan`을 사용하면 코드에 대한 검증을 해볼 수 있다.  
  위 output의 경우 Terraform은 새로운 하나의 EC2 instance를 띄울 것임을 알 수 있다.

- 이제 `terraform apply`를 수행하면 새로운 EC2 instance가 생성된다.

- 이제 선언적 언어의 장점을 확인하기 위해 이 EC2 instance에 새로운 tag를 지정하고 싶다고 해보자.  
  아래처럼 `main.tf` 파일을 수정해보자.

  ```tf
  resource "aws_instance" "example" {
  ami           = "ami-0443a21cb1a8f238e"
  instance_type = "t2.micro"
  tags = {
    "Name" = "terraform-example"
    }
  }
  ```

- `terraform apply`를 수행하면 지정한 tag가 기존 instance에 적용된다.

- Terraform은 configuration file들로 생성한 리소스들의 상태를 추적하기 때문에, 기존에 이미 EC2 instance가 있음을 알 수 있다.

---

## Deploying a Single Web Server

- 이번에는 기존에 생성한 인스턴스에 아래 그림과 같이 web server를 실행해볼 것이다.

  ![picture 1](/images/TFRU_9.png)

- 실제로는 RoR, Django 등의 프레임워크를 사용해 웹 서버를 개발하겠지만, 여기서는 단순하게 가져가보자.  
  아래의 스크립트는 항상 "Hello, World"만을 반환하는 매우 간단한 웹 서버이다.

  ```sh
  #!/bin/bash
  echo "Hello, World" > index.html
  nohup busybox httpd -f -p 8080 &
  ```

- EC2가 실행될 때마다 위 스크립트를 실행하도록 하는 방법으로 EC2 user data configuration 기능을 활용할 수 있다.  
   그리고 이를 Terraform 파일에 아래처럼 지정할 수 있다.

  ```tf
  resource "aws_instance" "example" {
  ami           = "ami-0443a21cb1a8f238e"
  instance_type = "t2.micro"

  tags = {
    "Name" = "terraform-example"
  }

  user_data_replace_on_change = true

  user_data = <<-EOF
              #!/bin/bash
              echo "Hello, World" > index.html
              nohup busybox httpd -f -p 8080 &
              EOF
  }
  ```

- 위 코드에서 봐야할 가지 한 가지는 `<<-EOF`와 `EOF`이다. 이는 Terraform의 _heredoc_ 문법으로, `\n` 문자를 입력하지 않고도  
  여러 줄의 문자열을 입력할 수 있게 해준다.

- 다음으로 해당 EC2 instance가 8080 포트로 접근할 수 있도록 하기 위해 security group을 만들어보자.

  ```tf
  resource "aws_security_group" "instance" {
  name = "terraform-example-instance"
  ingress = [{
      cidr_blocks = ["0.0.0.0/0"]
      from_port   = 8080
      protocol    = "tcp"
      to_port     = 8080
    }]
  }
  ```

- 새롭게 생성한 security group을 EC2 instance에 연결해줘야 한다. 이는 `vpc_security_group_ids` 라는 인자를 통해  
  지정할 수 있는데, 적용하기 전 먼저 Terraform _expression_ 에 대해 살펴보자.

- Terraform의 모든 표현식(expression)은 반환값이 존재한다. 다양한 표현식 중 자주 쓰이는 것은 _참조(reference)_ 로,  
  다른 Terraform 코드의 실제 값을 참조하도록 해준다. 예를 들어, 위에서 security group의 ID를 참조하려면  
  _resource attribute reference_ 를 사용해야 하며, 아래의 문법을 가진다.

  - `<PROVIDER>_<TYPE>.<NAME>.<ATTRIBUTE>`

- 한 번 EC2 코드에 사용해보자.

  ```tf
  resource "aws_instance" "example" {
  	#..
  	vpc_security_group_ids = [aws_security_group.instance.id]
  }
  ```

- 이렇게 하나의 리소스를 다른 리소스에서 참조하게 되면 _implicit dependency_ 를 생성하게 된다.  
  Terraform은 이러한 의존성들을 parsing하고, dependency graph를 만들어내고, 자동으로 어떤 순서로 리소스를 생성해야 할지  
  결정한다. 예를 들어, EC2와 Security Group이 함께 있는 코드를 처음 `apply` 한다면, Terraform은 Security Group을  
  먼저 만들어야 함을 안다.

- 이러한 dependency graph는 `terraform graph` 명령어를 통해 확인할 수 있다.

---
