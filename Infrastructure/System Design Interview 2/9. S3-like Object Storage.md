# S3-like Object Storage

- 이번 장에서는 Amazon S3와 비슷한 object storage 서비스를 설계해보자.  
  S3는 AWS에 의해 제공되는 object storage이며 RESTful API를 기반으로 하는 인터페이스를 제공한다.  
  아래는 S3에 대한 사실 중 일부이다.

  - 2006년 6월: GA
  - 2010년: Versioning, Bucket Policy, Multipart upload 지원
  - 2011년: SSE, Multi-object Delete, Object Expiration 지원
  - 2013년: S3에 저장된 object 개수 2조개 달성
  - 2014, 2015년: Life Cycle Policy, Event Notification, Cross-Region Replication 지원
  - 2021년: S3에 저장된 object 개수 200조개 달성

- Object storage를 설계하기 전, 우선 몇 가지의 storage system들을 살펴보고, 용어들을 정의하자.

## Storage System 101

- 개략적으로 봤을 때 storage system들은 아래의 3개 카테고리로 나뉜다.

  - Block storage
  - File storage
  - Object storage

### Block storage

- Block storage는 1960년대에 탄생했다. HDD, SSD와 같이 서버에 물리적으로 연결된 storage device를 block storage라 한다.

- Block storage는 저장된 raw block들을 서버에게 volume으로 제공한다. 이렇게 함으로써 storage를 유연하고, 다양한 용도로 사용할 수  
  있게 했다. 서버는 raw block들을 format해 file system으로 사용할 수도 있고, block들에 대한 제어권을 특정 애플리케이션에게  
  넘길 수도 있다. 데이터베이스나 VM engine같은 몇 가지 애플리케이션들은 성능을 쥐어짜내기 위해 block들을 직접 관리한다.

- Block storage는 단지 물리적으로 연결된 storage는 아니다. 빠른 속도를 가진 네트워크로 서버에게 연결될 수도 있고, FC(Fibre Channel),  
  iSCSI 등의 표준 프로토콜로 서버에게 연결될 수도 있다. 개념적으로 네트워크로 연결된 block storage는 여전히 raw block을 다루며  
  서버 입장에서는 물리적으로 연결된 block storage와 동일하게 사용할 수 있다.

### File storage

- File storage는 block storage에 기반해 만들어진 storage system이며 파일과 디렉토리를 더 쉽게 다루기 위해 추상화되어 있다.  
  데이터는 file의 형식으로 계층적 디렉토리 구조 내에 저장된다. 일반적인 용도로 가장 많이 사용되는 storage solution은 file storage이다.  
  File storage는 SMB/CIFS, NFS 등의 일반적인 file-level 네트워크 프로토콜을 사용해 동시에 수많은 서버들로 연결되어질 수 있다.  
  그리고 file storage에 접근하는 서버들은 block 관리, volume formatting 등 복잡한 과정을 관리할 필요가 없다.  
  이러한 file storage의 단순함과 간편함은 특정 organization 내에서 여러 개의 파일, 디렉토리를 공유하기에 너무나 좋은 선택지가 된다.

### Object storage

- Object storage는 block storage, file storage에 비하면 최신 기술에 속한다. 그리고 항상 성능과 안전성, 확장성, 비용에 대해  
  tradeoff 관계가 형성된다. 주로 상대적으로 archiving이나 backup을 위해 사용되는 상대적으로 _"cold"_ 한 데이터를 저장하기 위해  
  많이 사용된다. Objec tsotrage는 모든 데이터를 flat한 구조에 object로 저장한다. 따라서 계층적인 디렉토리 구조가 없다.  
  데이터에 대한 접근은 일반적으로 RESTful API로 제공된다. 그리고 다른 storage들에 비해 상대적으로 처리 속도가 느린 편이다.  
  대부분의 public cloud provider는 Amazon S3, Google Object Storage, Azure Blob Storage와 같이 object storage를  
  제공한다.

#### 3개 storage system들의 비교

![picture 45](/images/SDI2_SOS_1.png)

- 아래 표는 block storage, file storage, 그리고 object storage를 비교한 내용을 가진다.

| 특성            | Block storage                                              | File storage                        | Object storage                        |
| --------------- | ---------------------------------------------------------- | ----------------------------------- | ------------------------------------- |
| Mutable content | Y                                                          | Y                                   | N(object versioning을 사용해야 한다.) |
| Cost            | High                                                       | Medium to high                      | Low                                   |
| Performance     | Medium to high, very high                                  | Medium to high                      | Low to medium                         |
| Consistency     | Strong consistency                                         | Strong consistency                  | Strong consistency                    |
| Data access     | SAS/iSCSI/FC                                               | Standard file access, CIFS/SMB, NFS | RESTful API                           |
| Scalability     | Medium                                                     | High                                | Vast                                  |
| Good for        | VMs(Virtual Machines), Database와 같은 고성능 애플리케이션 | 일반적인 용도의 file system access  | Binary data, unstructured data        |

### 용어 정의

- S3-like object storage를 설계하려면 우선 object storage의 핵심 개념을 정립해야 한다.  
  여기서는 관련 용어들과 그 내용을 정의해보자.

- **Bucket** : Object들의 논리적인 container. Bucket의 이름은 전역적으로 unique해야 하며 데이터를 S3에 upload하기 전, 먼저  
  bucket을 생성해야 한다.

- **Object** : Object는 bucket에 저장할 독립적인 데이터 조각을 말한다. Payload라고도 불리는 object data와 metadata를 가진다.  
  Object data는 저장하고 싶은 순차적인 byte가 될 수도 있고, meatadata는 object에 대한 정보를 담은 name-value pair들로 구성된다.

- **Versioning** : 같은 bucket 내의 한 object의 여러 변형을 저장하도록 하는 기능이다. Bucket-level에서 활성화시킬 수 있다.  
  이 기능은 의도치 않게 삭제되거나 갱신된(overwritten) object를 사용자들이 복구할 수 있게 한다.

- **URI(Uniform Resource Identifier)** : Object storage는 bucket, object에 접근하기 위해 RESTful API들을 제공한다.  
  이를 위해 각 리소스들은 URI로 구별된다.

- **SLA(Service-Level Agreement)** : SLA는 서비스 프로바이더와 클라이언트 사이의 계약이다.  
  예를 들어, Amazon S3 Standard-IA storage class는 아래의 SLA를 제공한다.

  - 여러 개의 AZ에 걸쳐 99.999999999%의 내구성을 위해 설계되었다.
  - 데이터는 하나의 AZ가 장애 나더라도 회복할 수 있다.
  - 99.9%의 가용성을 위해 설계되었다.

---

## 문제 이해 및 설계 범위 확정

- 이번에 설계할 시스템의 요구사항들은 아래와 같다.

### 기능적 요구사항

- Bucket 생성
- Object upload, download
- Object versioning
- Bucket 내의 object들의 목록 조회. `aws s3 ls` 명령과 비슷하다.
- 대용량의(GB 단위 또는 그 이상) 데이터와 작은 데이터(수십 KB)를 모두 효율적으로 저장할 수 있어야 한다.
- 1년에 저장되는 총 데이터량은 100PB이다.

### 비기능적 요구사항

- 데이터 내구성은 99.9999%, 가용성은 99.99%를 만족해야 한다.
- Storage는 효율적이어야 한다. 높은 안정성과 성능을 제공함과 동시에 storage 비용은 최소화해야 한다.

### 추정치 계산

- Object storage는 일반적으로 디스크의 용량이나 IOPS(Input Output Per Second)가 병목 지점이 된다. 간단히 살펴보자.

  - Disk 용량: Object들이 아래와 같이 분포되어 있다고 가정해보자.

    - 1MB 미만의 object들: 20%
    - 1MB~64MB의 object들: 60%
    - 64MB 이상의 object들: 20%

  - IOPS: 하나의 hard disk(SATA interface, 7200rpm)가 random seek를 1초에 100~150번 수행할 수 있다 하자.(100 ~ 150 IOPS)

- 위의 수치들에 기반해 시스템이 보관할 수 있는 object들의 개수를 추정해볼 수 있다. 계산 과정을 단순화하기 위해 small object는 0.5MB,  
  medium object는 32MB, 그리고 large object는 200MB의 크기를 가진다고 가정하자.

- Storage를 40% 정도 사용한다 가정하면, 아래와 같은 수치가 나온다.

  - 100PB = `100 * 1000 * 1000 * 1000MB = 10^11MB`
  - `10^11MB * 0.4 / (0.2 * 0.5MB + 0.6 * 32MB + 0.2 * 200MB) = 6억 8000`개의 object들
  - Object의 metadata가 1KB라 가정하면 metadata 정보들을 위한 공간은 0.68TB가 된다.

- 위에서 나온 수치들을 직접 사용하지 않을 수도 있지만, 설계하려는 시스템의 규모와 제약 조건들을 파악하기에는 좋은 방법이다.

---

## 개략적 설계안 제시 및 동의 구하기

- 설계를 다루기 전, 먼저 object storage의 재미있는 특징들을 먼저 살펴보자.

- **Object immutability** : Object storage가 file storage, block storage와 달리 가지는 주요한 차이점 중 하나는 object  
  storage 내에 저장된 object는 불변하다는 것이다. 기존 object를 삭제하거나 완전히 대체할 수는 있어도, 갱신할 수는 없다.

- **Key-value store** : Object data를 가져오기 위해 object URI를 사용할 수 있다. Object URI는 key가 되며, object data가  
  value가 된다.

```
Request:
GET /bucket1/object1/txt HTTP/1.1

Response:
HTTP/1.1 200 OK
Content-Length: 4567

[4567 bytes of object data]
```

- **Write once, read many times** : Object data에 대한 접근 패턴은 한 번 쓰고 여러번 읽는 특징을 가진다.  
  LinkedIn에 따르면 요청의 95%가 read 연산을 수행한다고 한다.

- **Support both small and large objects** : Object의 크기는 각각 다르며 크거나 작은 데이터를 모두 지원해야 한다.

- Object storage의 설계 철학은 UNIX file system과 매우 유사하다. UNIX에서 local file system에 파일을 저장할 때  
  filename과 file data를 함께 저장하지 않는다. 대신 filename은 inode라는 자료구조에 저장되고 file data는 disk의 다른 위치에  
  저장된다. inode는 file data를 가리키는 file block pointer들을 가진다. 특정 local file에 접근할 때 먼저 inode로부터  
  metadata를 가져오게 된다. 그 후 file block pointer를 따라 디스크에 file data가 저장된 위치를 파악해 데이터를 읽어오게 된다.

- Object storage도 위와 비슷하게 동작한다. inode는 meatdata store가 되며, metadata store는 모든 object metadata를  
  보관한다. Hard disk는 object data가 저장되는 data store가 된다. UNIX file system에서 inode가 file block pointer를  
  통해 hard disk에 저장된 데이터의 위치를 찾아가는 것처럼 object storage에서는 네트워크 요청을 사용해 metadata store가  
  object의 ID를 통해 data store에 저장된 object data를 찾아간다. 아래 그림은 이 둘의 개랴적인 과정을 나타낸다.

  ![picture 47](/images/SDI2_SOS_2.png)

- 이렇게 metadata와 object data를 분리해 저장하는 것은 설계를 단순하게 해준다. Data store는 불변(immutable) 데이터를 저장하는  
  반면, metadata store는 가변(mutable) 데이터를 저장한다. 이러한 분리는 서로 다른 컴포넌트를 독립적으로 구현하고 최적화할 수 있도록 한다.

- 아래 그림은 bucket과 object가 어떤 모습인지 간단히 나타낸다.

  ![picture 48](/images/SDI2_SOS_3.png)

### 개략적 설계안

- 아래 그림은 개략적 설계안이다.

![picture 49](/images/SDI2_SOS_4.png)

- 각 컴포넌트들을 하나씩 살펴보자.

  - Load balancer: 여러 개의 API server들로 RESTful API 요청들을 분산시킨다.
  - API service: RPC들을 IAM service, Metadata service, Date store들로 적절히 orchestrate한다.  
    이 컴포넌트는 수평적 확장을 쉽게 하기 위해 stateless하다.
  - IAM(Identity & Access Management): 이 서비스는 인증, 인가, 그리고 접근 제어를 수행하는 중앙 서비스이다.  
    인증은 요청자의 신원을 파악하고, 인가는 신원에 따라 특정 작업을 수행할 권한이 있는지를 검증한다.
  - Data store: 실제 데이터를 저장하고 반환한다. 데이터와 관련된 모든 연산은 Object ID(UUID)를 기반으로 수행된다.
  - Metadata store: Object들의 metadata들을 저장한다.

- 이제 개략적 설계안에 대해 기본적인 이해가 되었으니, 아래의 object storage의 가장 주된 workflow들을 다뤄보자.

  - Object upload
  - Object download

#### Object upload

![picture 50](/images/SDI2_SOS_5.png)

- Object는 특정 bucket내에 저장된다. `bucket-to-share`라는 이름의 bucket을 만들고, 이 bucket에 `script.txt`라는 파일을  
  저장하는 과정을 살펴보자.

  - (1) 클라이언트는 `bucket-to-share`의 이름을 가지는 bucket을 생성하는 HTTP PUT request를 보낸다.  
    이 요청은 load balancer에서 API service로 전달된다.
  - (2) API service는 IAM을 호출해 해당 사용자가 WRITE 작업에 대한 권한을 가지는지 확인한다.
  - (3) API service는 bucket에 대한 새로운 entry를 metadata store에 생성한다. 이 entry가 생성되면, 성공 응답이 클라이언트에게 보내진다.
  - (4) Bucket이 생성된 후, 클라이언트는 `script.txt`라는 파일을 업로드하는 HTTP PUT request를 보낸다.
  - (5) 다시 IAM으로 권한이 있는지 확인하고, 성공하면 API service는 HTTP PUT request의 payload를 data store에 저장시킨다.  
    Data store는 payload를 object로 저장하며, 저장된 object의 UUID를 반환한다.
  - (6) API service가 metadata database에 새로운 entry를 저장시킨다. `object_id(UUID)`와 `bucket_id`,  
    `object_name` 등 중요한 metadata를 포함한다. 아래 표는 저장된 entry의 예시이다.

  | object_name | object_id                        | bucket_id                         |
  | ----------- | -------------------------------- | --------------------------------- |
  | script.txt  | 239D8443-0122-44F5-043E-C13E345S | 82AA1B2E-F599-4593-B353-1F5FA4FS1 |

- Object를 upload하는 API는 아래와 같다.

  ```
  PUT /bucket-to-share/script.txt HTTP/1.1
  Host: foo.s3example.org
  Date: Mon, 1 Aug 2022 17:03:00 KST
  Authorization: authorization string
  Content-Type: text/plain
  Content-Length: 4567
  x-amz-meta-author: Sangwoo

  [4567 bytes of object data]
  ```

#### Object download

- Bucket은 계층적인 디렉토리 구조를 갖지 않는다. 하지만 bucket 이름과 object 이름을 연결시켜 논리적으로 폴더 구조를 따라할 수 있다.  
  예를 들어 object 이름을 `script.txt`에 대신 `bucket-to-share/script.txt`로 짓는 것이다.

- 특정 object를 가져오기 위해서는 GET 요청에 object이름을 지정해야 한다. 이 API는 아래와 같이 생겼다.

  ```
  GET /bucket-to-share/script.txt HTTP/1.1
  Host: foo.s3example.org
  Date: Mon, 1 Aug 2022 17:03:00 KST
  Authorization: authorization string
  ```

- 이전에 언급했듯이 data store는 object의 이름을 저장하지 않고, 오직 `object_id(UUID)`를 기반으로 한 object 관련 작업만을  
  수행한다. 따라서 object를 download하기 위해서는 먼저 object의 이름을 UUID로 매핑시켜야 한다.

- Object를 다운로드하는 과정은 아래 그림과 같다.

![picture 51](/images/SDI2_SOS_6.png)

- 각 과정을 살펴보자.

  - (1) 클라이언트는 load balancer로 HTTP GET 요청을 보낸다. (`GET /bucket-to-share/script.txt`)
  - (2) API service는 IAM을 통해 요청을 보낸 자가 bucket에 대한 READ 권한이 있는지 검증한다.
  - (3) 검증이 성공하면 API service는 metadata store를 통해 해당 object의 UUID를 가져온다.
  - (4) API service는 data store로부터 UUID를 통해 해당 object data를 가져온다.
  - (5) API service는 object data를 HTTP GET의 응답으로 보낸다.

---
