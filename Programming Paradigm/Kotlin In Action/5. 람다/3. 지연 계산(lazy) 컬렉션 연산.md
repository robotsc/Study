# 지연 계산(lazy) 컬렉션 연산

- 앞에서 본 `map()`, `filter()` 같은 컬렉션 함수는 결과 컬렉션을 **즉시(eagerly)** 생성한다.  
  이는 곧 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.  
  **시퀀스(sequence)** 를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.

- 아래 예시를 보자.

```kt
people.map(Person::name).filter { it.startsWith("A") }
```

- 코틀린 표준 라이브러리 참조 문서에는 `filter()`와 `map()`이 `List`를 반환한다고 써 있다.  
  이는 이 연쇄 호출이 리스트를 2개 만든다는 뜻이다. 한 리스트는 `filter()`의 결과를 담고, 다른  
  하나는 `map()`의 결과를 담는다. 만약 원본 리스트에 원소가 수백만개 된다면 효율이 엄청 떨어질 것이다.

- 이를 더 효율적으로 만들기 위해서는 각 연산이 컬렉션을 직접 사용하는 대신, 시퀀스를 사용하게 해야 한다.

```kt
people
    .asSequence()
    .map(Person::name)
    .filter { it.startsWith("A") }
    .toList()
```

- 전체 연산을 수행한 결과는 이름이 A로 시작하는 사람의 목록으로, 이전 예시와 동일하다.  
  하지만 이 예시에서는 중간 결과를 저장하는 컬렉션이 생기지 않기 때문에 원소가 많은 경우 성능이 눈에  
  띄게 좋아진다.

- 코틀린의 지연 계산 시퀀스는 `Sequence` 인터페이스에서 시작한다. 이 인터페이스는 단지 한 번에 하나씩  
  열거될 수 있는 원소의 시퀀스를 표현할 뿐이다. `Sequence` 안에는 `iterator()`라는 단 하나의 메소드가 있다.  
  이 메소드를 통해 시퀀스로부터 원소 값을 얻을 수 있다.

- `Sequence` 인터페이스의 강점은 그 인터페이스 위에 구현된 연산이 계산을 수행하는 방법 덕분에 생긴다.  
  시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서  
  효율적으로 계산을 수행할 수 있다.

- `asSequence()` 확장함수를 호출하면 어떤 컬렉션이든 시퀀스로 바꿀 수 있다. 시퀀스를 리스트로 만들 때는  
  `toList()`를 사용한다.

- 왜 시퀀스를 다시 컬렉션으로 되돌려야 할까? 컬렉션보다 시퀀스가 훨씬 더 낫다면 그냥 시퀀스를 쓰는 편이 낫지 않을까?  
  이 질문의 답은 "항상 그렇지는 않다." 이다. 시퀀스의 원소를 차례대로 순회해야 한다면 시퀀스를 직접 써도 된다.  
  하지만 시퀀스 원소를 인덱스를 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스트로 변환해야 한다.

```kt
public interface Sequence<out T> {
    /**
     * Returns an [Iterator] that returns the values from the sequence.
     *
     * Throws an exception if the sequence is constrained to be iterated once and `iterator` is invoked the second time.
     */
    public operator fun iterator(): Iterator<T>
}
```

---

## 시퀀스 연산 실행: 중간 연산과 최종 연산

- 시퀀스에 대한 연산은 **중간(intermediate) 연산** 과 **최종(terminal) 연산** 으로 나뉜다.  
  중간 연산은 다른 시퀀스를 반환한다. 그 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 안다.  
  최종 연산은 결과를 반환한다. 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해  
  얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다.

> 위 예시에서 `map()`, `filter()`는 중간 연산이며 `toList()`가 최종 연산이다.

- 중간 연산은 항상 지연 계산된다. 최종 연산이 없는 예시를 보자.

```kt
val list = listOf(1, 2, 3, 4)

val result = list.asSequence()
    .map { print("map($it)"); it * it }
    .filter { print("filter($it)"); it % 2 == 0 }
```

- 위 코드를 실행해보면 아무런 내용도 출력되지 않는다. 이는 곧 `map()`과 `filter()` 변환이 늦춰져서(지연돼서)  
  결과를 얻을 필요가 있을 때, 즉 최종 연산이 호출될 때 적용된다는 뜻이다.

```kt
val result = list.asSequence()
    .map { print("map($it)"); it * it }
    .filter { print("filter($it)"); it % 2 == 0 }
    .toList()
```

- 위처럼 최종 연산을 호출하면 연기됐던 모든 계산이 수행된다.

- 위 예시 코드에서 수행 순서를 잘 알아둬야 한다. 직접 연산을 구현한다면 `map()`을 각 원소에 대해 먼저 수행하고  
  그 결과에 대해 다시 `filter()`를 수행할 것이다. 하지만 시퀀스에 대한 `map()`과 `filter()`는 그렇지 않다.  
  시퀀스의 경우, **모든 연산은 각 원소에 대해 순차적으로 적용** 된다. 즉, 위 코드의 결과는 아래와 같다.

```
map(1)filter(1)map(2)filter(4)map(3)filter(9)map(4)filter(16)
```

- 따라서 원소에 연산을 차례대로 적용하다가 결과가 얻어지면 그 이후의 원소에 대해서는 변환이 이뤄지지 않을 수 있다.  
  이런 예시를 `map()`과 `find()`로 알아보자.

```kt
fun main(args: Array<String>) {

    val list = listOf(1, 2, 3, 4)

    val result = list.asSequence()
        .map { print("map($it)"); it * it }
        .find { it > 3 }

    println(result)
}
```

- 위 코드의 결과는 아래와 같다.

```
map(1)map(2)4
```

- 같은 연산을 시퀀스가 아니라 컬렉션에 대해 수행하면 `map()`의 결과가 먼저 평가되어 최초 컬렉션의  
  모든 원소가 반환된다. 두 번째 단계에서는 `map()`을 적용해 얻은 중간 컬렉션으로부터 조건을 만족하는  
  원소를 찾는다. 시퀀스를 사용하면 지연 계산으로 인해 원소 중 일부의 계산은 이뤄지지 않는다.

- 컬렉션에 대해 수행하는 연산의 순서도 성능에 영향을 끼친다. 사람의 컬렉션이 있는데 이름이 특정 길이보다  
  짧은 사람의 명단을 얻고 싶다 하자. 이를 처리하기 위해서는 각 사람의 이름으로 `map()`한 다음에 이름 중  
  길이가 긴 사람을 제외시켜야 한다. 이 경우에는 `map()`과 `filter()`를 어떤 순서로 수행해도 된다.  
  그러나 `map()` 다음에 `filter()`를 하는 경우와 `filter()` 다음에 `map()`을 하는 경우, 결과는  
  같아도 수행해야 하는 변환의 전체 회수는 다르다.

- `map()`을 먼저 하면 모든 원소를 변환한다. 하지만 `filter()`를 먼저 하면 부적절한 원소를 먼저  
  제외하기 때문에 그런 원소는 변환되지 않는다.

---

## 시퀀스 만들기

- 지금까지 본 시퀀스 예제는 모두 컬렉션에 대해 `asSequence()`를 호출해 시퀀스를 만들었다.  
  시퀀스를 만드는 다른 방법으로 `generateSequence()` 함수를 사용할 수 있다. 이 함수는 이전의 원소를  
  인자로 받아 다음 원소를 계산한다. 아래는 `generateSequence()`로 0부터 100까지 자연수의 합을 구하는 코드다.

```kt
val naturalNumbers = generateSequence(0) { it + 1 }
val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }
println(numbersTo100.sum()) // 5050
```

- 위 예시 코드에서 naturalNumbers와 numbersTo100은 모두 시퀀스이며, 연산을 지연 계산한다.  
  최종 연산을 수행하기 전까지는 시퀀스의 각 숫자는 계산되지 않는다.  
  (여기서는 `sum()`이 최종 연산이다.)

- 시퀀스를 사용하는 일반적인 용례 중 하나는 객체의 조상으로 이뤄진 시퀀스를 만들어내는 것이다. 어떤 객체의 조상이  
  자신과 같은 타입이고 모든 조상의 시퀀스에서 어떤 특성을 알고 싶을 때가 있다.  
  아래 예시는 어떤 파일의 상위 디렉토리를 뒤지면서 hidden 속성을 가진 디렉토리가 있는지 검사함으로써 파일이  
  감춰진 디렉토리 안에 들어있는지 알아본다.

```kt
fun File.isInsideHiddenDirectory() = generateSequence(this) { it.parentFile }.any { it.isHidden }
```

- 여기서도 첫 번째 원소를 지정하고, 시퀀스의 한 원소로부터 다음 원소를 계산하는 방법을 제공함으로써 시퀀스를 만든다.  
  `any()`를 `find()`로 바꾸면 원하는 디렉토리를 찾을 수도 있다. 이렇게 시퀀스를 사용하면 조건을 만족하는 디렉토리를  
  찾은 뒤에는 더 이상 상위 디렉토리를 뒤지지 않는다.

---
