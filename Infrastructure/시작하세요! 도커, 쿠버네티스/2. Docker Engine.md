# Docker Engine

## Docker image, container

### Docker image

- 이미지는 컨테이너를 생성할 때 필요한 요소로 VM을 생성할 때 사용하는 iso 파일과 비슷하다. 이미지는 여러 개의 계층으로 구성된 binary  
  파일로 존재하고, 컨테이너를 생성하고 실행할 때 read only로 사용된다.

### Docker container

- Docker image는 Ubuntu, CentOS 등의 기본적인 linux OS부터 Apache web server, MySQL 등의 각종 애플리케이션,  
  Hadoop이나 Spark 등의 빅데이터 분석 도구까지 갖가지 종류가 있다. 이러한 이미지로 컨테이너를 생성하면 해당 이미지의 목적에 맞는  
  파일이 들어 있는 file system과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립적인 공간이 생성되고, 이를 바로 docker  
  container라고 부른다. 대부분의 docker container는 생성될 때 사용된 docker image의 종류에 따라 각각 알맞은 설정과 파일을  
  가지기에 docker image의 목적에 맞도록 사용되는 것이 일반적이다.

- 컨테이너는 이미지를 read only로 사용하되 이미지에서 변경된 사항만 컨테이너 계층에 저장하므로 컨테이너에서 무슨 일을 하든 원래 이미지는  
  영향을 받지 않는다. 또한 생성된 각 컨테이너는 각기 독립된 file system을 제공받으며 호스트와 분리되어 있으므로 특정 컨테이너에서  
  어떤 애플리케이션을 설치하거나 삭제해도 다른 컨테이너와 host는 변화가 없다.

---

## Docker volume

- Docker image로 컨테이너를 생성하면 이미지는 read-only가 되며 컨테이너의 변경 사항만 별도로 저장해 각 컨테이너의 정보를 보존한다.

- 이미 생성된 이미지는 어떠한 경우로도 변경되지 않으며, 컨테이너 계층에 원래 이미지에서 변경된 file system 등을 저장한다.  
  예를 들어 이미지가 mysql을 갖고 있다면 이 mysql에 저장되는 데이터들은 컨테이너 계층에 저장된다는 것이다.

- 따라서 만약 mysql 컨테이너를 삭제하면 컨테이너 계층에 저장된 모든 데이터가 함께 삭제된다. 즉, 데이터베이스 데이터도 모두 삭제된다는  
  것이다. 이를 방지하기 위해 데이터를 persistent한 데이터로 활용할 수 있는 방법이 몇 가지 있다. 그 중 가장 활용하기 쉬운 방법이  
  volume을 사용하는 것이다.

- Volume을 활용하는 여러 가지 방법을 보자.

### 호스트 volume 공유

- MySQL의 경우, 데이터베이스 내의 데이터는 모두 `/var/lib/mysql`에 저장된다. 아래 명령어를 보자.

```sh
docker run -d \
-v /home/some_db:/var/lib/mysql \
mysql:5.7
```

- 위 명령어에는 `-v` flag가 추가되었고, 그 값을 `/home/some_db:/var/lib/mysql`로 지정했다.  
  이는 host의 `/home/some_db` 디렉토리와 컨테이너의 `/var/lib/mysql` 디렉토리를 공유한다는 뜻이다.  
  즉 `[host의 공유 디렉토리]:[컨테이너의 공유 디렉토리]`의 형식을 가진다.

- 이렇게 `-v` flag를 써서 디렉토리를 호스트와 공유하면 `/var/lib/mysql` 디렉토리는 호스트의 `/home/some_db` 디렉토리와  
  동기화되는 것이 아니라, 완전히 같은 디렉토리가 된다.

- `-v` 옵션은 디렉토리가 아니라 파일 단위의 공유도 가능하다.

- `-v` 옵션에 지정한 host의 공유 디렉토리가 없다면 새롭게 생성되어 사용되고, 이미 존재한다면 컨테이너 디렉토리 자체가 덮어씌워진다.  
  즉 `-v`를 통합 host volume 공유는 호스트의 디렉토리를 컨테이너의 디렉토리에 mount하는 것이다.

### Volume container

- Volume을 사용하는 두 번째 방법으로 `-v` option에 volume을 사용하는 컨테이너를 다른 컨테이너와 공유하도록 할 수 있다.  
  컨테이너를 생성할 때 `--volumes-from` option을 설정하면 `-v` 또는 `--volume` option이 적용된 컨테이너의 volume  
  디렉토리를 공유할 수 있다. 그러나 이는 직접 volume을 공유하는 것이 아닌 `-v` option을 적용한 컨테이너를 통해 공유하게 된다.

- 여러 개의 컨테이너가 동일한 컨테이너에 대해 `--volumes-from` 옵션을 사용함으로써 volume을 공유하도록 할 수도 있다.  
  이러한 구조를 활용하면 host에서 volume만 공유하고, 별도의 역할은 담당하지 않는 일명 "Volume container로 활용하는 것도  
  가능하다. 즉 volume을 사용하려는 컨테이너에 `-v` option 대신 `--volumes--from` option을 사용함으로써 volume  
  container에 연결헤 데이터를 간접적으로 공유받는 방식이다.

### Docker volume

- 세 번째로 `docker volume` 명령어가 있다. 이는 docker 자체에서 제공하는 volume 기능을 활용해 데이터를 보존하는 방법이다.

- Volume을 다루는 명령어는 `docker volume`으로 시작하며 `docker volume create`로 volume을 생성한다.

  ```sh
  docker volume create myvolume
  ```

- Volume을 생성할 때는 plugin driver를 설정해 여러 종류의 storage backend를 사용할 수 있지만, 여기서는 기본적으로 제공되는  
  driver인 local을 사용하도록 해보자. 이 volume은 local host에 저장되며, docker engine에 의해 생성되고 삭제된다.

- 위에서 만든 myvolume을 사용하는 컨테이너를 생성할 때, `-v` option과는 다르게 `[volume명]:[컨테이너 공유 디렉토리]`의 형식을  
  사용해야 한다.

  ```sh
  docker run  -i -t --name myvolume_1 \
  -v myvolume:/root/ \
  ubuntu:latest
  ```

- Docker volume도 여러 개의 컨테이너가 공유해 사용할 수 있다.

- Volume은 디렉토리 하나에 상응하는 단위로, docker engine에서 관리한다. Docker volume도 host volume 공유와 마찬가지로  
  host에 저장함으로써 데이터를 보존하지만, 파일이 실제로 어디에 저장되는지는 사용자가 알 필요가 없다.

> `docker inspect` 명령어로 파악할 수 있다.

- 지금까지 volume 공유를 통한 데이터 저장에 대해 보았는데, 이처럼 컨테이너가 아닌 외부에 데이터를 저장하고 컨테이너는 그 데이터로  
  동작하도록 설계하는 것을 stateless container라 한다. 컨테이너 자체는 상태가 없고, 모든 상태를 결정하는 데이터를 외부로부터  
  제공받기 때문이다. 이와 반대로 컨테이너가 데이터를 저장하고 있어 상태가 있으면 stateful container라 하는데, stateful container는  
  컨테이너 자체에서 데이터를 보관하므로 지양하는 것이 좋다.

---
