# 함수, 변수, 클래스

## 기본 요소: 함수와 변수

- 코틀린으로 함수 만들기

```kt
fun main(args: Array<String>) {
    println("Hello, world!")
}
```

- 함수 선언 시 fun 키워드 사용
- 파라미터명 뒤에 해당 파라미터의 타입 지정
- 함수를 최상위 수준에 정의할 수 있다. 즉, Java와 달리 **꼭 클래스 안에 함수를 넣어야 할 필요가 없다.**
- 배열도 일반적인 클래스와 마찬가지다. **코틀린에는 Java와 달리 배열 처리를 위한 문법이 따로 없다.**
- `System.out.println()` 대신 `println()`을 쓴다.  
  코틀린 표준 라이브러리는 여러 가지 표준 Java 라이브러리 함수를 간결하게 사용할 수 있도록 감싼  
  Wrapper를 제공한다. `println()`도 그들 중 하나다.
- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 `;`를 붙이지 않아도 된다.

### 함수

- 위에서 본 코드는 아무런 값도 반환하지 않는 함수이다. 만약 반환할 값이 있는 함수라면  
  반환 타입은 함수 선언의 파라미터 목록의 닫는 괄호 뒤에 `:`를 기준자로 선언한다.

```kt
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
    // Java의 return a > b ? a : b; 와 동일
}
```

- 위 코드를 보면, if가 값을 만들어내는 _문장_ 이 아니고, 결과를 만드는 _식_ 으로 쓰였다.  
  코틀린에서 if는 식이지 문이 아니다. 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에  
  참여할 수 있는 반면, 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며  
  아무런 값을 만들어내지 않는다는 차이가 있다. Java에서는 모든 제어 구조가 문인 반면,  
  코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.

- 반면, 대입문은 Java에서는 식이었으나 코틀린에서는 문이 됐다. 그로 인해 Java와 달리  
  코틀린에서는 대입식과 비교식을 바꿔 써서 버그가 생기는 경우가 없다.

#### 식이 본문인 함수

- 방금 본 함수를 아래처럼 간결하게 표현할 수 있다. 함수 본문이 if 식 하나로만 되어 있기에  
  함수 몸체를 뜻하는 중괄호를 제거하고, return 키워드를 제거하면서 `=`를 붙이면 된다.

```kt
fun max(a: Int, b: Int):Int = if (a > b) a else b
```

- 본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라 하며, 등호와 식으로 이뤄진 함수를  
  **식이 본문인 함수**라 한다.

- 코틀린에서는 식이 본문인 함수가 자주 쓰인다. 그런 함수의 본문 식에는 단순한 산술식이나  
  함수 호출식 뿐만 아니라, if, when, try 등의 더 복잡한 식도 자주 쓰인다.

- 반환 타입을 생략하면 `max()`를 더 간략하게 만들 수 있다.

```kt
fun max(a: Int, b: Int) = if (a > b) a else b
```

- 여기서 반환 타입을 생략할 수 있는 이유는 **식이 본문인 함수의 경우, 굳이 사용자가 반환 타입을**  
  **적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정하기 때문**이다.  
  이렇게 컴파일러가 타입을 분석해 프로그래머 대신 구성 요소의 타입을 정해주는 기능을 **타입 추론(Type Inference)** 라 한다.

- **반환 타입의 생략은 식이 본문인 함수에서만 가능**하다. 블록이 본문인 함수가 값을 반환한다면  
  반드시 반환 타입을 지정하고, return문을 사용해 반환 값을 명시해줘야 한다.

### 변수

- Java에서는 변수를 선언할 때 타입이 맨 앞에 온다. 하지만 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.  
  타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없다.  
  그런 이유로 코틀린에서는 키워드로 변수 선언을 시작하는 대신, **변수명 뒤에 타입을 명시하거나 생략하게 허용**한다.

```kt
val question = "Life, the universe, and everything."
val answer = 42
```

- 위 코드에서는 두 변수 모두 타입이 생략되어 있지만, 아래처럼 타입을 명시해줘도 된다.

```kt
val answer: Int = 42
```

- 식이 본문인 함수와 마찬가지로 타입을 명시적으로 지정하지 않으면 컴파일러가 초기화 식을  
  분석해서 초기화 식의 타입을 변수 타입으로 지정한다.  
  참고로 부동소수점(floating point) 상수를 사용한다면 변수 타입은 `Double`이 된다.

- 만약 초기화를 하지 않고 변수를 선언만 하려면 반드시 타입을 명시해줘야 한다.

```kt
val answer: Int
//..
answer = 42
```

#### 변경 가능한 변수와 변경 불가능한 변수

- 변수 선언 시 사용하는 키워드는 두 가지가 있다.

  - `val`(value의 약자): 변경 불가능한(immutable) 참조를 저장하는 변수다.  
    val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다. Java의 final 변수와 같다.
  - `var`(variable의 약자): 변경 가능한(mutable) 참조다. 이런 변수의 값은 바뀔 수 있다.  
    Java의 일반 변수에 해당한다.

- 기본적으로는 **모든 변수를 val을 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때만 var로 변경하자.**  
  변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합헤 사용하면 코드가 함수형 코드에  
  가까워진다.

- val 변수는 블록을 실행할 때 정확히 단 한 번만 초기화돼야 한다.  
  하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면  
  조건에 따라 val 값을 다른 여러 값으로 초기화할 수 있다.

```kt
val message: String
if(canPerformOperation()) {
    message = "Success"
    //..
} else {
    message = "Failure"
    //..
}
```

- **val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.**  
  예를 들어, 아래 코드는 완전히 올바른 코드다.

```kt
val languages = arrayListOf("Java")
languages.add("Kotlin") // 참조가 가리키는 객체 내부 변경
```

- var 키워드를 사용하면 변수의 값을 변경할 수 있지만, 여전히 변수의 타입은 고정된다.

```kt
// 컴파일 불가한 코드
var answer = 42
answer = "No answer"
```

- 위 코드가 컴파일에 실패하는 이유는 컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의  
  타입을 추론하며, 변수 선언 이후 변수에 재대입이 이뤄질 때는 이미 추론한 변수의 타입을  
  염두에 두고 대입문의 타입을 검사하기 때문이다.

- 어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로  
  변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형변환(coerce)해야 한다.

### 문자열 템플릿

```kt
val name = "World!"
println("Hello $name")
// Hello World!
```

- 위 코드는 **문자열 템플릿(String Template)** 이라는 기능을 보여준다.  
  Java의 문자열 접합 연산(`"Hello " + name`)과 동일한 기능을 하지만 더 간결하다.  
  물론 컴파일러가 각 식을 정적으로 검사하기에, 존재하지 않는 변수를 문자열 템플릿에  
  사용하면 당연히 컴파일 오류가 발생한다.

- 만약 `$`를 사용하고 싶다면 `\`를 사용해 escape 시켜야 한다.  
  또한 식을 사용하고 싶다면 `${식}`으로 쓰면 된다.

```kt
val money = 4.0
println("I only have \$$money") // I only have $4.0

println("Result of foo.bar() is ${foo.bar()}")
```

- 중괄호로 둘러싼 식 안에서는 큰 따옴표를 사용할 수도 있다.

```kt
fun main(args: Array<String>) {
    println("Hello, ${if (args.size > 0) args[0] else "someone"}!")
}
```

---
