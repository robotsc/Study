# Context

- 서버는 개별 요청에 따라 metadata 처리를 위한 방법이 필요하다. 해당 metadata는 요청을 정확히 처리하기 위해 필요한 metadata와  
  요청 처리를 중단해야 하는 시점에 대한 metadata의 두 가지로 일반적으로 분류된다. 예를 들어 HTTP 서버는 microservice의 구성으로  
  요청 chain을 식별하기 위해 trace ID의 사용을 원할 수 있다. 또한 처리 시간이 너무 오래 걸린다면 다른 microservice에 대한 요청을  
  마무리하는 타이머를 설정할 수 있다. 많은 언어들은 이와 같은 정보를 저장하기 위해 threadlocal 변수를 사용하고, 특정 OS의 스레드  
  실행에 데이터를 연결한다. Goroutine은 값을 찾을 때 사용하는 고유 식별자를 가지지 않기 때문에 Go에서는 이러한 방식으로 처리가  
  불가하다.

- Go는 위 문제를 context라는 구성으로 해결한다. 정확히 사용하는 방법을 보도록 하자.

## Context 소개

- Context는 언어의 새로운 기능이 아니라 단순히 `context` 패키지에 정의된 `Context` 인터페이스를 만족하는 인스턴스일 뿐이다.  
  관용적 Go는 함수 파라미터를 통해 명시적으로 데이터를 전달하는 것을 권장한다. Context도 마찬가지이다. 함수에 대한 또다른 파라미터일 뿐이다.  
  Go는 함수에서 마지막에 반환하는 것은 error라는 관례가 있는 것처럼, 프로그램을 통해 명시적으로 전달되는 함수의 첫 번째 파라미터로써  
  context를 사용한다. 일반적으로 변수명은 ctx를 사용한다.

```go
func logic(ctx context.Context, info string) (string, error) {
	// some things
	return "", nil
}
```

- `Context` 인터페이스를 정의하는 것 외에도 `context` 패키지에는 `Context`를 생성하고 wrapping하기 위한 여러 factory 함수들이  
  포함되어 있다. CLI의 진입점과 같이 기존 context가 없는 경우에는 `context.Background()`를 사용해 초기 context를 만든다.  
  그리고 이 함수는 `context.Context` 타입의 변수를 반환한다.

- 비어 있는 `Context`에 대해 metadata를 추가할 때마다 `context` 패키지에 있는 factory 함수들 중 하나를 사용해 기존 context를 wrapping한다.

```go
ctx := context.Background()
result, err := logic(ctx, "a string")
```

> `context.TODO()`라는 함수도 비어 있는 `context.Context` 변수를 생성해 반환한다. 이 함수는 개발 중 임시로 사용해야 한다.  
> context가 어디서 와야 할지, 어떻게 사용되어야 할지에 대한 확신이 없다면 코드에 실제 내용이 놓여질 자리에 `context.TODO()`를  
> 사용하자. 프로덕션 코드에는 `context.TODO()`가 포함되어 있어서는 안된다.

- HTTP 서버를 작성할 때 middleware 계층에서 최상위 `http.Handler`로 context를 전달하거나 획득하기 위해 꽤 많은 패턴들이 사용된다.  
  하지만 context는 `net/http` 패키지가 생성된 한참 후에 Go API에 추가되었다. 하위 호환성을 보장해야 하기 때문에 `context.Context`  
  파라미터를 추가하기 위해 `http.Handler` 인터페이스를 변경할 방법이 없었다.

- 호환성 보장에 대한 약속을 지키기 위해 기존 타입에 새로운 메소드를 추가하는 식으로 변경되었으며, 이 결과 `http.Request`에는 2개의  
  context와 관련된 메소드가 있다.

  - `Context()`: 요청과 연관된 `context.Context`를 반환한다.
  - `WithContext()`: `context.Context`를 인자로 받고, 제공된 `context.Context`를 예전 요청 상태 정보들과 결합해  
    새로운 `http.Request`를 반환한다.

- 일반적인 패턴을 하나 봐보자.

```go
func Middleware(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		// ctx로 작업을 wrapping한다.
		r = r.WithContext(ctx)
		handler.ServeHTTP(w, r)
	})
}
```

- handler에 도달하면 `Context()` 메소드로 요청에서 context를 추출하고 첫 번째 파라미터로 context와 함께 비즈니스 로직을 호출할 수 있다.

```go
func handler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	err := r.ParseForm()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	data := r.FormValue("data")
	result, err := logic(ctx, data)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}
	w.Write([]byte(result))
}
```

- `WithContext()` 메소드를 사용해야 하는 또다른 상황이 있는데, Go 애플리케이션에서 다른 HTTP service로 HTTP 호출을 할 때이다.  
  Middleware를 통해 context를 전달하는 경우와 같이 `WithContext()`를 사용해 외부로 나가는 요청에 대해 context를 생성할 수 있다.

```go
type ServiceCaller struct {
	client *http.Client
}

func (sc ServiceCaller) callAnotherService(ctx context.Context, data string) (string, error) {
	req, err := http.NewRequest(http.MethodGet, "some.url", nil)
	if err != nil {
		return "", err
	}

	req = req.WithContext(ctx)
	resp, err := sc.client.Do(req)
	if err != nil {
		return "", err
	}

	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("unexpected status code %d", resp.StatusCode)
	}

	// 응답 처리
	id, err := processResponse(resp.Body)
	return id, err
}
```

---
