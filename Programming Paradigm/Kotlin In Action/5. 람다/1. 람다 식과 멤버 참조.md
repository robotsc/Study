# 람다 식과 멤버 참조

## 람다 소개: 코드 블록을 함수 인자로 넘기기

- _"이벤트가 발생하면 이 핸들러를 실행하자"_ 또는 _"데이터 구조의 모든 원소에 이 연산을 적용하자"_ 와 같은  
  생각을 코드로 표현하기 위해 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야 하는 경우가 자주 있다.  
  예전에 Java에서는 무명 내부 클래스를 사용해 이런 목적을 달성했다. 무명 내부 클래스를 사용하면 코드를  
  함수에 넘기거나 변수에 저장할 수 있기는 하지만, 상당히 번거롭다.

- 이와 달리 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택함으로써 이 문제를 해결했다.  
  클래스를 선언하고, 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접  
  다른 함수에 전달할 수 있다. 람다 식을 사용하면 코드가 더욱 간결해진다. 람다 식을 사용하면 함수를  
  선언할 필요가 없고, 코드 블록을 함수의 인자로 전달할 수 있다.

- 예제를 하나 보자. 버튼 클릭에 따른 동작을 정의하고 싶다. 그런 경우 클릭 이벤트를 처리하는 리스너를 추가한다.  
  버튼 클릭 리스너는 `onClick()` 메소드가 들어있는 `OnClickListener`를 구현해야 한다.

```java
button.setOnClickListener(new OnClickListener() {
  @Override public void onClick(View view) {
    //..
  }
});
```

- 위 코드는 Java 방식이다. 무명 내부 클래스를 선언해야 하기 때문에 코드가 번잡스러워졌다. 이와 비슷한 작업을  
  많이 수행해야 하는 경우, 그런 번잡함은 난잡함으로 변해 개발자를 괴롭힌다. 클릭 시 벌어질 동작을 간단히  
  기술할 수 있는 표기법이 있다면 이런 불필요한 코드를 제거할 수 있을 것이다. 코틀린에서는 Java8과 마찬가지로  
  람다를 쓸 수 있다.

```kt
button.setOnClickListener { /* 클릭 시 수행할 동작 */ }
```

- 이 코틀린 코드는 앞서 본 Java 무명 클래스와 같은 역할을 하지만, 훨씬 더 간결하고 읽기 쉽다.  
  이 예제는 람다를 메소드가 하나뿐인 무명 객체 대신 사용할 수 있다는 사실을 보여준다.

---

## 람다와 컬렉션

- 코드에서 중복을 제거하는 것은 프로그래밍 스타일을 개선하는 중요한 방법 중 하나다.  
  컬렉션을 다룰 때 수행하는 대부분의 작업은 몇 가지 일반적인 패턴에 속한다. 따라서 그런 패턴은  
  라이브러리 내에 있어야 한다. 하지만 람다가 없다면 컬렉션을 편리하게 처리할 수 있는 좋은 라이브러리를  
  제공하기 어렵다. 그런 이유로 Java8 이전에는 Java에서 쓰기 편한 컬렉션 라이브러리가 적었으며, 그에  
  따라 Java 개발자들은 필요한 컬렉션 기능을 직접 작성하곤 했다.

- 사람의 이름과 나이를 저장하는 `Person` 클래스를 사용해보자.

```kt
data class Person(val name: String, val age: Int)
```

- `Person`들로 이뤄진 리스트가 있고, 그중에 가장 나이가 많은 사람을 찾고 싶다. 람다를 사용해본 경험이  
  없는 개발자라면 루프를 써서 직접 검색을 구현했을 것이다.

```kt
fun findTheOldest(people: List<Person>) {
  val maxAge = 0
  var theOldest: Person? = null
  for(person in people) {
    if(person.age > maxAge) {
      maxAge = person.age
      theOldest = person
    }
  }
  println(theOldest)
}
```

- 이 루프는 작성하기 쉽지만, 상당히 많은 코드가 들어있기 때문에 작성하다 실수를 저지르기도 쉽다.  
  예를 들어, 비교 연산자를 잘못 사용하면 최대값 대신 최소값을 찾게 된다.

- 코틀린에서는 더 좋은 방법이 있다. 라이브러리 함수를 쓰는 것이다.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.maxBy { it.age })
```

- 모든 컬렉션에 대해 `maxBy()` 함수를 호출할 수 있다. `maxBy()`는 가장 큰 원소를 찾기 위해 비교에 사용할  
  값을 돌려주는 함수를 인자로 받는다. `{ it.age }`는 바로 비교에 사용할 값을 돌려주는 함수다. 이 코드는 컬렉션의  
  원소를 인자로 받아서 비교에 사용할 값을 반환한다. 이 예시에서는 컬렉션의 원소가 `Person` 객체였으므로 이 함수가  
  반환하는 값은 `Person` 객체의 age 필드에 저장된 나이 정보다.

- 이런 식으로 단지 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있다.

```kt
people.maxBy(Person::age)
```

---

## 람다 식의 문법

- 람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다. 람다를 따로 선언해서 변수에 저장할 수도 있다.  
  하지만 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다.

- 코틀린 람다식은 항상 중괄호(`{}`)로 둘러싸여 있다. 인자 목록 주변에 괄호 또한 없다.  
  화살표(`->`)가 인자 목록과 람다의 본문을 구별해준다.

- 람다 식을 변수에 저장할 수도 있다. 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다.  
  (변수명 뒤에 괄호를 놓고, 그 안에 필요한 인자를 넣어 람다를 호출할 수 있다.)

```kt
val sum = { x: Int, y: Int -> x + y }
println(sum(1, 2)) // 3
```

- 원한다면 람다식을 직접 호출할 수도 있다.

```kt
{ println(42) }()
// 42
```

- 하지만 이와 같은 구문은 읽기 어렵고, 그다지 쓸모도 없다. 굳이 람다를 만들자마자 바로 호출하느니, 람다 본문을  
  직접 실행하는 편이 낫다. 이렇게 코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 `run()`을 사용한다.  
  run은 인자로 받은 람다를 실행해주는 라이브러리 함수다.

```kt
run { println(42) }
// 42
```

- 실행 시점에 코틀린 람다 호출에는 아무런 부가 비용이 들지 않으며, 프로그램의 기본 구성 요소와 비슷한 성능을 낸다.  
  사람 목록에서 가장 연장자를 찾는 코드를 다시 보자.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.maxBy { it.age })
```

- 위 코드에서 코틀린이 코트를 줄여 쓸 수 있게 제공했던 기능을 제거하고, 정식으로 람다를 작성하면 아래와 같다.

```kt
println(people.maxBy({ p: Person -> p.age }))
```

- 여기서 어떤 일이 벌어지고 있는지 더 명확히 알 수 있다. 중괄호 안에 있는 코드는 람다 식이고, 그 람다식을  
  `maxBy()`에 넘긴다. 람다 식은 `Person` 타입의 값을 인자로 받아 인자의 age를 반환한다.

- 하지만 이 코드는 번잡하다. 우선 구분자가 너무 많이 쓰여서 가독성이 떨어진다. 그리고 컴파일러가 문맥으로부터  
  유추할 수 있는 인자 타입을 굳이 적을 필요는 없다. 마지막으로 인자가 단 하나뿐인 경우, 굳이 인자에 이름을  
  붙이지 않아도 된다.

- 이런 개선을 적용해보자. 먼저 중괄호부터 시작해보자. 코틀린에는 함수 호출 시 맨 뒤에 있는 인자가  
  람다 식이라면, 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다. 이 예시에서는 람다가 유일한  
  인자이므로 마지막 인자이기도 하다.

```kt
people.maxBy() { p: Person -> p.age }
```

- 이 코드처럼 람다가 어떤 함수의 유일한 인자이고, 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다.

```kt
people.maxBy { p: Person -> p.age }
```

- 이 세가지 형태는 모두 같은 뜻이지만, 가장 마지막 문장이 읽기 제일 쉽다. 람다가 함수의 유일한 인자라면 분명  
  괄호 없이 람다를 바로 쓰기를 원할 것이다. 인자가 여럿 있는 경우에는 람다를 밖으로 빼낼 수도 있고, 람다를 괄호 안에  
  유지해서 함수의 인자임을 분명하게 할 수도 있다. 두 방식 모두 정당하다. 둘 이상의 람다를 인자로 받는 함수라고 해도  
  인자 목록의 맨 마지막 람다만 밖으로 뺄 수 있다. 따라서 그런 경우에는 괄호를 사용하는 일반적인 함수 호출 구문을  
  사용하는 편이 낫다.

- 이 세 가지 방식을 더 복잡한 함수 호출에 적용한 모습을 보기 위해 이전에 봤던 `joinToString()` 메소드를 보자.  
  코틀린 표준 라이브러리에도 `joinToString()`이라는 함수가 있지만, 표준 라이브러리의 `joinToString()`은  
  맨 마지막 인자로 함수를 받는다는 차이가 있다. 리스트의 원소를 `toString()`이 아닌 다른 방식을 통해 문자열로  
  변환하고 싶은 경우에 이 인자를 활용한다.

```kt
val people = listOf(Person("Alice", 29), Person("Bob", 31))
val names = people.joinToString(
  separator = " ",
  transform = { p: Person -> p.name })
println(names)
// Alice Bob
```

- 이 함수 호출에서 함수를 괄호 밖으로 빼낸 모습은 아래와 같다.

```kt
val names = people.joinToString(" ") { p: Person -> p.name }
```

- 아래처럼 파라미터 타입을 생략해 더 간단히 할 수 있다.

```kt
val names = people.joinToString(" ") { p -> p.name }
```

- 로컬 변수처럼 컴파일러는 람다 파라미터의 타입 또한 추론해낼 수 있다. 따라서 파라미터 타입을 따로 명시할 필요가 없다.  
  이전에 본 `maxBy()`의 경우, 파라미터의 타입은 항상 컬렉션 원소의 타입과 같다. 컴파일러는 `Person` 타입의 객체가  
  들어 있는 컬렉션에 대해 `maxBy()`를 호출한다는 사실을 알고 있으므로 람다의 파라미터도 `Person`이라는 사실을  
  이해할 수 있다.

> - 컴파일러가 람다 파라미터의 타입을 추론하지 못하는 경우도 있다.

- 파라미터 중 일부의 타입은 지정하고 나머지 파라미터는 타입을 지정하지 않고 이름만 남겨둬도 된다.  
  컴파일러가 파라미터 타입 중 일부를 추론하지 못하거나, 타입 정보가 코드를 읽을 때 도움이 된다면  
  그렇게 일부 타입만 표시하면 편하다.

- 마지막으로 람다의 파라미터명을 디폴트 이름인 it으로 바꾸면 람다식을 더 간단히 만들 수 있다.  
  람다의 파라미터가 하나뿐이고, 그 타입을 컴파일러가 추론할 수 있을 때 it을 쓸 수 있다.

```kt
val names = people.joinToString(" ") { it.name }
```

- 람다 파라미터명을 따로 지정하지 않은 경우에만 it이라는 이름이 자동으로 만들어진다.

> - it을 사용하는 관습은 코드를 아주 간단하게 만들어주지만, 남용해서는 안된다.  
>   특히 람다 안에 또다른 람다가 중첩되는 경우에는 it보다는 각 람다의 파라미터를 명시하는 게 낫다.  
>   파라미터를 명시하지 않으면 각각의 it이 가리키는 파라미터가 어떤 람다에 속했는지 파악하기  
>   어려울 수 있다. 문맥에서 람다 파라미터의 의미나 파라미터 타입을 쉽게 알 수 없는 경우에도  
>   파라미터를 명시적으로 선언하면 도움이 된다.

- 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않는다.  
  따라서 반드시 파라미터 타입을 명시해야 한다.

```kt
val getAge = { p: Person -> p.age }
people.maxBy(getAge)
```

- 지금까지는 한 문장(식 또는 명령)으로만 이뤄진 작은 람다만을 봤다.  
  본문이 여러 줄로 이뤄진 경우, 본문의 맨 마지막에 있는 식이 람다의 결과값이 된다.

```kt
val sum = { x: Int, y: Int ->
    println("Computing the sum of $x and $y")
    x + y
}

println(sum(1, 2))
// Computing the sum of 1 and 2
// 3
```

---

## 현재 영역에 있는 변수에 접근하기

- Java 메소드 안에서 무명 내부 클래스를 정의할 때, 메소드의 지역 변수를 무명 내부 클래스에서  
  사용할 수 있다. 람다 안에서도 같은 일을 할 수 있다. 람다를 함수 안에서 정의하면, 함수의  
  파라미터뿐 아니라 람다 정의에 앞에 선언된 지역 변수까지 람다에서 모두 사용할 수 있다.

- 이런 기능을 보기 위해 `forEach()` 표준 함수를 사용해보자. `forEach()`는 가장 기본적인  
  컬렉션 조작 함수 중 하나다. `forEach()`는 컬렉션의 모든 원소에 대해 람다를 호출해준다.  
  `forEach()`는 일반적인 for문보다 훨씬 강력하지만, 그렇다고 다른 장점이 많지는 않다.  
  따라서 기존 for loop을 모두 `forEach()`로 바꿀 필요는 없다.

- 아래 예시 코드는 메시지의 목록을 받아 모든 메시지에 똑같은 접두사를 붙여 출력해준다.

```kt
fun printMessageWithPrefix(messages: Collection<String>, prefix: String) {
  messages.forEach {
    // 람다 안에서 함수의 파라미터 사용
    println("$prefix $it)
  }
}
```

- Java와 다른 점 중 중요한 한 가지는 코틀린의 람다 안에서는 final 변수가 아닌 변수에도 접근할 수  
  있다는 것이다. 또한 람다 내에서 바깥의 변수를 변경해도 된다. 아래 코드는 전달받은 상태 코드 목록에  
  있는 클라이언트와 서버 오류의 횟수를 센다.

```kt
fun printProblemCounts(responses: Collection<String>) {
  var clientErrors = 0
  var serverErrors = 0
  responses.forEach {
    if(it.startsWith("4")) {
      clientErrors++
    }
    else if(it.startsWith("5")) {
      serverErrors++
    }
  }
  println("$clientErrors client errors, $serverErrors server errors")
}
```

- 코틀린에서는 Java와 달리 람다에서 람다 밖 함수에 있는 final이 아닌 변수에 접근할 수 있고, 그 변수를  
  변경할 수도 있다. 위 예시 코드의 prefix, clientErrors, serverErrors와 같이 람다 안에서  
  사용하는 외부 변수를 _'람다가 포획(capture)한 변수'_ 라 부른다.

- 기본적으로 함수 안에 정의된 지역 변수의 생명주기는 함수가 반환되면 끝난다. 하지만 어떤 함수가 자신의  
  지역 변수를 포획한 람다를 반환하거나, 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가  
  달라질 수 있다. 어떻게 이런 동작이 가능한걸까? final이 아닌 변수를 포획한 경우에는 변수를 특별한 wrapper로  
  감싸서 나중에 변경하거나 읽을 수 있게한 다음, wrapper에 대한 참조를 람다 코드와 함께 저장한다.

> - **변경 가능한 변수 포획하기: 자세한 구현 방법**
>
> - Java에서는 final 변수만 포획할 수 있다. 하지만 교묘한 속임수를 통해 변경 가능한 변수도 포획할 수 있다.  
>    그 속임수는 변경 가능한 변수를 저장하는 원소가 단 하나뿐인 배열을 선언하거나, 변경 가능한 변수를 필드로 하는  
>    함수를 선언하는 것이다.(안에 들어 있는 원소는 변경 가능할지라도 배열이나 클래스의 인스턴스에 대한 참조를  
>   final로 만들면 포획이 가능하다.) 이런 속임수를 코틀린으로 작성하면 아래와 같다.
>
> ```kt
> class Ref<T>(var value: T)
>
> val counter = Ref(0)
> val inc = { counter.value++ }
> ```
>
> - 실제 코드에서는 이런 wrapper를 만들지 않아도 된다. 대신, 변수를 직접 바꾼다.
>
> ```kt
> var counter = 0
> val inc = { counter++ }
> ```
>
> - 이 코틀린 코드가 어떻게 작동할까? 첫 번째 예시에서는 두 번째 예시가 작동하는 내부 모습을 보여준다.  
>   람다가 final 변수(val)를 포획하면, Java와 마찬가지로 그 변수의 값이 복사된다. 하지만 람다가  
>   변경 가능한 변수(var)를 포획하면 변수를 `Ref`의 인스턴스에 넣는다. 그 `Ref` 인스턴스에 대한 참조를  
>   final로 만들면 쉽게 포획할 수 있고, 람다 안에서는 `Ref` 인스턴스의 필드를 변경할 수 있다.

- 한 가지 꼭 알아둬야 할 함정이 있다. 람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우,  
  함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다. 예를 들어, 아래 코드는 버튼 클릭 횟수를 제대로 셀 수 없다.

```kt
fun tryToCountButtonClicks(button: Button): Int {
    var clicks = 0
    button.onClick { clicks++ }
    return clicks
}
```

- 이 함수는 항상 0을 반환한다. `onClick()` 핸들러는 호출될 때마다 clicks의 값을 증가시키지만, 그 값의 변경을  
  관찰할 수는 없다. 핸들러는 `tryToCountButtonClicks()`가 clicks를 반환한 다음에 호출되기 때문이다.  
  이 함수를 제대로 구현하려면 클릭 횟수를 세는 카운터 변수를 함수의 내부가 아니라 클래스의 프로퍼티나 전역  
  프로퍼티 등의 위치로 빼내서 나중에 변수 변화를 살펴볼 수 있게 해야 한다.

---

## 멤버 참조

- 람다를 사용해 코드 블록을 다른 함수에게 인자로 넘기는 방법을 살펴봤다. 하지만 넘기려는 코드가 이미 함수로  
  선언되어 있는 경우에는 어떻게 해야 할까? 물론 그 함수를 호출하는 람다를 만들면 된다. 하지만 이는 중복이다.

- 코틀린에서는 Java8과 마찬가지로 함수를 값으로 바꿀 수 있다. 이때, 이중 콜론(`::`)을 사용한다.

```kt
val getAge = Person::age
```

- `::`를 사용하는 식을 **멤버 참조(Member Reference)** 라 한다. 멤버 참조는 프로퍼티나 메소드를 단 하나만  
  호출하는 함수 값을 만들어준다. 위의 `Person::age`와 같은 역할을 하는 람다식은 아래와 같다.

```kt
val getAge = { person: Person -> person.age }
```

- 참조 대상이 함수인지 프로퍼티인지는 관계없이, 멤버 참조 뒤에는 괄호를 넣으면 안된다.

- 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다. 따라서 아래 예시처럼 그 둘을 자유롭게 바꿔 쓸 수 있다.

```kt
people.maxBy(Person::age)
people.maxBy { p -> p.age }
people.maxBy { it.age }
```

- 최상위에 선언되었고 다른 클래스의 멤버가 아닌 함수나 프로퍼티를 참조할 수도 있다.

```kt
fun salute() = println("Salute!")

run(::salute) // 최상위 함수 참조
// Salute!
```

- 클래스명을 생략하고 `::`로 참조를 바로 시작했다. `::salute`라는 멤버 참조를 람다를 인자로 받는 `run()`  
  라이브러리 함수에 넘겼다.

- 람다가 인자가 여럿인 다른 함수에게 작업을 위임하는 경우, 람다를 정의하지 않고 직접 위임 함수에 대한 참조를 제공하면 편리하다.

```kt
// sendEmail에게 작업 위임
val action = { person: Person, message: String -> sendEmail(person, message) }

// 람다 대신 멤버 참조 사용 가능
val nextAction = ::sendEmail
```

- 생성자 참조(Constructor Reference)를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다.  
  `::` 뒤에 클래스명을 넣으면 생성자 참조를 만들 수 있다.

```kt
data class Person(val name: String, val age: Int)

// client
val createPerson = ::Person
val p = createPerson("Alice", 29)
println(p) // Person(name=Alice, age=29)
```

- 확장 함수도 멤버 함수와 똑같은 방식으로 참조할 수 있다.

```kt
fun Person.isAdult() = age >= 21

val predicate = Person::isAdult
```

- `isAdult()`는 `Person`의 멤버가 아니고 확장 함수다. 그렇지만 `isAdult()`를 호출할 때  
  `person.isAdult()`로 인스턴스 멤버 호출 구문을 쓸 수 있는 것처럼 `Person::isAdult`로  
  멤버 참조 구문을 사용해 이 확장 함수에 대한 참조를 얻을 수 있다.

> - **바운드 멤버 참조(Bound Member Reference)**
>
> - 코틀린 1.0에서는 클래스의 메소드나 프로퍼티에 대한 참조를 얻은 다음에 그 참조를 호출할 때 항상  
>   인스턴스 객체를 제공해야 했다. 코틀린 1.1부터는 바운드 멤버 참조를 지원한다. 바운드 멤버 참조를 사용하면  
>   멤버 참조를 생성할 때 클래스 인스턴스를 함께 저장한 다음, 나중에 그 인스턴스에 대해 멤버를 호출해준다.  
>   따라서 호출 시 수신 대상 객체를 별도로 지정해 줄 필요가 없다.
>
> ```kt
> val p1 = Person("Alice", 29)
> val personAgeFunction1 = Person::age
> println(personAgeFunction1(p1)) // 29
>
> // Using Bound Member Reference
> val p2 = Person("Alice", 29)
> val personAgeFunction2 = p2::age
> println(personAgeFunction2()) // 29
> ```
>
> - 여기서 `personAgeFunction1()`은 인자가 하나이지만, `personAgeFunction2()`는 인자가 없는  
>   함수라는 점에 유의하자. 코틀린 1.0에서는 `p::age` 대신에 `{ p.age }`라고 직접 객체의 프로퍼티를  
>   돌려주는 람다를 만들어야만 한다.

---
