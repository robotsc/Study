# Distributed Email Service

- 이번 장에서는 Gmail, Outlook, Yahoo Mail과 같이 대형 규모의 이메일 서비스를 설계해보자.  
  인터넷 자체가 성장해가면서 이메일 서비스의 수요도 나날이 증가하고 있다. 2020년 Gmail은 활성 사용자 수가 18억명에 달했고,  
  Outlook은 전 세계에서 400만명에 달한다.

## 문제 이해 및 설계 범위 확정

- 최근 몇년간 이메일 서비스들은 점점 더 복잡해져왔고, 규모도 커져갔다. 현대 이메일 서비스는 많은 기능들은 가진 굉장히 복잡한 시스템이다.  
  따라서 설계를 하기 전 먼저 집중적으로 볼 기능들 및 요구사항들을 파악해보자.

### 기능적 요구사항

- 사용자 수: 10억명
- 이메일 전송 및 수신
- 모든 이메일 조회
- 읽음, 읽지 않음의 상태에 따른 이메일 필터링
- 주제, 발신자, 내용으로 이메일 검색
- Anti-spam, Anti-virus
- 클라이언트와 서버 사이의 소통으로는 HTTP가 사용된다.
- 이메일은 첨부 파일이 있을 수 있다.

### 비 기능적 요구사항

- Reliability: 이메일 데이터가 누락되면 안된다.
- Availability: 이메일과 사용자 데이터는 가용성을 보장하기 위해 여러 개의 node들로 자동으로 복제되어야 한다. 또한 시스템은 부분 장애가 있더라도  
  계속해서 동작할 수 있어야 한다.
- Scalability: 사용자 수가 증가하고 이메일의 수가 증가해도 시스템은 이를 잘 처리할 수 있어야 한다. 그리고 사용자 수, 이메일 수가 많아짐에 따라  
  시스템의 성능이 낮아지면 안된다.
- Flexibility, extensibility: 유연하고 확장성이 뛰어난 시스템은 새로운 컴포넌트들을 추가해 새로운 기능을 추가하거나 성능을 향상시키는 등의  
  작업을 쉽게 할 수 있게 한다. POP, IMAP 등 전통적인 이메일 프로토콜들은 굉장히 제한된 기능들만 제공한다. 따라서 유연성과 확장성을 보장하기 위해  
  이러한 이메일 프로토콜 외에 직접 프로토콜을 정의해 사용해야 할 수도 있을 것이다.

### 각종 추정치 계산

- 다양한 추정치들을 계산해 규모를 파악하고, 이를 설계하면서 발생할 수 있는 문제점들을 미리 파악해보자.

  - 10억명의 사용자
  - 한 사람이 하루에 발신하는 이메일이 10개라고 가정하면, 이메일을 전송하는 QPS는 `10^9 * 10 / 10^5 = 100,000`이다.
  - 한 사람이 하루에 수신하는 이메일이 40개라 가정하고, 이메일 metadata의 평균 크기가 50KB라고 가정하자.  
    Metadata는 첨부 파일을 제외한 이메일에 관련된 모든 나머지 정보들을 말한다.
  - Metadata가 저장소에 저장된다 해보자. 1년의 metadata를 유지하기 위해 필요한 저장 공간은 아래와 같다.  
    `10억명의 사용자 * 매일 40개 이메일 * 365일 * 50KB = 730PB`
  - 전체 이메일 중 20%가 첨부파일이 있으며, 첨부파일들의 평균 크기는 500KB라고 가정하자.
  - 1년의 첨부 파일들을 유지하기 위해 필요한 저장 공간은 아래와 같다.
    `10억명의 사용자 * 매일 40개의 이메일 * 365일 * 20% * 500KB = 1,460PB`

- 위 추정치들을 통해 이 시스템에서 굉장히 많은 양의 데이터를 다뤄야함은 분명한 사실이 되었다. 따라서 분산 데이터베이스를 사용하는 것이 좋을 것 같다.

---

## 개략적 설계안 제시 및 동의 구하기

- 이번에는 우선 이메일 서버들의 기초들을 먼저 다루고, 이메일 서버들이 시간이 지남에 따라 어떻게 변화해왔는지 알아보자.  
  그 후에 분산 이메일 서버들의 개략적 설계안을 살펴볼 것이다. 아래의 내용들을 순서대로 다뤄볼 것이다.

  - 이메일 기초 지식
  - 전통적인 메일 서버들
  - 분산 메일 서버들

### 이메일 기초 지식

- 이메일을 수신, 발신하는 데에 사용되는 이메일 프로토콜들은 여러 가지가 있다. 역사적으로 대부분의 메일 서버들은 POP, IMAP, SMTP와 같은  
  이메일 프로토콜들을 사용해왔다.

#### 이메일 프로토콜

- **SMTP(Simple Mail Transfer Protocol)**

  - 하나의 메일 서버로부터 다른 메일 서버에게 이메일을 **발신** 할 때 사용되는 표준 프로토콜

- **POP(Post Office Protocol)**

  - 이메일 서버로부터 이메일을 **수신** 할 때 사용되는 표준 프로토콜
  - 이메일이 클라이언트로부터 받아지면 메일 서버에서 해당 이메일은 삭제된다. 즉 이메일을 하나의 모바일 기기 또는 컴퓨터에서만 볼 수 있는 것이다.
  - POP는 클라이언트가 이메일의 모든 내용을 전부 다운로드하도록 요구한다. 따라서 이메일이 대량의 첨부 파일을 갖고 있다면 시간이 오래 걸릴 수 있다.

- **IMAP(Internet Mail Access Protocol)**

  - 이메일 서버로부터 이메일을 **수신** 할 때 사용되는 표준 프로토콜(POP, IMAP 모두 이메일 수신 표준 프로토콜이다.)
  - 이메일을 읽기 위해 클라이언트는 외부의 메일 서버와 connection을 맺고, 이 connection으로 데이터를 수신해간다.
  - IMAP은 클릭 시에만 이메일을 다운로드하며, 다운로드 해도 메일 서버에 있는 해당 이메일이 지워지지 않는다.
  - IMAP은 개인 이메일 계정을 위해 가장 많이 사용되는 프로토콜이다.
  - 이메일을 클릭하기 전까지는 오직 header 정보만을 가져오기 때문에 connection이 느려도 잘 동작한다.

- **HTTPS** : 기술적으로 봤을 때 메일만을 위한 프로토콜은 절대 아니지만, 웹 기반의 이메일에 사용하기에 좋다.  
  예를 들어 Microsoft Outlook은 모바일 기기와 HTTPS로 소통하며 ActiveSync라는 직접 만든 메일 프로토콜을 사용한다.

#### DNS(Domain Name Service)

- DNS 서버는 수신자의 도메인 중 MX record(mail exchanger record)를 lookup하기 위해 사용된다.  
  CLI에서 `gmail.com`에 대해 dnslookup을 수행하면 아래와 같이 MX record들을 볼 수 있다.

![picture 14](/images/SDI2_DES_1.png)

- Priority number는 설정 값으로 이 숫자가 낮을 수록 더 높은 선호도를 가지게 된다. 따라서 위 예시에서는 priority가 5인  
  `gmail-smtp-in.l.google.com`이 가장 처음으로 사용된다. 이메일을 발신하는 메일 서버는 이 메일 서버에게 처음으로 연결을 시도하고,  
  메일을 보내려고 할 것이다. 만약 connection이 실패하면 다음으로 낮은 priority를 갖는 `alt1.gmail-smtp-in.l.google.com`으로  
  연결을 시도하고, 메일 전달을 수행하려 할 것이다.

#### 첨부 파일

- 이메일의 첨부 파일들은 일반적으로 base64 encoding되어 이메일 메시지와 함께 전송된다. 그리고 일반적으로는 첨부 파일에 용량 제한이 있다.  
  예를 들어 2021년 6월 기준 Outlook은 20MB, Gmail은 25MB로 첨부 파일의 크기를 제한한다. 이 제한 수치는 당연히 설정 가능하며  
  개인 계정, 회사 계정 등 계정 종류에 따라 다르기도 하다. 그리고 첨부 파일을 인터넷 상으로 전달하게끔 하는 데에는  
  MIME(Multi-purpose Internet Mail Extension) 형식이 사용된다.

### 전통적인 메일 서버들

- 분산 메일 서버들을 다루기 전, 간단히 전통적인 메일 서버들은 어떻게 동작했는지를 파악해보자.  
  여기서 전통적인 메일 서버들이라 함은 제한된 이메일 사용자들이 있고, 일반적으로 1대의 서버로 동작하는 이메일 시스템을 말한다.

#### 전통적인 메일 서버의 아키텍쳐

- 아래 그림은 전통적인 메일 서버를 사용해 Alice가 Bob에게 이메일을 발송했을 때의 과정을 나타낸다.

![picture 15](/images/SDI2_DES_2.png)

- 총 4 단계를 거치게 된다.

  - (1) Alice는 자신의 Outlook 클라이언트에 로그인하고 이메일을 작성한 후 "전송" 버튼을 클릭한다.  
    해당 이메일은 먼저 Outlook 메일 서버에게 전송된다. 이때 Outlook 클라이언트와 메일 서버 사이에는 SMTP 프로토콜이 사용된다.
  - (2) Outlook 메일 서버는 수신자의 SMTP 서버를 찾기 위해 DNS query를 수행한다. 이 경우, Gmail의 SMTP 서버를 DNS query하는  
    것이다. 다음으로 Gmail 메일 서버로 이메일을 전송한다. 이 때에도 Outlook mail server, Gmail mail server 사이에는  
    SMTP 프로토콜아 사용된다.
  - (3) Gmail 서버는 이메일을 저장하고 Bob(수신자)에게 보여지게 한다.
  - (4) Gmail client는 Bob이 Gmail에 로그인했을 때 IMAP/POP 서버로부터 새로운 이메일을 수신해간다.

##### 저장소

- 전통적인 메일 서버들에서 이메일들은 local file directory들에 보관되었고, 각 email은 고유의 이름을 가진 별도의 파일로 저장되었다.  
  각 사용자는 자신만의 user directory를 가지며, 이 directory 내에 설정 데이터 및 이메일들을 보관했다.  
  이런 식으로 메일 서버에 이메일들을 보관하는 데에는 Maildir가 널리 사용되었다.

![picture 16](/images/SDI2_DES_3.png)

- 이렇게 file directory를 사용하는 방식은 사용자 수가 적었을 때는 잘 동작했으나, 수억개의 이메일들을 수신하고 백업하기에는 적합하지 않았다.  
  이메일 양이 계속해서 증가함에 따라 file structure도 계속 복잡해지면서 disk I/O가 병목 지점이 되었다. 또한 이렇게 local directory를  
  사용하는 방식은 고가옹셩 및 안전성 요구사항을 만족하지 못한다. Disk는 언제든제 훼손될 수 있고 서버 자체에도 장애가 날 수 있다.

- 이메일은 1960년대에 발명된 이후 지금까지 계속해서 multimedia, threading, 검색, label 등 더 많은 다양한 기능들을 제공해가고 있지만  
  이메일 프로토콜(POP, IMAP, SMTP)들은 훨씬 이전에 발명되었기 때문에 이러한 기능들을 지원하기가 어렵다. 또한 수십억명의 사용자들을  
  지원할 수 있는 확장성 또한 갖지 못한다.

### 분산 메일 서버들

- 분산 메일 서버들은 대규모 및 안전성 등의 문제를 해결하고 현대 use case들을 지원하기 위해 설계되었다.

#### Email APIs

- 이메일 API들은 각기 다른 메일 클라이언트 혹은 이메일의 생명 주기에 따라 굉장히 다른 의미를 가질 수 있다. 예를 들어보자.

  - Native 모바일 클라이언트들을 위한 SMTP/POP/IMAP APIs
  - 발신자 및 수신자 메일 서버들 사이의 SMTP communication
  - 웹 기반의 이메일 애플리케이션들을 위한 HTTP 상의 RESTful APIs

- 이번에는 웹 기반의 이메일을 위해 사용되는 가장 중요한 API들 일부만 살펴보도록 하자. 웹 기반의 메일이 소통하는 가장 일반적인 방법은  
  HTTP 프로토콜을 사용하는 것이다.

- `POST /v1/messages`

  - To, Cc, Bcc header들에 있는 수신자들에게 이메일을 발송한다.

- `GET /v1/folders`

  - 특정 이메일 계정의 모든 폴더들을 반환한다.
  - 응답 예시:
    ```json
    [
      {
        "id": "string", // 폴더의 고유 ID
        "name": "string", // 폴더명, RFC6154에 따르면 기본 폴더들은 All, Archive, Drafts, Flagged, Junk, Sent, Trash 중 하나여야 한다.
        "user_id": "string" // 계정 소유자의 reference
      }
    ]
    ```

- `GET /v1/folders/{folder_id}/messages`

  - 특정 폴더 하위의 모든 메시지들을 반환한다. 이 API는 매우 단순한 변형임을 유의하자. 실 세계에서 이 API는 당연히 pagination을 제공해야 한다.
  - 응답: message 객체들의 리스트

- `GET /v1/messages/{message_id}`

  - 특정 메시지의 모든 정보를 조회한다. 메시지는 발신자, 수신자, 주제, body, 첨부 파일 등의 정보를 포함하는 이메일 애플리케이션을 구성하는  
    주요 building block이다.

  - 응답 예시(message 객체):

    ```json
    {
      "user_id": "string", // 계정 소유자의 reference
      "from": { "name": "string", "email": "string" }, // 발신자 정보
      "to": [{ "name": "string", "email": "string" }], // 수신자(들)의 정보
      "subject": "string", // 이메일의 주제
      "body": "string", // 이메일의 body
      "is_read": false // 해당 메시지가 읽어졌는지의 여부
    }
    ```

#### 분산 메일 서버 아키텍쳐

- 사용자 수가 적은 이메일 서버를 구축하는 것은 쉽지만, 한 대의 서버를 넘어 확장하기에는 어렵다. 이는 전통적인 메일 서버들이 단 1대의  
  서버를 사용하게끔 설계되어있기 때문이다. 여러 서버들 사이에 데이터를 동기화하는 것은 어려울 수 있고, 수신자의 메일 서버가 해당 이메일을  
  spam으로 잘못 분류하는 것을 방지하는 것도 꽤나 어렵다. 이번에는 클라우드 기술을 사용해 이를 어떻게 쉽게 구현할 수 있는지 살펴보자.  
  아래는 분산 메일 서버의 개략적인 설계안이다.

![picture 17](/images/SDI2_DES_4.png)

- 각 컴포넌트들을 자세히 살펴보자.

  - **Webmail** : 사용자들은 이메일을 발신, 수신하기 위해 웹 브라우저를 사용한다.
  - **Web Servers** : Web server는 로그인, 회원 가입, 사용자 프로필 등의 기능을 제공하는 public-facing request/response  
    서비스이다. 이번 장의 설계에서 이메일 발신, 이메일 폴더 조회, 폴더 내의 모든 이메일 조회 등의 모든 이메일 관련 API 요청들도  
    이 web server가 처리하게 된다.
  - **Real-time Servers** : Real-time server는 새로운 이메일에 대한 알림을 실시간으로 클라이언트에게 push한다.  
    이 real-time server는 persistent connection을 유지해야 하기 때문에 stateful server들이다. 실시간 커뮤니케이선을 지원하기  
    위해 long polling, WebSocket 등의 선택지가 있지만 WebSocket이 더 우아하다. 다만 브라우저 호환성이 문제가 될 수 있다.  
    이를 위해 가능할 때는 WebSocket connection을 사용하고, fallback으로 long polling을 사용하도록 할 수 있을 것이다.
  - **Metadata Database** : 이 데이터베이스는 메일 주제, body, 발신자, 수신자 등 이메일의 metadata를 저장한다.
  - **Attachment Store** : Attachment store는 첨부 파일들을 저장하며, 이에는 Amazon S3와 같은 object storage가 적격이다.  
    S3는 확장성이 뛰어난 스토리지 인프라를 가지며 이미지, 비디오, 파일 등의 대용량 파일들을 저장하기 위한 서비스이다.  
    이전에 요구사항에서 첨부 파일은 25MB의 제한을 가질 수 있다고 했다. 반면 Cassandra와 같은 NoSQL column-family database는  
    아래의 이유들 때문에 좋은 선택지가 아닐 수 있다.

    - Cassandra는 blob data type을 지원하고 이론적으로 blob은 2GB까지 다룰 수 있지만, 실질적인 제한은 1MB도 안된다.
    - Cassandra에 첨부 파일들을 저장하면 row 하나가 너무 많은 저장 공간을 차지하기에 메모리를 사용하는 caching을 할 수 없다.

  - **Distributed Cache** : 가장 최신의 이메일들은 클라이언트들이 가장 많이 접하게 되기 때문에 최신 이메일들을 caching하게 되면  
    load time을 효과적으로 개선할 수 있을 것이다. 이를 위해 list 등의 다양한 기능을 제공하며 확장성이 뛰어난 Redis를 사용할 수 있을 것이다.
  - **Search store** : Search store는 분산 document store이며 굉장히 빠른 full-text 검색을 지원하는 inverted index라는  
    자료구조를 사용한다.

- 이제 분산 메일 서버를 구축하기 위한 주요 컴포넌트들을 파악했으니, 아래의 대표적인 2개 workflow들을 다뤄보자.

  - 이메일 발신 flow
  - 이메일 수신 flow

#### 이메일 발신 flow

![picture 18](/images/SDI2_DES_5.png)

- 각 단계를 살펴보자.

  - (1) 사용자는 이메일을 작성하고 "전송" 버튼을 클릭한다. 이메일 전송 요청은 load balancer에 먼저 전달된다.
  - (2) Load balancer는 rate limit을 수행하고 조건에 부합하면 web server에 요청을 전달한다.
  - (3) Web server는 아래의 사항들을 처리한다.

    - 기본적인 이메일 검증 작업. 들어오는 이메일 각각에 대해 크기 제한 등 사전에 정의된 규칙들을 부합하는기 검사한다.
    - 수신자의 이메일 주소 domain이 발신자와 동일한지 검사한다. 만약 동일하다면 웹 서버는 이메일 데이터의 spam 유무 및 바이러스를 검사하고,  
      이를 통과한다면 이메일 데이터는 발신자의 "Sent folder"에 보관되고, 수신자의 "Inbox folder"에도 저장된다.  
      수신자는 이메일을 RESTful API를 사용해 직접 조회할 수 있고, (4)번 단계로 넘어갈 필요가 없다.

  - (4) Message queues

    - (4.a) 이메일에 대한 기본 검증이 성공하면 이메일 데이터는 Outgoing queue로 전달된다. 만약 첨부 파일의 크기가 너무 커서  
      queue에 보관되지 못한다면, 첨부 파일만 따로 object storage에 보관하고 queue에 보관할 메시지에 해당 첨부 파일의 reference만 추가한다.
    - (4.b) 이메일에 대한 기본 검증이 실패하면 해당 이메일은 Error queue로 전달된다.

  - (5) SMTP outgoing worker들은 Outgoing queue로부터 메시지들을 pull하고 각 메시지들이 spam이 아니며 바이러스가 없음을 확인한다.
  - (6) (5)를 통과한 이메일은 Storage layer의 "Sent folder" 내에 저장된다.
  - (7) SMTP outgoing worker가 수신자의 메일 서버로 이메일을 전송한다.

- Outgoing queue 내의 각 메시지는 이메일을 만들어내기 위한 모든 metadata를 포함한다. 그리고 분산 message queue는 이메일 처리 과정을  
  비동기적으로 수행하기 위해 매우 중요한 컴포넌트이다. SMTP outgoing worker들을 web server와 decoupling함으로써 이 둘을 독립적으로  
  상황에 따라 확장할 수 있다.

- 이때 Outgoing queue의 크기를 상세히 모니터링해야 한다. 만약 queue에 많은 이메일들이 적재되어 있다면 원인을 찾아 해결해야 한다.  
  아래와 같은 원인들이 있을 수 있다.

  - 수신자의 메일 서버가 장애가 난 상황. 이 경우 시간이 더 지난 후애 이메일 전송을 재시도해야 한다. 이를 위한 전략으로 exponential  
    backoff가 좋은 선택지가 될 것이다.

  - 메시지를 보내기 위한 SMTP outgoing worker(outgoing queue 입장에서의 consumer)들이 부족한 상황. 이 경우 처리 시간을 단축시키기  
    위해 consumer들을 더 추가할 수 있다.

#### 이메일 수신 flow

- 아래 그림은 이메일을 수신하는 flow를 나타낸다.

![picture 19](/images/SDI2_DES_6.png)

- 이번에도 마찬가지로 각 과정을 살펴보자.

  - (1) 새롭게 수신되는 이메일들은 먼저 SMTP load balancer에 전달된다.
  - (2) Load balancer는 트래픽을 SMTP server들로 분산시킨다. 이메일 수신 정책(email acceptance policy)는 SMTP-connection  
    level에서 설정하고 적용될 수 있다. 예를 들어 부적절한 이메일은 불필요한 이메일 처리 과정을 피하기 위해 무시되도록 할 수 있다.
  - (3) 이메일의 첨부 파일이 queue에 넣기에 너무 크다면, 해당 첨부 파일만 따로 S3와 같은 object storage에 저장시킬 수 있다.
  - (4) 이메일들은 Incoming email queue로 전달된다. 이 queue는 Mail processing worker들과 SMTP server들을 decoupling 시켜  
    각자가 독립적으로 확장될 수 있게 한다. 또한 queue server는 수신되는 이메일의 개수가 갑자기 치솟았을 때 일종의 buffer의 역할도 수행한다.
  - (5) Mail processing worker들은 spam 메일 필터링, 바이러스 검출 등 다양한 작업들을 수행하는 책임을 가진다.  
    이러한 작업들을 통과한 이메일들 만이 다음 단계를 이어나갈 수 있다.
  - (6) 이메일은 Mail storage, Cache, Object data store에 저장된다.
  - (7) 수신자가 활성 상태라면 이메일은 Real-time server들로 전달된다.
  - (8) Real-time server들은 WebSocket server로 클라이언트들이 새로운 이메일들을 실시간으로 수신할 수 있도록 한다.
  - (9) 비활성 사용자들의 경우이다. 이메일들은 우선 Storage layer에 저장된다. 해당 사용자가 다시 활성 상태로 돌아온다면 웹메일 클라이언트들은  
    RESTful API를 통해 web server에게 새로운 이메일을 달라는 요청을 보낸다.
  - (10) Web server들은 Storage layer로부터 새로운 이메일들을 pull하고, 클라이언트에게 반환한다.

---
