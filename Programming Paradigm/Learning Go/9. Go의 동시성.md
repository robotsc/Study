# Go의 동시성

- **동시성**은 단일 프로세스를 독립적인 컴포넌트로 분리하고 해당 컴포넌트가 안전하게 데이터를 공유하는 방법을 지정하는 컴퓨터 과학 용어이다.  
  대부분의 언어는 lock을 획득해 공유 데이터를 접근하는 OS level 스레드를 사용하는 라이브러리를 통해 동시성을 제공한다. 하지만 Go는 다르다.  
  Go는 주요 동시성 모델로 CSP(Communicating Sequential Processes, 순차적 프로세스들의 통신)에 기반한다.

- 이번 장에서는 Go네애 동시성을 위한 중추인 goroutine, channel, select 키워드의 기능을 빠르게 살펴보는 것으로 시작해보자.  
  그리고 몇 몇의 일반적인 Go 동시성 패턴을 살펴보고 low-level 접근 방식이 더 나은 상황도 다뤄보자.

---

## 동시성 사용 지점

- 동시성을 사용하기 전, 먼저 프로그램이 동시성을 사용했을 때 얻을 수 있는 이점이 있는지 확신할 수 있어야 한다. 새로운 Go 개발자가 동시성을  
  실험으로 시작하면 아래의 과정을 거치는 경향이 있다.

  - (1) 동시성은 굉장하다. Goroutine 내에 모든 것을 넣자!
  - (2) 내 프로그램은 더 빨라지지 않는다. 따라서 channel에 버퍼를 추가하자.
  - (3) 내 channel은 blocking되고 deadlock에 빠진다. 따라서 정말 큰 버퍼를 사용하는 buffered channel을 사용하자.
  - (4) 내 channel은 여전히 blocking된다. Mutex를 사용하자!
  - (5) 모르겠다. 그냥 동시성 안써야겠다.

- 사람들은 동시성을 가진 프로그램은 더 빠르게 수행된다고 믿기에 동시성을 사용한다. 하지만 모든 경우가 이렇지는 않다. 더 많은 동시성은 어떤 것을  
  자동으로 더 빠르게 만들지는 않으며 코드를 이해하기 더 어렵게 만들 수 있다. 먼저 **동시성(concurrency)과 병렬성(parallelism)은 다르다** 는  
  것을 먼저 이해하는 것이 중요하다. 동시성은 해결하고자 하는 문제를 더 나은 구조로 만들기 위한 도구이다. 동시성 코드가 병렬적으로(동시에)  
  실행되는지의 여부는 하드웨어와 알고리즘이 허용하는지의 여부에 따라 다르다.

- 넓은 의미로 모든 프로그램은 같은 3단계 처리를 따른다. 이 단계는 데이터를 받고, 데이터를 변환하고, 결과를 출력하는 것을 의미한다.  
  프로그램에서 동시성 사용의 여부는 각 단계에 따른 데이터 흐름에 따라 결정된다. 한 단계의 데이터가 다른 단계를 진행하는 데 필요하지 않기에  
  두 단계가 동시성을 가질 수 있는 경우도 있고, 다른 하나의 결과에 의존해 두 단계가 순차적으로 실행되어야 하는 경우도 있다.  
  독립적으로 수행할 수 있는 여러 처리로부터 데이터를 결합시키길 원한다면 동시성을 사용하자.

- 또다른 중요한 점은 동시성은 동시에 실행되는 작업들이 시간이 얼마 걸리지 않을 때 사용하기 좋지 않다는 것이다. 동시성은 공짜가 아니다.  
  많은 일반적인 in-memory 알고리즘은 너무 빨라 동시성을 통해 값을 전달하는 오버헤드가 병렬적으로 동시성 코드를 수행해 얻는 잠재적인 시간 절약을  
  압도할 수 있다. 이래서 동시성 수행은 보통 I/O 작업을 위해 사용된다. 디스크나 네트워크로부터 읽거나 쓰는 동작은 대부분의 복잡한 in-momory의  
  처리보다 1000배 정도 느리다. 동시성이 도움이 되는지 확실치 않다면 먼저 코드를 순차적으로 구현하고, 동시성 구현과 성능을 비교하기 위한 벤치마크를  
  작성하자.

- 예시를 들어보자. 3개의 다른 웹 서비스를 호출하는 웹 서비스를 작성한다고 생각해보자. 해당 서비스 중 2곳에 데이터를 보내 결과를 받은 다음, 이 결과를  
  3번째 서비스에 전달해 결과를 반환 받을 것이다. 전체 과정은 50ms내에 완료되지 않는다면 오류를 반환해야 한다. 이 예시 상황은 서로가 상호작용 없이  
  I/O를 수행할 필요가 있는 부분과 결과를 결합하는 부분, 그리고 수행을 완료해야 하는 시간적 제약까지 있기에 동시성을 사용하기 좋다.

---

## Goroutine

- Goroutine은 Go의 동시성 모델의 핵심 개념이다. Goroutine을 이해하기 위해 용어 몇 개를 정의해보자.

  - Process: Process는 컴퓨터의 OS에서 수행 중인 프로그램의 인스턴스이다. OS는 프로세스와 메모리 같은 자원을 연결시키고, 다른 프로세스에서  
    접근할 수 없도록 보장한다.

  - Thread: Process는 하나 이상의 thread로 구성된다. Thread는 OS가 주어진 시간 동안 수행하는 실행의 단위이다. Process 내의 thread는  
    자원들의 접근을 공유한다. CPU는 코어 수에 따라 하나 이상의 thread를 동시에 실행시킬 수 있다. OS의 역할 중 하나는 모든 process가  
    수행되는 기회를 얻을 수 있도록 보장하기 위해 thread를 CPU에 scheduling하는 것이다.

- Goroutine은 Go runtime에서 관리하는 가벼운 process이다. Go 프로그램이 실행되면, Go runtime은 여러 개의 thread를 생성하고 프로그램을  
  실행시키기 위한 단일 goroutine을 시작한다. 프로그램에서 생성된 goroutine은 초기에 생성된 하나를 포함해 OS에서 CPU 코어 수에 따라 thread를  
  scheduling 하듯이 Go runtime scheduler가 자동으로 thread들을 할당한다. 이미 OS가 thread, process를 관리하는 scheduler를 이미  
  갖고 있기 때문에, 이런 작업이 추가 작업으로 보일 수 있으나 아래의 몇 가지 이점들이 있다.

  - Goroutine의 생성은 OS level 자원을 생성하지 않기에 thread 생성보다 빠르다.
  - Goroutine의 초기 스택 크기는 thread의 스택 크기보다 작으며, 필요하다면 늘릴 수 있다. 그리고 goroutine은 메모리를 더 효율적으로  
    사용할 수 있게 한다.
  - Goroutine 간의 전환은 완전히 process 내에서 일어나기에 상대적으로 느린 OS syscall을 회피한다. 따라서 thread 사이의 전환보다 빠르다.
  - Scheduler가 Go process의 일부이기 때문에 scheduling 결정을 최적화할 수 있다. Scheduler는 네트워크를 확인하는 작업과 함께 수행돼  
    I/O가 blocking되어 goroutine이 scheduling되지 않는 시점을 감지할 수 있다. 그리고 GC와 통합되어 작업이 go process에 할당된  
    모든 OS thread에서 균형을 이루도록 한다.

- 이런 장점들이 Go 프로그램이 수백 개, 수천 개, 수만 개의 동시 goroutine을 생성할 수 있도록 한다.

- Goroutine은 함수의 실행 전에 go 키워드를 사용함으로써 시작된다. 다른 함수들과 같이 상태를 초기화하기 위해 파라미터를 전달할 수도 있다.  
  하지만 해당 함수에서 반환되는 모든 값들은 무시된다.

- 모든 함수는 goroutine으로 실행될 수 있다.

---

## Channel

- Goroutine은 channel을 통해 서로 통신한다. Slice, map과 같이 channel은 `make()` 함수를 사용해 생성할 수 있는 내장 타입이다.

```go
ch := make(chan int)
```

- Map과 같이 channel은 참조 타입이다. Channel을 함수로 전달하면 실제로는 channel에 대한 포인터를 전달하는 것이다.  
  그리고 channel의 zero value는 nil이다.

### Read, write, buffering

- Channel과 상호작용하기 위해서는 `<-` 연산자를 사용한다.

```go
a := <-ch // ch에서 값을 읽어와 a에 할당
ch <- b // b의 값을 ch에 저장
```

- Channel에 쓰여진 각 값은 한 번에 하나씩 읽을 수 있다. 여러 개의 goroutine들이 같은 channel에 대해 읽기를 수행하면 channel에 쓰인  
  하나의 값은 여러 개의 goroutine들 중 단 하나만이 읽을 수 있다.

- 하나의 goroutine으로 같은 channel에 대해 읽고 쓰는 작업을 하는 경우는 드물다.

- Channel을 변수나 항목에 할당하거나 함수로 전달한다면, goroutine이 channel에서 읽기만 가능하다는 것을 나타내기 위해 `ch <-chan int`와  
  같이 선언하자. 만약 쓰기만 가능하다면 `ch chan<- int`와 같이 선언하면 된다. 이렇게 하면 Go 컴파일러가 channel을 함수에서 읽기 전용, 혹은  
  쓰기 전용으로만 사용하도록 할 수 있다.

- 기본적으로 channel에는 buffer가 없다. Buffer가 없는 열린 channel에는 쓰기를 할 때마다 다른 goroutine에서 같은 channel을 읽을 때까지  
  해당 goroutine을 일시 중지한다. 비슷하게 buffer가 없는 열린 channel에 읽기를 수행하면 다른 goroutine에서 같은 channel에 쓰기를 할 때까지  
  일시 중지한다. 이는 적어도 두 개의 수행 중인 goroutine 없이는 buffer가 없는 channel로 읽기나 쓰기를 할 수 없다는 뜻이다.

- Go는 buffered channel(buffer가 있는 channel)도 갖고 있다. 이러한 channel은 blocking 없이 제한된 크기의 buffer를 가진다.  
  Channel에서 읽어가는 것 없이 buffer가 다 채워지면, channel이 읽어질 때까지 쓰기를 수행하는 goroutine은 일시 중지된다.  
  가득 찬 buffer를 가진 channel에 쓰는 것과 같이, 비어 있는 buffer를 가진 channel로 읽기를 수행해도 blocking된다.

- Buffer가 있는 channel은 channel을 생성할 때 buffer의 capacity를 지정해 만들 수 있다.

```go
ch := make(chan int, 10)
```

- 내장 함수 `len()`, `cap()`은 buffer가 있는 channel 정보를 반환한다. `len()`을 이용해 현재 buffer 내에 얼마나 많은 값들이 있는지 알 수  
  있고 `cap()`을 통해 최대 buffer 크기를 가져올 수 있다. 그리고 한 번 생성한 buffer의 수용력은 변경할 수 없다.

- 대부분의 경우에는 buffer가 없는 channel을 사용한다.

### for-range와 channel

- for-range loop를 이용해 channel에서 값을 읽을 수 있다.

```go
for v := range ch {
	fmt.Println(v)
}
```

- 다른 for-range loop와 다르게 channel을 위해 선언된 값을 갖는 단일 변수만 있다. Channel이 닫히거나 break, return문에 도달할 때까지  
  loop는 지속된다.

### Channel 닫기

- Channel에 쓰기를 완료했으면 `close()` 내장 함수를 사용해 channel을 닫을 수 있다.

```go
close(ch)
```

- 일단 channel을 닫으면 이후 해당 channel에 쓰기를 시도하거나 다시 닫으려 한다면 panic이 발생한다. 반면 닫힌 channel에 읽기를 시도하는 것은  
  언제나 성공한다. Channel이 buffering되고 아직 읽어지지 않은 값이 있다면 값들은 순차적으로 반환된다. 만약 channel에 buffer가 없거나  
  해당 channel에 buffer가 있지만 더 이상 값이 없다면 해당 channel 타입의 zero value가 반환된다.

- Channel에서 값을 읽었을 때 channel이 닫혀서 zero value가 반환되는 것인지, 아니면 실제로 zero value가 저장된 값인지 파악하는 방법으로  
  comma-ok idiom을 사용할 수 있다.

```go
v, ok := <-ch
```

- ok가 true라면 channel은 열려 있는 것이고, false라면 channel이 닫혀 있는 것이다.

- Channel을 닫아야 하는 책임은 channel에 쓰기를 수행하는 goroutine에 있다. Channel을 닫는 것은 해당 channel이 닫혀지기를 기다리는  
  goroutine이 있는 경우에만 필요하다. Channel도 하나의 변수이기 때문에 Go runtime은 더 이상 사용되지 않는다는 것이 확인되면 GC로 정리한다.

- Channel은 다른 언어와 Go의 동시성 모델을 구분하는 두 가지 요소 중 하나이다. Channel을 사용하면 코드를 일련의 단계로 생각하게 하고, 데이터의  
  의존성을 명확히 해 동시성에 대해 더 쉽게 추론할 수 있도록 한다. 반면 다른 언어들은 스레드 간의 통신을 위해 전역에 공유된 상태에 의존한다.  
  이런 변경 가능한 공유 상태는 데이터가 프로그램의 전반을 흐르는 방식을 이해하기 어렵게 만들고, 결과적으로는 2개의 스레드가 실제로 독립적인지의  
  여부를 파악하기 어렵게 한다.

### Channel 동작 방식

- Channel은 읽기, 쓰기, 혹은 닫기를 할 때 각각 다른 동작을 한다.

| 연산 | Unbuffered, open          | Unbuffered, closed | Buffered, open                   | Buffered, closed           | nil       |
| ---- | ------------------------- | ------------------ | -------------------------------- | -------------------------- | --------- |
| 읽기 | 뭔가 써질 때까지 blocking | zero value         | Buffer가 빌 때까지 blocking      | Buffer에 남아 있는 값 반환 | 무한 대기 |
| 쓰기 | 뭔가 읽힐 때까지 blocking | panic              | Buffer가 가득 찰 때까지 blocking | panic                      | 무한 대기 |
| 닫기 | 정상 동작                 | panic              | 동작, 남은 값 보관               | panic                      | panic     |

- Go 프로그램이 panic 상태로 가는 것은 반드시 피해야 한다. 앞서 봤듯이 표준 패턴은 더 이상 channel에 쓸 내용이 없을 때 해당 channel에  
  쓰기를 수행하는 goroutine에서 channel을 닫도록 한다. 여러 goroutine들이 같은 channel에 쓰기를 한다면 같은 channel에 `close()`를  
  두번 호출하면 panic이 발생하기에 더 복잡해진다. 게다가 하나의 goroutine에서 channel을 닫았을 때 다른 goroutine에서 해당 channel에 쓰기를  
  수행해도 panic이 발생한다. 이 문제를 해결하기 위해서는 `sync.WaitGroup`을 사용하면 된다. 이후에 다뤄보자.

---

## select 문

- select 문은 다른 언어와 동시성 모델을 구분하는 또다른 요소이다. Select문은 Go에서 사용되는 동시성을 위한 제어 구조이며 일반적인 문제를  
  훌륭하게 해결한다. 두 개의 동시성 연산을 수행해야 한다면, 어떤 것을 먼저 실행해야 할까? 이 경우 어떤 하나를 다른 것 보다 선호하지 않는  
  경우를 starvation(기아)이라 한다.

- select 키워드는 여러 channel들 중 하나에 읽기를 하거나 쓰기를 할 수 있는 goroutine을 허용한다.

```go
select {
case v := <-ch:
	fmt.Println(v)
case v := <-ch2:
	fmt.Println(v)
case ch3 <- x:
	fmt.Println("wrote", x)
case <-ch4:
	fmt.Println("got value on ch4, but ignored it")
}
```

- select 문의 각 case는 channel에 읽기나 쓰기를 한다. 읽기나 쓰기가 가능한 case에서 해당 본문의 코드가 함께 실행된다.  
  switch와 비슷하게 select 내의 case는 자신만의 block을 생성한다.

- 여러 case에 읽거나 쓸 수 있는 channel이 있는 경우는 어떻게 될까? select의 알고리즘은 단순하다. 진행 가능한 여러 case 중 하나를  
  임의로 선택한다. 순서는 중요하지 않다. 이는 true로 해석되는 첫 번째 case를 항상 선택한느 switch문과는 많이 다르다. 또한 다른 case보다  
  선호되는 것이 없고 모두 동시에 확인되기 때문에 starvation 문제를 깔끔히 해결한다.

- select가 case를 임의로 선택하는 것의 또다른 장점은 deadlock의 가장 일반적인 원인 중 하나인 일관성 없는 순서로 lock을 획득하는 것을  
  방지할 수 있다는 것이다. 동일한 두 개의 channel을 접근하는 두 개의 goroutine이 있다면, 두 goroutine 내에서 반드시 같은 순서로  
  접근해야 deadlock에 빠지지 않는다. 즉, 두 개의 goroutine 내에 channel이 서로 기다리게 되어 어느 쪽 하나도 실행할 수 없는 상황이  
  된다는 것이다. Go의 애플리케이션에서 모든 goroutine이 deadlock에 빠진다면 Go runtime은 해당 프로그램을 제거한다.

```go
func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	go func() {
		v := 1
		ch1 <- v
		v2 := <-ch2
		fmt.Println(v, v2)
	}()
	v := 2
	ch2 <- v
	v2 := <-ch1
	fmt.Println(v, v2)
}
```

- 위 프로그램을 실행하면 아래의 에러 메시지를 볼 수 있다.

```
fatal error: all goroutines are asleep - deadlock!
```

- 위 코드는 왜 deadlock에 빠질까? 우선 `go func() { .. }`에서 시작된 goroutine에서는 ch1에 값을 넣고, ch2로부터 값을 읽으려 한다.  
  그리고 `main()`이 수행되는 goroutine에서는 반대로 ch2에 값을 넣고, ch1으로부터 값을 읽으려 한다.  
  익명 함수가 실행되는 goroutine은 ch1에서 값을 읽을 때까지 blocking되고, main goroutine은 ch2에서 값을 읽을 때까지 blocking된다.  
  즉 두 goroutine모두 blocking되어 deadlock에 빠지게 된 것이다.

- 만약 main goroutine에서 select로 channel에 접근하게 하면, deadlock을 피할 수 있다.

```go
func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)
	go func() {
		v := 1
		ch1 <- v
		v2 := <-ch2
		fmt.Println(v, v2)
	}()
	v := 2
	var v2 int
	select {
	case ch2 <- v:
	case v2 = <-ch1:
	}
	fmt.Println(v, v2)
}

// Output: 2 1
```

- 위 코드에서는 select가 진행할 수 있는 case를 확인하기에 deadlock을 피하게 된다. ch1에 값을 쓰는 것을 goroutine에서 진행했고,  
  main goroutine에서 ch1으로부터 값을 읽어 v2에 할당하는 것도 정상적으로 처리된다.

- select는 여러 channel을 통한 통신을 담당하기 때문에 종종 for loop에 embedding된다.

```go
for {
	select {
	case <-done:
		return
	case v := <-ch:
		fmt.Println(v)
	}
}
```

- 이 조합은 일반적으로 많이 쓰여 for-select loop라고볻 불린다. for-select loop를 사용할 때는 반드시 loop를 빠져나가는 방법을 포함해야 한다.

- switch문과 마찬가지로 select문은 default 절을 가질 수 있다. 또한 switch와 마찬가지로 default는 읽기와 쓰기를 할 수 있는 channel이  
  어떠한 case에도 없는 경우에 선택된다. Channel에서 비동기 읽기, 쓰기를 구현하고 싶다면 default와 함께 select를 사용하도록 하자.  
  아래 코드는 ch에 읽을 값이 없을 때 기다리지 않고 즉시 default의 내부 코드를 실행한다.

```go
select {
	case v := <-ch:
		fmt.Println("read from ch", v)
	default:
		fmt.Println("no value written to ch")
}
```

---
