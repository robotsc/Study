# 알림 시스템 설계

- Notification System(알림 시스템)은 최근 많은 프로그램이 채택한 인기 있는 기능이다.  
  이 기능을 갖춘 애플리케이션은 최신 뉴스, 제품 업데이트, 이벤트, 선물 등 고객에게 중요할 만한 정보를 비동기적으로 제공한다.  
  이 기능은 이미 우리 일상생활에 중요한 부분으로 자리잡았다. 이 시스템을 설계해보자.

- 알림 시스템은 단순히 Mobile Push Notification에 한정되지 않는다. 사실 알림 시스템은 Mobile Push Notification,  
  SMS Message, 그리고 이메일로 분류할 수 있다.

---

## 문제 이해 및 설계 범위 확정

- 이번에 설계할 알림 시스템의 세부 설계사항은 아래와 같다.

  - Soft real-time system: 알림은 가능한 한 빨리 전달돼야 하지만, 시스템에 높은 부하가 걸렸을 때 약간의 지연은 무방하다.
  - iOS, Android, Laptop/Desktop을 지원해야 한다.
  - 사용자에게 보낼 알림은 클라이언트 애플리케이션 프로그램일 수도 있고, 서버 측 스케쥴링일 수도 있다.
  - 사용자가 알림을 받지 않도록 설정하면 알림을 받지 않도록(Opt-out) 할 수 있어야 한다.
  - 하루에 1000만건의 mobile push notification, 100만건의 메시지, 500만건의 이메일을 보낼 수 있어야 한다.

---

## 개략적 설계안 제시 및 동의 구하기

- iOS, Android push notification, SMS, email을 지원하는 알림 시스템의 개략적 설계안을 보자.

  - 알림 유형별 지원 방안
  - 연락처 정보 수집 절차
  - 알림 전송 및 수신 절차

### 알림 유형별 지원 방안

- 우선 각각의 알림 메커니즘이 어떻게 동작하는지 보자.

#### iOS Push Notification

- iOS에서 푸시 알림을 보내기 위해서는 아래 그림의 3개 컴포넌트가 필요하다.

![picture 11](/images/SDI_PNS_1.png)

- 알림 제공자(provider): 알림 요청(notification request)을 만들어 APNS(Apple Push Notification Service)로 보내는 주체.  
  알림 요청을 만들려면 아래와 같은 데이터가 필요하다.

  - Device token(단말 토큰): 알림 요청을 보내는 데 필요한 고유 식별자
  - Payload: 알림 내용을 담은 JSON dictionary

  ```json
  {
    "aps": {
      "alert": {
        "title": "Game Request",
        "body": "Bob wants to play poker with you",
        "action-loc-key": "PLAY"
      },
      "badge": 1
    }
  }
  ```

- APNS: Apple이 제공하는 원격 서비스로 푸시 알림을 iOS 장치로 보내는 역할을 담당한다.
- iOS Device: 푸시 알림을 수신하는 사용자 단말이다.

#### Android Push Notification

- 안드로이드 푸시 알림도 iOS와 비슷한 절차로 전송된다.  
  APNS 대신 FCM(Firebase Cloud Messaging)을 사용한다는 점만 다르다.

![picture 12](/images/SDI_PNS_2.png)

#### SMS

- SMS 메시지를 보낼 때는 보통 Twilio, Nexmo와 같은 제3 사업자의 서비스를 많이 이용한다.  
  이런 서비스들은 대부분 상용 서비스라서 이용 요금을 내야한다.

![picture 13](/images/SDI_PNS_3.png)

#### Email

- 대부분의 회사는 고유 이메일 서버를 구축할 역량을 갖추고 있다. 그럼에도 많은 회사가 상용 이메일 서비스를 이용한다.  
  그중 유명한 서비스로 Sendgrid, Mailchimp가 있다. 전송 성공률도 높고, 데이터 분석 서비스(analytics)도 제공한다.

![picture 22](/images/SDI_PNS_4.png)

- 아래 그림은 지금까지 살펴본 알림 유형 전부를 한 시스템으로 묶은 결과이다.

![picture 15](/images/SDI_PNS_5.png)

### 연락처 정보 수집 절차

- 알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요하다. 아래 그림과 같이 사용자가 우리 앱을 설치하거나  
  처음으로 계정을 등록하면 API 서버는 해당 사용자의 정보를 수집해 데이터베이스에 저장한다.

![picture 16](/images/SDI_PNS_6.png)

- 이 데이터베이스에 연락처 정보를 저장할 테이블 구조는 아래 그림과 같다. 아래 그림은 필수 정보만 담은 개략적인 설계안으로서,  
  이메일 주소와 전화번호는 user 테이블에 저장하고, 단말 토큰은 device 테이블에 저장한다. 한 사용자가 여러 단말을 가질 수 있고,  
  알림은 모든 단말에 전송되어야 한다는 점을 고려했다.

![picture 17](/images/SDI_PNS_7.png)

### 알림 전송 및 수신 절차

- 우선 개략적인 설계안부터 살펴보고, 점차적으로 최적화해 나가보자.

#### 개략적 설계안(초안)

- 아래 그림은 개략적 설계 초안이다.

![picture 18](/images/SDI_PNS_8.png)

- 각 시스템 컴포넌트에 대해 알아보자.

  - 1부터 N까지의 서비스: 이 서비스 각각은 micro service일 수도 있고, cron job일 수도 있고, 분산 시스템 컴포넌트일 수도 있다.  
    사용자에게 납기일을 알리고자 하는 billing service, 배송 알림을 보내려는 쇼핑몰 웹사이트 등이 그 예시이다.

  - 알림 시스템(notification system): 알림 시스템은 알림의 전송, 수신 처리의 핵심이다. 우선은 1개의 서버만 사용하는 시스템이라 가정해보자.  
    이 시스템은 서비스 1~N에 알림 전송을 위한 API를 제공해야 하고, 제3자 서비스에 전달할 알림 payload를 만들어낼 수 있어야 한다.

  - 제3자 서비스(third party services): 이 서비스들은 사용자에게 알림을 실제로 전달하는 역할을 한다. 제3자 서비스와의 통합을 진행할 때  
    유의할 것은 확장성이다. 즉 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다는 뜻이다. 또 하나 고려할 것으로는, 어떤  
    서비스는 다른 시장에서는 사용할 수 없을 수도 있다는 것이다. 가령 FCM은 중국에서는 사용할 수 없다. 따라서 중국 시장에서는 Jpush, PushY와  
    같은 서비스를 사용해야만 한다.

  - iOS, android, sms, email 단말: 사용자는 자신의 단말에서 알림을 수신해야 한다.

- 위 설계안에는 몇 가지 문제점들이 있다.

  - SPOF: 알림 서비스에 서버가 하나 밖에 없다는 것은 해당 서버에 장애가 생기면 전체 서비스의 장애로 이어진다는 뜻이다.
  - 규모 확장성: 한 대의 서비스로 푸시 알림에 관련된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트들의 규모를 개별적으로 늘릴 방법이 없다.
  - 성능 병목: 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업일 수 있다. 예를 들어 HTML 페이지를 만들고 제3자 서비스의 응답을 기다리는 일은  
    시간이 많이 걸릴 가능성이 있는 작업이다. 따라서 모든 것을 하나의 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템이 과부하 상태에 빠질 수 있다.

#### 개략적 설계안(개선된 버전)

- 초안의 문제점들을 보았으니, 아래와 같은 방향으로 개선해보자.

  - 데이터베이스와 캐시를 알림 시스템의 주 서버에서 분리한다.
  - 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이뤄질 수 있도록 한다.
  - 메시지 큐를 사용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.

- 아래 그림은 위 아이디어들을 적용한 시스템 개선안을 보여준다.

![picture 21](/images/SDI_PNS_9.png)

- 1~N의 서비스: 알림 시스템 서버의 API를 통해 알림을 보낼 서비스들이다.
- 알림 서버(notification server)

  - 알림 전송 API: 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능하다.
  - 알림 검증(validation): 이메일 주소, 전화번호 등에 대한 기본적인 검증 수행
  - 데이터베이스 또는 캐시 query: 알림에 포함시킬 데이터를 가져오는 기능
  - 알림 전송: 알림 데이터를 메시지 큐에 넣는다. 이 설계안의 경우, 하나 이상의 메시지 큐를 사용하므로 알림을 병렬적으로 처리할 수 있다.

- 아래는 이메일 형태의 알림을 보내는 데 사용하는 API 예시이다.  
  `POST https://api.example.com/v/sms/send`

```json
{
  "to": [
    {
      "user_id": 123456
    }
  ],
  "from": {
    "email": "from_address@example.com"
  },
  "subject": "Hello world",
  "content": [
    {
      "type": "text/plain",
      "value": "Hello world"
    }
  ]
}
```

- 캐시(cache): 사용자 정보, 단말 정보, 알림 template 등을 캐시한다.
- 데이터베이스: 사용자, 알림, 설정 등 다양한 정보를 저장한다.
- 메시지 큐(message queue): 시스템 컴포넌트 간의 의존성을 제거하기 위해 사용한다. 다량의 알림이 전송되어야 하는 경우를 대비한 buffer의  
  역할도 한다. 이 설계안에서는 알림의 종류별로 각각 메시지 큐를 사용하였기에 제3자 서비스 가운데 하나에 장애가 발생해도 다른 종류의 알림은  
  정상 동작한다.
- 작업 서버(workers): 메시지 큐에서 전송할 알림을 꺼내 제3자 서비스로 전달하는 역할을 담당하는 서버이다.
- 제3자 서비스: APNS, FCM 등
- iOS, Android, SMS, Email 단말: 알림을 수신할 단말

- 이제 이 컴포넌트들이 어떻게 협력해 알림을 전송하는지 순서를 보자.

  - (1) API를 호출해 알림 서버로 알림을 보낸다.
  - (2) 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 등의 metadata를 cache나 database에서 가져온다.
  - (3) 알림 서버는 전송할 알림에 맞는 이벤트를 만들어 해당 이벤트를 위한 메시지 큐에 넣는다.
  - (4) 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.
  - (5) 작업 서버는 알림을 제3자 서비스로 보낸다.
  - (6) 제3자 서비스는 사용자 단말로 알림을 전송한다.

---

## 상세 설계

- 이번에는 개략적 설계안을 토대로 각 단계를 좀 더 상세히 설계해보자. 아래는 고려할 요소들이다.

  - 안정성(reliability)
  - 추가로 필요한 컴포넌트 및 고려사항: 알림 template, 알림 설정, rate limiting(전송률 제한), retry mechanism(재시도 메커니즘),  
    보안(security), 큐에 보관된 알림에 대한 모니터링 및 이벤트 추적
  - 개선된 설계안

### 안정성

- 분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위한 몇 가지 사항을 반드시 고려해야 한다.

#### 데이터 손실 방지

- 알림 전송 시스템의 가장 중요한 요구사항 가운데 하나는 **어떤 상황에서도 알림이 소실되면 안된다는 것**이다. 알림이 지연되거나 순서가 틀려도  
  괜찮지만, 사라지면 안된다는 것이다. 이 요구사항을 만족하려면 알림 시스템은 알림 데이터를 데이터베이스에 보관하고, retry mechanism을 구현해야 한다.  
  아래와 같이 notification log(알림 로그) 데이터베이스를 유지하는 것이 한 가지 방법이다.

![picture 23](/images/SDI_PNS_10.png)

#### 알림 중복 전송 방지

- 같은 알림이 여러 번 반복되는 것을 완전히 막는 것은 불가능하다. 대부분의 경우 알림은 딱 한 번만 전송되겠지만, 분산 시스템의 특성상  
  가끔은 같은 알림이 중복되어 전송되기도 할 것이다. 그 빈도를 줄이려면 중복을 탐지하는 메커니즘을 도입하고, 오류를 신중히 처리해야 한다.  
  아래는 간단한 중복 방지 처리 로직의 사례이다.

  - 보내야 할 알림이 도착하면 그 이벤트 ID를 검사해 이전에 본 적이 있는 이벤트인지 검사한다. 중복된 이벤트라면 버리고, 그렇지 않으면 알림을 발송한다.

### 추가로 필요한 컴포넌트 및 고려사항

- 지금까지 사용자 연락처 정보를 어떻게 수집하고, 알림은 어떻게 보내고 받을 것인지 살펴보았다. 그러나 알림 시스템은 사실 이보다 훨씬 복잡하다.  
  지금부터는 알림 template, 알림 설정, 이벤트 추적, 시스템 모니터링, rate limiting 등 알림 시스템 구현을 위해 필요한 추가 컴포넌트들에  
  대해 알아보자.

#### 알림 template

- 대형 알림 시스템은 하루에도 수백만 건 이상의 알림을 처리한다. 그런데 그 알림 메시지의 대부분은 형식이 비슷하다. 알림 template은 이러한  
  유사성을 고려해 알림 메시지의 모든 부분을 처음부터 다시 만들 필요가 없도록 해준다. 알림 template은 인자(parameter)나 스타일,  
  추적 링크(tracking link)를 조정하기만 하면 사전에 지정한 형식에 맞춰 알림을 만들어내는 툴이다. 아래는 간단한 예제다.

  - 본문:

    ```
    [item_name]이 입고되었습니다. [date]까지만 주문 가능합니다.
    ```

  - 타이틀(CTA: Call To Action):
    ```
    지금 [item_name]을 주문 또는 예약하세요!
    ```

- 이렇게 template을 사용하면 전송될 알림들의 형식을 일관성 있게 유지할 수 있고, 오류 가능성 뿐만 아니라 알림 작성에 드는 시간도 줄일 수 있다.

#### 알림 설정

- 사용자는 이미 너무 많은 알림을 받고 있어 쉽게 피곤함을 느낀다. 따라서 많은 웹사이트와 앱에서는 사용자가 알림 설정을 상세히 조정할 수 있도록  
  하고 있다. 이 정보는 알림 설정 테이블에 보관되며, 이 테이블에는 아마 아래와 같은 필드들이 있을 것이다.

| user_id | bigint  | 사용자 ID                                     |
| :------ | ------- | --------------------------------------------- |
| channel | varchar | 알림이 전송될 채널. 푸시 알림, 이메일, SMS 등 |
| opt_in  | boolean | 해당 채널로 알림을 받을 것인지 여부           |

- 이와 같은 설정을 도입한 뒤에는 특정 종류의 알림을 보내기 전에 반드시 해당 사용자가 해당 알림을 켜 두었는지 확인해야 한다.

#### Rate limiting

- 사용자에게 너무 많은 알림을 보내지 않도록 하는 한 가지 방법으로는 한 사용자가 받을 수 있는 알림의 빈도를 제한하는 것이다.  
  이것이 중요한 이유는 알림을 너무 많이 보내기 시작하면 사용자가 알림 기능을 아예 꺼버릴 수도 있기 때문이다.

#### Retry mechanism

- 제3자 서비스가 알림 전송에 실패하면, 해당 알림을 재시도 전용 큐에 넣는다.  
  같은 문제가 계속해서 발생하면 개발자에게 통지한다.(alert)

#### 푸시 알림과 보안

- iOS와 안드로이드 앱의 경우, 알림 전송 API는 appKey와 appSecret을 사용해 보안을 유지한다.  
  따라서 인증된(authenticated), 혹은 승인된(verified) 클라이언트만 해당 API를 사용해 알림을 보낼 수 있다.

#### 큐 모니터링

- 알림 시스템을 모니터링할 때 중요한 메트릭(metric) 하나는 큐에 쌓인 알림의 개수이다.  
  이 수가 너무 크면 작업 서버들이 이벤트를 빠르게 처리하고 있지 못하고 있다는 뜻이다.  
  그런 경우에는 작업 서버를 증설하는 게 바람직할 것이다.

#### 이벤트 추적

- 알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 등의 metric은 사용자를 이해하는 데 중요하다.  
  데이터 분석 서비스(analytics)는 보통 이벤트 추적 기능도 제공한다. 따라서 보통 알림 시스템을 만들면 데이터 분석 서비스와도  
  통합해야만 한다. 아래는 데이터 분석 서비스를 통해 추적하게 될 알림 시스템 이벤트의 예시이다.

![picture 24](/images/SDI_PNS_11.png)

### 수정된 설계안

- 지금까지 본 내용을 모두 반영해 수정한 설계안은 아래와 같다.

![picture 25](/images/SDI_PNS_12.png)

- 이전 설계안에 없던 많은 컴포넌트들이 추가된 것을 확인할 수 있다.

  - 알림 서버에 authentication과 rate limiting 기능이 추가되었다.
  - 전송 실패에 대응하기 위한 retry 기능이 추가되었다. 전송에 실패한 알림은 다시 큐에 넣고 지정된 횟수만큼 재시도한다.
  - 전송 template을 사용해 알림 생성 과정을 단순화하고, 알림 내용의 일관성을 유지한다.
  - 모니터링과 추적 시스템을 추가해 시스템 상태를 확인하고, 추후 시스템을 개선하기 쉽게 했다.

---

## 마무리

- 알림은 중요 정보를 계속 알려준다는 점에서 필수불가결한 기능이다.

- 이번 장에서 규모 확장이 쉬울 뿐 아니라 푸시 알림, SMS 메시지, 이메일 등 다양한 정보 전달 방식을 지원하는 알림 시스템을 설계해보았다.  
  시스템 컴포넌트 사이의 결합도를 낮추기 위해 메시지 큐를 적극적으로 사용했다.

- 개략적 설계안과 더불어 각 컴포넌트의 구현 방법과 최적화 기법에 대해서도 심도 있게 알아보았다. 특히 아래 주제들에 집중했다.

  - 안정성(reliability): 메시지 전송 실패율을 낮추기 위해 안정적인 retry 메커니즘을 도입했다.
  - 보안(security): 인증된 클라이언트만이 알림을 보낼 수 있도록 appKey, appSecret 등의 메커니즘을 이용했다.
  - 이벤트 추적 및 모니터링: 알림이 만들어진 후 성공적으로 전송되기까지의 과정을 추적하고 시스템 상태를 모니터링하기 위해  
    알림 전송의 각 단계마다 이벤트를 추적하고 모니터링할 수 있는 시스템을 통합했다.
  - 사용자 설정: 사용자가 알림 수신 설정을 조정할 수 있도록 했다. 따라서 알림을 보내기 전, 반드시 해당 설정을 확인하도록 시스템 설계를 변경했다.
  - rate limiting: 사용자에게 알림을 보내는 빈도(frequency)를 제한할 수 있도록 했다.

---
