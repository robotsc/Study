# Distributed Email Service

- 이번 장에서는 Gmail, Outlook, Yahoo Mail과 같이 대형 규모의 이메일 서비스를 설계해보자.  
  인터넷 자체가 성장해가면서 이메일 서비스의 수요도 나날이 증가하고 있다. 2020년 Gmail은 활성 사용자 수가 18억명에 달했고,  
  Outlook은 전 세계에서 400만명에 달한다.

## 문제 이해 및 설계 범위 확정

- 최근 몇년간 이메일 서비스들은 점점 더 복잡해져왔고, 규모도 커져갔다. 현대 이메일 서비스는 많은 기능들은 가진 굉장히 복잡한 시스템이다.  
  따라서 설계를 하기 전 먼저 집중적으로 볼 기능들 및 요구사항들을 파악해보자.

### 기능적 요구사항

- 사용자 수: 10억명
- 이메일 전송 및 수신
- 모든 이메일 조회
- 읽음, 읽지 않음의 상태에 따른 이메일 필터링
- 주제, 발신자, 내용으로 이메일 검색
- Anti-spam, Anti-virus
- 클라이언트와 서버 사이의 소통으로는 HTTP가 사용된다.
- 이메일은 첨부 파일이 있을 수 있다.

### 비 기능적 요구사항

- Reliability: 이메일 데이터가 누락되면 안된다.
- Availability: 이메일과 사용자 데이터는 가용성을 보장하기 위해 여러 개의 node들로 자동으로 복제되어야 한다. 또한 시스템은 부분 장애가 있더라도  
  계속해서 동작할 수 있어야 한다.
- Scalability: 사용자 수가 증가하고 이메일의 수가 증가해도 시스템은 이를 잘 처리할 수 있어야 한다. 그리고 사용자 수, 이메일 수가 많아짐에 따라  
  시스템의 성능이 낮아지면 안된다.
- Flexibility, extensibility: 유연하고 확장성이 뛰어난 시스템은 새로운 컴포넌트들을 추가해 새로운 기능을 추가하거나 성능을 향상시키는 등의  
  작업을 쉽게 할 수 있게 한다. POP, IMAP 등 전통적인 이메일 프로토콜들은 굉장히 제한된 기능들만 제공한다. 따라서 유연성과 확장성을 보장하기 위해  
  이러한 이메일 프로토콜 외에 직접 프로토콜을 정의해 사용해야 할 수도 있을 것이다.

### 각종 추정치 계산

- 다양한 추정치들을 계산해 규모를 파악하고, 이를 설계하면서 발생할 수 있는 문제점들을 미리 파악해보자.

  - 10억명의 사용자
  - 한 사람이 하루에 발신하는 이메일이 10개라고 가정하면, 이메일을 전송하는 QPS는 `10^9 * 10 / 10^5 = 100,000`이다.
  - 한 사람이 하루에 수신하는 이메일이 40개라 가정하고, 이메일 metadata의 평균 크기가 50KB라고 가정하자.  
    Metadata는 첨부 파일을 제외한 이메일에 관련된 모든 나머지 정보들을 말한다.
  - Metadata가 저장소에 저장된다 해보자. 1년의 metadata를 유지하기 위해 필요한 저장 공간은 아래와 같다.  
    `10억명의 사용자 * 매일 40개 이메일 * 365일 * 50KB = 730PB`
  - 전체 이메일 중 20%가 첨부파일이 있으며, 첨부파일들의 평균 크기는 500KB라고 가정하자.
  - 1년의 첨부 파일들을 유지하기 위해 필요한 저장 공간은 아래와 같다.
    `10억명의 사용자 * 매일 40개의 이메일 * 365일 * 20% * 500KB = 1,460PB`

- 위 추정치들을 통해 이 시스템에서 굉장히 많은 양의 데이터를 다뤄야함은 분명한 사실이 되었다. 따라서 분산 데이터베이스를 사용하는 것이 좋을 것 같다.

---

## 개략적 설계안 제시 및 동의 구하기

- 이번에는 우선 이메일 서버들의 기초들을 먼저 다루고, 이메일 서버들이 시간이 지남에 따라 어떻게 변화해왔는지 알아보자.  
  그 후에 분산 이메일 서버들의 개략적 설계안을 살펴볼 것이다. 아래의 내용들을 순서대로 다뤄볼 것이다.

  - 이메일 기초 지식
  - 전통적인 메일 서버들
  - 분산 메일 서버들

### 이메일 기초 지식

- 이메일을 수신, 발신하는 데에 사용되는 이메일 프로토콜들은 여러 가지가 있다. 역사적으로 대부분의 메일 서버들은 POP, IMAP, SMTP와 같은  
  이메일 프로토콜들을 사용해왔다.

#### 이메일 프로토콜

- **SMTP(Simple Mail Transfer Protocol)**

  - 하나의 메일 서버로부터 다른 메일 서버에게 이메일을 **발신** 할 때 사용되는 표준 프로토콜

- **POP(Post Office Protocol)**

  - 이메일 서버로부터 이메일을 **수신** 할 때 사용되는 표준 프로토콜
  - 이메일이 클라이언트로부터 받아지면 메일 서버에서 해당 이메일은 삭제된다. 즉 이메일을 하나의 모바일 기기 또는 컴퓨터에서만 볼 수 있는 것이다.
  - POP는 클라이언트가 이메일의 모든 내용을 전부 다운로드하도록 요구한다. 따라서 이메일이 대량의 첨부 파일을 갖고 있다면 시간이 오래 걸릴 수 있다.

- **IMAP(Internet Mail Access Protocol)**

  - 이메일 서버로부터 이메일을 **수신** 할 때 사용되는 표준 프로토콜(POP, IMAP 모두 이메일 수신 표준 프로토콜이다.)
  - 이메일을 읽기 위해 클라이언트는 외부의 메일 서버와 connection을 맺고, 이 connection으로 데이터를 수신해간다.
  - IMAP은 클릭 시에만 이메일을 다운로드하며, 다운로드 해도 메일 서버에 있는 해당 이메일이 지워지지 않는다.
  - IMAP은 개인 이메일 계정을 위해 가장 많이 사용되는 프로토콜이다.
  - 이메일을 클릭하기 전까지는 오직 header 정보만을 가져오기 때문에 connection이 느려도 잘 동작한다.

- **HTTPS** : 기술적으로 봤을 때 메일만을 위한 프로토콜은 절대 아니지만, 웹 기반의 이메일에 사용하기에 좋다.  
  예를 들어 Microsoft Outlook은 모바일 기기와 HTTPS로 소통하며 ActiveSync라는 직접 만든 메일 프로토콜을 사용한다.

#### DNS(Domain Name Service)

- DNS 서버는 수신자의 도메인 중 MX record(mail exchanger record)를 lookup하기 위해 사용된다.  
  CLI에서 `gmail.com`에 대해 dnslookup을 수행하면 아래와 같이 MX record들을 볼 수 있다.

![picture 14](/images/SDI2_DES_1.png)

- Priority number는 설정 값으로 이 숫자가 낮을 수록 더 높은 선호도를 가지게 된다. 따라서 위 예시에서는 priority가 5인  
  `gmail-smtp-in.l.google.com`이 가장 처음으로 사용된다. 이메일을 발신하는 메일 서버는 이 메일 서버에게 처음으로 연결을 시도하고,  
  메일을 보내려고 할 것이다. 만약 connection이 실패하면 다음으로 낮은 priority를 갖는 `alt1.gmail-smtp-in.l.google.com`으로  
  연결을 시도하고, 메일 전달을 수행하려 할 것이다.

#### 첨부 파일

- 이메일의 첨부 파일들은 일반적으로 base64 encoding되어 이메일 메시지와 함께 전송된다. 그리고 일반적으로는 첨부 파일에 용량 제한이 있다.  
  예를 들어 2021년 6월 기준 Outlook은 20MB, Gmail은 25MB로 첨부 파일의 크기를 제한한다. 이 제한 수치는 당연히 설정 가능하며  
  개인 계정, 회사 계정 등 계정 종류에 따라 다르기도 하다. 그리고 첨부 파일을 인터넷 상으로 전달하게끔 하는 데에는  
  MIME(Multi-purpose Internet Mail Extension) 형식이 사용된다.

### 전통적인 메일 서버들

- 분산 메일 서버들을 다루기 전, 간단히 전통적인 메일 서버들은 어떻게 동작했는지를 파악해보자.  
  여기서 전통적인 메일 서버들이라 함은 제한된 이메일 사용자들이 있고, 일반적으로 1대의 서버로 동작하는 이메일 시스템을 말한다.

#### 전통적인 메일 서버의 아키텍쳐

- 아래 그림은 전통적인 메일 서버를 사용해 Alice가 Bob에게 이메일을 발송했을 때의 과정을 나타낸다.

![picture 15](/images/SDI2_DES_2.png)

- 총 4 단계를 거치게 된다.

  - (1) Alice는 자신의 Outlook 클라이언트에 로그인하고 이메일을 작성한 후 "전송" 버튼을 클릭한다.  
    해당 이메일은 먼저 Outlook 메일 서버에게 전송된다. 이때 Outlook 클라이언트와 메일 서버 사이에는 SMTP 프로토콜이 사용된다.
  - (2) Outlook 메일 서버는 수신자의 SMTP 서버를 찾기 위해 DNS query를 수행한다. 이 경우, Gmail의 SMTP 서버를 DNS query하는  
    것이다. 다음으로 Gmail 메일 서버로 이메일을 전송한다. 이 때에도 Outlook mail server, Gmail mail server 사이에는  
    SMTP 프로토콜아 사용된다.
  - (3) Gmail 서버는 이메일을 저장하고 Bob(수신자)에게 보여지게 한다.
  - (4) Gmail client는 Bob이 Gmail에 로그인했을 때 IMAP/POP 서버로부터 새로운 이메일을 수신해간다.

##### 저장소

- 전통적인 메일 서버들에서 이메일들은 local file directory들에 보관되었고, 각 email은 고유의 이름을 가진 별도의 파일로 저장되었다.  
  각 사용자는 자신만의 user directory를 가지며, 이 directory 내에 설정 데이터 및 이메일들을 보관했다.  
  이런 식으로 메일 서버에 이메일들을 보관하는 데에는 Maildir가 널리 사용되었다.

![picture 16](/images/SDI2_DES_3.png)

- 이렇게 file directory를 사용하는 방식은 사용자 수가 적었을 때는 잘 동작했으나, 수억개의 이메일들을 수신하고 백업하기에는 적합하지 않았다.  
  이메일 양이 계속해서 증가함에 따라 file structure도 계속 복잡해지면서 disk I/O가 병목 지점이 되었다. 또한 이렇게 local directory를  
  사용하는 방식은 고가용성 및 안전성 요구사항을 만족하지 못한다. Disk는 언제든지 훼손될 수 있고 서버 자체에도 장애가 날 수 있다.

- 이메일은 1960년대에 발명된 이후 지금까지 계속해서 multimedia, threading, 검색, label 등 더 많은 다양한 기능들을 제공해가고 있지만  
  이메일 프로토콜(POP, IMAP, SMTP)들은 훨씬 이전에 발명되었기 때문에 이러한 기능들을 지원하기가 어렵다. 또한 수십억명의 사용자들을  
  지원할 수 있는 확장성 또한 갖지 못한다.

### 분산 메일 서버들

- 분산 메일 서버들은 대규모 및 안전성 등의 문제를 해결하고 현대 use case들을 지원하기 위해 설계되었다.

#### Email APIs

- 이메일 API들은 각기 다른 메일 클라이언트 혹은 이메일의 생명 주기에 따라 굉장히 다른 의미를 가질 수 있다. 예를 들어보자.

  - Native 모바일 클라이언트들을 위한 SMTP/POP/IMAP APIs
  - 발신자 및 수신자 메일 서버들 사이의 SMTP communication
  - 웹 기반의 이메일 애플리케이션들을 위한 HTTP 상의 RESTful APIs

- 이번에는 웹 기반의 이메일을 위해 사용되는 가장 중요한 API들 일부만 살펴보도록 하자. 웹 기반의 메일이 소통하는 가장 일반적인 방법은  
  HTTP 프로토콜을 사용하는 것이다.

- `POST /v1/messages`

  - To, Cc, Bcc header들에 있는 수신자들에게 이메일을 발송한다.

- `GET /v1/folders`

  - 특정 이메일 계정의 모든 폴더들을 반환한다.
  - 응답 예시:
    ```json
    [
      {
        "id": "string", // 폴더의 고유 ID
        "name": "string", // 폴더명, RFC6154에 따르면 기본 폴더들은 All, Archive, Drafts, Flagged, Junk, Sent, Trash 중 하나여야 한다.
        "user_id": "string" // 계정 소유자의 reference
      }
    ]
    ```

- `GET /v1/folders/{folder_id}/messages`

  - 특정 폴더 하위의 모든 메시지들을 반환한다. 이 API는 매우 단순한 변형임을 유의하자. 실 세계에서 이 API는 당연히 pagination을 제공해야 한다.
  - 응답: message 객체들의 리스트

- `GET /v1/messages/{message_id}`

  - 특정 메시지의 모든 정보를 조회한다. 메시지는 발신자, 수신자, 주제, body, 첨부 파일 등의 정보를 포함하는 이메일 애플리케이션을 구성하는  
    주요 building block이다.

  - 응답 예시(message 객체):

    ```json
    {
      "user_id": "string", // 계정 소유자의 reference
      "from": { "name": "string", "email": "string" }, // 발신자 정보
      "to": [{ "name": "string", "email": "string" }], // 수신자(들)의 정보
      "subject": "string", // 이메일의 주제
      "body": "string", // 이메일의 body
      "is_read": false // 해당 메시지가 읽어졌는지의 여부
    }
    ```

#### 분산 메일 서버 아키텍쳐

- 사용자 수가 적은 이메일 서버를 구축하는 것은 쉽지만, 한 대의 서버를 넘어 확장하기에는 어렵다. 이는 전통적인 메일 서버들이 단 1대의  
  서버를 사용하게끔 설계되어있기 때문이다. 여러 서버들 사이에 데이터를 동기화하는 것은 어려울 수 있고, 수신자의 메일 서버가 해당 이메일을  
  spam으로 잘못 분류하는 것을 방지하는 것도 꽤나 어렵다. 이번에는 클라우드 기술을 사용해 이를 어떻게 쉽게 구현할 수 있는지 살펴보자.  
  아래는 분산 메일 서버의 개략적인 설계안이다.

![picture 17](/images/SDI2_DES_4.png)

- 각 컴포넌트들을 자세히 살펴보자.

  - **Webmail** : 사용자들은 이메일을 발신, 수신하기 위해 웹 브라우저를 사용한다.
  - **Web Servers** : Web server는 로그인, 회원 가입, 사용자 프로필 등의 기능을 제공하는 public-facing request/response  
    서비스이다. 이번 장의 설계에서 이메일 발신, 이메일 폴더 조회, 폴더 내의 모든 이메일 조회 등의 모든 이메일 관련 API 요청들도  
    이 web server가 처리하게 된다.
  - **Real-time Servers** : Real-time server는 새로운 이메일에 대한 알림을 실시간으로 클라이언트에게 push한다.  
    이 real-time server는 persistent connection을 유지해야 하기 때문에 stateful server들이다. 실시간 커뮤니케이선을 지원하기  
    위해 long polling, WebSocket 등의 선택지가 있지만 WebSocket이 더 우아하다. 다만 브라우저 호환성이 문제가 될 수 있다.  
    이를 위해 가능할 때는 WebSocket connection을 사용하고, fallback으로 long polling을 사용하도록 할 수 있을 것이다.
  - **Metadata Database** : 이 데이터베이스는 메일 주제, body, 발신자, 수신자 등 이메일의 metadata를 저장한다.
  - **Attachment Store** : Attachment store는 첨부 파일들을 저장하며, 이에는 Amazon S3와 같은 object storage가 적격이다.  
    S3는 확장성이 뛰어난 스토리지 인프라를 가지며 이미지, 비디오, 파일 등의 대용량 파일들을 저장하기 위한 서비스이다.  
    이전에 요구사항에서 첨부 파일은 25MB의 제한을 가질 수 있다고 했다. 반면 Cassandra와 같은 NoSQL column-family database는  
    아래의 이유들 때문에 좋은 선택지가 아닐 수 있다.

    - Cassandra는 blob data type을 지원하고 이론적으로 blob은 2GB까지 다룰 수 있지만, 실질적인 제한은 1MB도 안된다.
    - Cassandra에 첨부 파일들을 저장하면 row 하나가 너무 많은 저장 공간을 차지하기에 메모리를 사용하는 caching을 할 수 없다.

  - **Distributed Cache** : 가장 최신의 이메일들은 클라이언트들이 가장 많이 접하게 되기 때문에 최신 이메일들을 caching하게 되면  
    load time을 효과적으로 개선할 수 있을 것이다. 이를 위해 list 등의 다양한 기능을 제공하며 확장성이 뛰어난 Redis를 사용할 수 있을 것이다.
  - **Search store** : Search store는 분산 document store이며 굉장히 빠른 full-text 검색을 지원하는 inverted index라는  
    자료구조를 사용한다.

- 이제 분산 메일 서버를 구축하기 위한 주요 컴포넌트들을 파악했으니, 아래의 대표적인 2개 workflow들을 다뤄보자.

  - 이메일 발신 flow
  - 이메일 수신 flow

#### 이메일 발신 flow

![picture 18](/images/SDI2_DES_5.png)

- 각 단계를 살펴보자.

  - (1) 사용자는 이메일을 작성하고 "전송" 버튼을 클릭한다. 이메일 전송 요청은 load balancer에 먼저 전달된다.
  - (2) Load balancer는 rate limit을 수행하고 조건에 부합하면 web server에 요청을 전달한다.
  - (3) Web server는 아래의 사항들을 처리한다.

    - 기본적인 이메일 검증 작업. 들어오는 이메일 각각에 대해 크기 제한 등 사전에 정의된 규칙들에 부합하는지 검사한다.
    - 수신자의 이메일 주소 domain이 발신자와 동일한지 검사한다. 만약 동일하다면 웹 서버는 이메일 데이터의 spam 유무 및 바이러스를 검사하고,  
      이를 통과한다면 이메일 데이터는 발신자의 "Sent folder"에 보관되고, 수신자의 "Inbox folder"에도 저장된다.  
      수신자는 이메일을 RESTful API를 사용해 직접 조회할 수 있고, (4)번 단계로 넘어갈 필요가 없다.

  - (4) Message queues

    - (4.a) 이메일에 대한 기본 검증이 성공하면 이메일 데이터는 Outgoing queue로 전달된다. 만약 첨부 파일의 크기가 너무 커서  
      queue에 보관되지 못한다면, 첨부 파일만 따로 object storage에 보관하고 queue에 보관할 메시지에 해당 첨부 파일의 reference만 추가한다.
    - (4.b) 이메일에 대한 기본 검증이 실패하면 해당 이메일은 Error queue로 전달된다.

  - (5) SMTP outgoing worker들은 Outgoing queue로부터 메시지들을 pull하고 각 메시지들이 spam이 아니며 바이러스가 없음을 확인한다.
  - (6) (5)를 통과한 이메일은 Storage layer의 "Sent folder" 내에 저장된다.
  - (7) SMTP outgoing worker가 수신자의 메일 서버로 이메일을 전송한다.

- Outgoing queue 내의 각 메시지는 이메일을 만들어내기 위한 모든 metadata를 포함한다. 그리고 분산 message queue는 이메일 처리 과정을  
  비동기적으로 수행하기 위해 매우 중요한 컴포넌트이다. SMTP outgoing worker들을 web server와 decoupling함으로써 이 둘을 독립적으로  
  상황에 따라 확장할 수 있다.

- 이때 Outgoing queue의 크기를 상세히 모니터링해야 한다. 만약 queue에 많은 이메일들이 적재되어 있다면 원인을 찾아 해결해야 한다.  
  아래와 같은 원인들이 있을 수 있다.

  - 수신자의 메일 서버가 장애가 난 상황. 이 경우 시간이 더 지난 후애 이메일 전송을 재시도해야 한다. 이를 위한 전략으로 exponential  
    backoff가 좋은 선택지가 될 것이다.

  - 메시지를 보내기 위한 SMTP outgoing worker(outgoing queue 입장에서의 consumer)들이 부족한 상황. 이 경우 처리 시간을 단축시키기  
    위해 consumer들을 더 추가할 수 있다.

#### 이메일 수신 flow

- 아래 그림은 이메일을 수신하는 flow를 나타낸다.

![picture 19](/images/SDI2_DES_6.png)

- 이번에도 마찬가지로 각 과정을 살펴보자.

  - (1) 새롭게 수신되는 이메일들은 먼저 SMTP load balancer에 전달된다.
  - (2) Load balancer는 트래픽을 SMTP server들로 분산시킨다. 이메일 수신 정책(email acceptance policy)는 SMTP-connection  
    level에서 설정하고 적용될 수 있다. 예를 들어 부적절한 이메일은 불필요한 이메일 처리 과정을 피하기 위해 무시되도록 할 수 있다.
  - (3) 이메일의 첨부 파일이 queue에 넣기에 너무 크다면, 해당 첨부 파일만 따로 S3와 같은 object storage에 저장시킬 수 있다.
  - (4) 이메일들은 Incoming email queue로 전달된다. 이 queue는 Mail processing worker들과 SMTP server들을 decoupling 시켜  
    각자가 독립적으로 확장될 수 있게 한다. 또한 queue server는 수신되는 이메일의 개수가 갑자기 치솟았을 때 일종의 buffer의 역할도 수행한다.
  - (5) Mail processing worker들은 spam 메일 필터링, 바이러스 검출 등 다양한 작업들을 수행하는 책임을 가진다.  
    이러한 작업들을 통과한 이메일들 만이 다음 단계를 이어나갈 수 있다.
  - (6) 이메일은 Mail storage, Cache, Object data store에 저장된다.
  - (7) 수신자가 활성 상태라면 이메일은 Real-time server들로 전달된다.
  - (8) Real-time server들은 WebSocket server로 클라이언트들이 새로운 이메일들을 실시간으로 수신할 수 있도록 한다.
  - (9) 비활성 사용자들의 경우이다. 이메일들은 우선 Storage layer에 저장된다. 해당 사용자가 다시 활성 상태로 돌아온다면 웹메일 클라이언트들은  
    RESTful API를 통해 web server에게 새로운 이메일을 달라는 요청을 보낸다.
  - (10) Web server들은 Storage layer로부터 새로운 이메일들을 pull하고, 클라이언트에게 반환한다.

---

## 상세 설계

- 이메일 서버를 구성하는 모든 컴포넌트들을 알아보았으니, 아래의 주요 컴포넌트들을 더 자세히 살펴보고, 어떻게 시스템을 확장성 있게 가져갈지 생각해보자.

  - Metadata database
  - Deliverability
  - Search
  - Scalability

### Metadata database

- 이번에는 이메일 metadata의 특성과 적절한 데이터베이스의 선택, 데이터 모델, 그리고 conversation thread에 대해 다뤄보자.

#### 이메일 metadata의 특성

- 이메일 헤더는 주로 작으며 자주 접근된다.
- 이메일 body의 크기는 작을 수도 있고 클 수도 있지만 자주 접근되지는 않는다.  
  사용자들은 일반적으로 이메일을 1번만 읽기 때문이다.
- 이메일 가져오기, 읽음 처리, 검색 등 대부분의 이메일 관련 작업들은 각 사용자들마다 격리되어 수행된다.  
  풀어 말하자면 특정 사용자의 메일들은 해당 사용자만 접근할 수 있으며 해당 메일들에 대한 연산은 그 사용자만이 수행하게 된다는 것이다.
- 데이터의 최신성은 데이터 사용량에 영향을 끼친다. 사용자들은 주로 가장 최신 이메일들만 읽는다.  
  어떤 연구 결과에 따르면 조회 query의 82%는 16일 내의 데이터들만 다룬다고 한다.
- 데이터는 높은 안전성을 보장해야 한다. 데이터의 누락은 허용되지 않는다.

#### 적절한 데이터베이스 선택하기

- Gmail, Outlook의 규모에서 일반적으로 데이터베이스 시스템은 IOPS(Input, Output operations Per Second)를 최소화하기  
  위해 직접 만들어 사용한다. 이는 IOPS가 시스템의 주요 제약 조건이 되기 쉽기 때문이다. 적절한 데이터베이스를 고르는 것은 쉽지 않다.  
  따라서 고르기 전, 가능한 모든 선택지들을 먼저 생각해보는 것이 좋다.

  - RDBMS: RDBMS를 사용하면 이메일 header, body에 index를 걸어 검색 작업을 효율적으로 수행할 수 있다.  
    하지만 RDBMS는 작은 데이터 뭉치를 위해 최적화되어 있기 때문에 큰 데이터 뭉치를 효율적으로 다루기에는 좋지 않다. 이메일은 주로  
    KB 단위이며, HTML이 포함되어 있다면 쉽게 100KB가 넘는 크기를 가질 수 있다. 큰 데이터들을 다루기 위한 BLOB data type을 사용하면  
    되지 않냐고 생각할 수 있지만, 비구조화된 BLOB data type에 대한 검색 query는 효율적으로 수행될 수 없다. 따라서 MySQL, PostgreSQL  
    등의 RDBMS는 좋은 선택지가 되지 못한다.

  - 분산 object storage: 또다른 선택지로 Amazon S3와 같은 클라우드 스토리지에 raw email을 저장하도록 할 수 있다.  
    하지만 이렇게 하면 읽음 처리, 키워드 기반의 이메일 검색, threading 등의 다양한 기능을 효율적으로 제공하기 어렵다.

  - NoSQL database: Gmail은 Google Bigtable을 사용한다. 하지만 Bigtable은 오픈소스가 아니기 때문에 이메일 검색이 어떻게 구현되어  
    있는지를 알 수 없다. Cassandra도 좋은 선택지가 될 수 있지만, 이를 사용하는 이메일 서비스의 선례가 없다.

- 위의 논의를 토대로 우리가 설계하려는 이메일 서비스에 적절한 데이터베이스를 위한 선택지는 그렇게 많지 않다는 것을 알 수 있다.  
  대형 이메일 서비스 프로바이더들은 자신들의 요구사항을 만족시키기 위해 직접 데이터베이스를 만들어 사용하는 경향이 있다. 하지만 분산 데이터베이스를  
  만드는 것은 이번 장의 주제를 벗어나기 때문에 다루지 않을 것이다. 대신, 사용될 데이터베이스가 가져야 할 특성들을 다시 한번 보자.

  - 10MB 미만의 크기를 가질 수 있는 단일 column 지원
  - 높은 데이터 일관성(consistency)
  - Disk I/O를 적게 소비하도록 설계
  - 고가용성 제공 및 장애 감래 가능
  - Incremental backup의 용이성

#### 데이터 모델

- 데이터를 저장하는 한 가지 방법으로 `user_id`를 partition key로 사용해 한 사용자의 모든 데이터가 하나의 shard에 저장되도록 할 수  
  있다. 이러한 데이터 모델의 한 가지 한계점은 메시지들이 여러 사용자들에게 공유되지 않는다는 점이다. 메시지를 공유하는 것은 이번에 설계하는  
  시스템의 요구사항이 아니기 때문에 여기서 다루지 않는다.

- 이제 테이블을 정의해보자. Primary key는 partition key과 clustering key의 2개 컴포넌트로 구성된다.

  - Partition key: 데이터를 여러 node들로 분산시키는 데에 사용된다. 일반적으로 데이터는 동등하게 균포하는 것이 좋다.
  - Clustering key: 특정 partition 내의 데이터를 정렬하는 데에 사용된다.

- 개략적으로 봤을 때 이메일 서비스는 data layer에서 아래의 query들을 지원해야 한다.

  - (1) 사용자의 모든 폴더 조회

    - 아래 그림에 나타난 것처럼 `user_id`는 partition key로 사용되어 특정 사용자의 모든 폴더가 하나의 partition에 저장되도록 한다.

      ![picture 20](/images/SDI2_DES_7.png)

  - (2) 특정 폴더 내의 모든 이메일 조회

    - 사용자가 자신의 수신함을 조회할 때 이메일들은 일반적으로 timestamp로 정렬되어 가장 최신 순서대로 위에서부터 보여준다.  
      이렇게 같은 폴더 내의 모든 이메일을 하나의 partition에 저장하기 위해 `user_id`를 partition key로, 그리고 `folder_id`도  
      함께 partition key로 사용된다. 추가적으로 TIMEUUID 타입의 `email_id`가 이메일을 시간 순서대로 정렬하기 위해 clustering  
      key로 사용된다.

      ![picture 21](/images/SDI2_DES_8.png)

  - (3) 이메일 생성, 삭제, 조회

    - 3개 기능 중 이메일의 상세 정보를 조회하는 방법만 살펴보자. 아래의 2개 테이블이 사용되는데, 이메일이 여러 개의 첨부 파일을 가질 수  
      있기 때문에 `email_id`와 `filename` 필드들의 조합으로 특정 이메일의 모든 첨부 파일들을 가져올 수 있다.

      ![picture 22](/images/SDI2_DES_9.png)

    - 그리고 특정 이메일의 모든 정보를 조회하려면 아래의 간단한 query를 수행하면 된다.

      ```sql
      SELECT * FROM emails_by_user WHERE email_id = 123;
      ```

  - (4) 모든 읽거나 안읽은 이메일 조회

    - 만약 데이터 모델이 RDBMS를 사용했다면, 모든 읽음 처리된 이메일을 조회하려면 아래와 같은 query를 수행해야 했을 것이다.

      ```sql
      SELECT * FROM emails_by_folder
      	WHERE user_id = <user_id> AND folder_id = <folder_id> AND is_read = true
      ORDER BY email_id;
      ```

    - 읽지 않은 모든 이메일들을 가져오는 query도 위와 매우 유사한데, 단지 `is_read = true`를 `is_read = false`로 바꾸면 된다.

    - 하지만 우리의 데이터 모델은 NoSQL을 사용한다. 그리고 NoSQL 데이터베이스는 일반적으로 partition key, cluster key를 기반으로 한  
      query만 수행하도록 한다. `emails_by_folder` 테이블에서 `is_read`는 partition key도 아니고 cluster key도 아니기 때문에  
      대부분의 NoSQL 데이터베이스는 이 query를 지원하지 못할 것이다.

    - 이러한 한계점을 극복하기 위한 한 가지 방법으로 전체 폴더를 모두 가져온 다음, 애플리케이션 내부에서 필터링을 수행하게 할 수 있다.  
      이 방식은 작은 이메일 서비스에서는 동작할 수 있지만, 우리가 설계하는 규모에서는 잘 동작하지 못한다.

    - 이 문제는 주로 NoSQL의 비정규화를 통해 해결된다. 모든 읽거나 읽지 않은 이메일들을 조회하는 query를 지원하기 위해 `emails_by_folder`  
      테이블을 아래의 2개 테이블로 비정규화할 수 있을 것이다.

      - `read_emails`: 오직 읽음 처리된 이메일들만 저장한다.
      - `unread_emails`: 오직 읽지 않은 이메일들만 저장한다.

      ![picture 23](/images/SDI2_DES_10.png)

    - 이렇게 했을 때 특정 이메일을 읽음 처리하려면 해당 이메일을 `unread_emails`에서 지우고 `read_emails`에 저장하면 된다.
    - 특정 폴더의 모든 읽지 않은 이메일들을 조회하려면 아래와 같은 query를 수행하면 된다.

      ```sql
      SELECT * FROM unread_emails
      WHERE user_id = <user_id> AND folder_id = <folder_id>
      ORDER BY email_id;
      ```

    - 위와 같은 NoSQL의 비정규화는 자주 사용되는 기법이다. 애플리케이션 코드는 더 복잡해지고 유지 보수하기 어려워질 수 있지만,  
      대규모에서도 read 성능을 향상시킬 수 있다.

  - (5) Conversation thread 조회

    - Thread는 많은 이메일 클라이언트들에서 제공하는 기능으로, 특정 이메일의 모든 답변들을 원본 메시지와 함께 grouping해 사용자가 하나의  
      conversation에 연관된 모든 이메일들을 한 번에 볼 수 있게 해준다. 전통적으로 thread는 JWZ 알고리즘 등을 사용해 구현되었다.  
      여기서 이 알고리즘에 대해 자세히 다루지는 않을 것이지만, 간단히 이 알고리즘의 핵심 아이디어만 짚어보자.

    - 이메일 헤더는 보통 아래의 3개 필드들을 가진다.

      ```json
      {
        "headers": {
          "Message-Id": "<asdfjasdfjkajsf;l@gmail.com>",
          "In-Reply-To": "<jsadfasdfhlja@gmail.com>",
          "References": ["<kkjasdfasj@gmail.com>"]
        }
      }
      ```

    - 각 필드에 대한 설명은 아래와 같다.

      - Message-Id: 메시지의 ID 값으로, 클라이언트가 메시지를 발신하는 과정에서 생성된다.
      - In-Reply-To: 메시지가 답변을 보내는 parent Message-Id.
      - References: Thread에 연관된 Message-Id들의 목록

    - 이 필드들을 통해 이메일 클라이언트는 메시지들을 토대로 mail conversation을 만들어낼 수 있다.

#### Consistency(일관성) trade-off

- 복제를 수행해 고가용성을 제공하는 분산 데이터베이스들에서는 일관성과 가용성 사이의 tradeoff 관계가 항상 생긴다.  
  이메일 시스템에서는 요구사항에서부터 일관성이 매우 중요하기 때문에 모든 mailbox는 최소 하나의 primary를 가져야 한다.  
  만약 데이터베이스에 장애가 나면 해당 데이터베이스의 mailbox는 클라이언트들이 접근할 수 없게되므로 이들의 동기화, 업데이트 연산은  
  장애가 끝날 때까지 처리되지 못한다. 따라서 높은 일관성을 유지하기 위해 가용성을 일부 떨어뜨리게 된 상황이다.

### Email Deliverability

- 메일 서버를 구축하고 이메일을 발신하는 과정은 상대적으로 쉽다. 사실 어려운 부분은 발신된 이메일들이 수신자들의 수신함에 도달하게끔 하는 일이다.  
  만약 이메일이 spam 폴더에 저장된다면, 수신자는 높은 확률로 해당 이메일을 읽지 않을 것이다. Spam email은 큰 문젯거리이다.  
  Statista에 의해 진행된 연구 결과에 따르면 50%가 넘는 이메일들은 spam으로 분류된다고 한다. 만약 우리가 새로운 메일 서버를 구축한다면  
  우리가 만든 메일 서버는 아무런 평판(reputation) 정보가 없기 때문에 대부분 수신자의 spam 폴더에 들어가게 될 것이다.  
  이렇게 이메일이 잘 수신자에게 도달하게끔 하기 위해 고려해야 할 몇 가지 요소들이 있다.

  - **Dedicated IPs** : 이메일 발송 서버들은 전용 IP를 할당받아 사용하는 것이 좋다. 수신자의 이메일 프로바이더들은 대부분 아무런 기록이  
    없는 IP 주소로부터 수신한 이메일을 잘 읽으려 하지 않고, spam 처리하기 때문이다.

  - **Classify emails** : 서로 다른 카테고리의 이메일들은 각자 다른 IP 주소로부터 전송되어야 한다. 예를 들어 중요한 이메일들과 마케팅  
    이메일들을 동일한 서버(IP)로 전송한다면 ISP가 해당 서버로부터 전송되는 이메일들은 마케팅 이메일들이라 판단하게 될 것이다.

  - **Email sender reputation** : 이메일 서버를 위한 IP 주소들을 할당받고 꾸준히 좋은 평판(reputation)을 가져가 Office365,  
    Gmail, Yahoo Mail 등의 대형 이메일 서비스 프로바이더들이 우리의 이메일 서버로부터 전송되는 이메일들을 spam 폴더로 저장시키지 않도록  
    해야 한다. Amazon SES(Simple Email Service)에 따르면 새로운 IP 주소의 평판을 꾸리는 데에는 대략 2주에서 6주 가량이 소요된다고 한다.

  - **Ban spammers quickly** : 스팸 사용자들은 우리가 만든 이메일 서버의 평판을 떨어뜨리기 전에 빠르게 사용 중지 처리되어야 한다.

  - **Feedback processing** : 여기서 말하는 feedback이라 함은 ISP와의 관계에서의 이야기이다. ISP와 지속적으로 feedback을 주고받아  
    빠르게 스팸 사용자들을 처리하고, 규칙을 잘 준수함을 알려야 한다. 만약 이메일 전송이 실패하거나 사용자가 불만을 표출하면, 아래의 결과 중 하나가 나타난다.

    - Hard bounce: 수신자의 이메일이 유효하지 않기 때문에 ISP에 의해 이메일이 전송 거부되는 것
    - Soft bounce: ISP에 장애가 나는 등의 일시적인 상황 때문에 이메일이 전송 실패하는 것
    - Complaint: 수신자가 "스팸 신고" 버튼을 클릭하는 경우

  - 아래 그림은 hard bounce, soft bounce, 그리고 complaint를 수집하고 처리하는 일련의 과정을 나타낸다.  
    각 경우를 위해 별도의 queue를 사용해 각각 다르게 관리되도록 한다.

    ![picture 24](/images/SDI2_DES_11.png)

- 위의 모든 과정을 하나하나 알 필요는 없다. 중요한 점은 이메일이 원하는 대로 동작하게끔 하는 것이 생각보다 어렵다는 것이다.  
  도메인 지식을 필요로 할 뿐만 아니라, ISP들과 좋은 관계도 유지해 나가야 한다.

### Search

- 기본적인 이메일 검색은 특정 키워드를 주제나 body에 포함하는 이메일을 검색하는 기능을 말한다. 더 고급 기능으로 발신자 별로 검색하거나  
  주제, 읽지 않은 이메일들, 또는 다른 속성들을 기반으로 필터링을 할 수 있다.

- 이메일이 전송되거나 수신되거나, 삭제되는 등의 경우 reindexing이 수행된다. 반면, 검색 query는 사용자가 "검색" 버튼을 클릭 했을 때만  
  수행된다. 이는 곧 이메일 시스템에서 검색 기능은 read보다 write 작업이 훨씬 더 빈번하게 수행된다는 것을 의미한다.  
  Google 검색과 비교했을 때 이메일 검색은 아래와 같은 차이점들이 있다.

  | 검색 종류     | 범위                 | 정렬                                                                 | 정확도                                                                                                   |
  | ------------- | -------------------- | -------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
  | Google search | 전체 인터넷          | 관련성에 따른 정렬                                                   | Indexing은 일반적으로 시간이 꽤 소요되므로 일부 결과들은 즉각적으로 검색 결과에 반영되지 못할 수도 있다. |
  | Email search  | 사용자 본인의 수신함 | 시간, 첨부 파일 유무, 날짜 범위, 읽지 않은 이메일 등의 속성으로 정렬 | Indexing은 거의 실시간으로 진행되어야 하며 검색 결과는 정확해야만 한다.                                  |

- 검색 기능을 지원하기 위해서 Elasticsearch를 사용하는 것과 직접 검색 기능을 개발하는 것을 비교해볼 것이다.

#### 1. Elasticsearch

- Elasticsearch를 사용해 검색 기능을 수행하는 개략적 설계안은 아래와 같다. Query들은 대부분 해당 사용자의 정보를 저장하는 이메일 서버에서  
  수행되기 때문에 `user_id`를 partition key로 사용해 특정 사용자의 모든 이메일 정보들을 동일한 node에 두도록 할 수 있다.

![picture 25](/images/SDI2_DES_12.png)

- 사용자가 "검색" 버튼을 클릭하면 해당 사용자는 검색 결과가 반환될 때까지 기다리게 된다. 즉 검색 요청은 동기 처리된다.  
  "Send email", "Receive email", "Delete email"과 같은 이벤트들이 trigger되는 경우에는 검색과 관련된 어떠한 정보도 클라이언트에게  
  반환될 필요가 없다. Reindexing은 필수로 필요하고, offline job들로 인해 수행될 수 있다. 위 설계안에서는 reindexing을 trigger하는  
  서비스와 실제로 reindexing을 수행하는 서비스를 decoupling 시키기 위해 Kafka가 사용되었다.

- 2021년 6월 기준으로 Elasticsearch가 가장 유명한 검색 엔진 데이터베이스로 사용되고 있고 이메일을 위한 full-text search를 잘 지원한다.  
  Elasticsearch를 사용했을 때의 한 가지 고려 사항은 primary email store와의 데이터 동기화 문제이다.

#### 2. 직접 개발한 검색 기능

- 대규모의 이메일 프로바이더들은 대부분 자신들만의 요구사항을 만족시키기 위해 직접 검색 엔진을 개발한다. 그리고 이메일 검색 엔진을 설계하는 것은  
  굉장히 복잡한 일이며 이 장의 범위를 벗어난다. 여기서는 간단히 disk I/O의 병목, 그리고 직접 검색 엔진을 개발할 때 맞딱뜨리게 될 대표적인  
  문제들을 다뤄보자.

- 이전에 추정치를 계산할 때 보았듯이 metadata와 첨부파일들을 1년동안 보관하기 위해 필요한 저장 공간은 PB(petabyte) 규모였다.  
  한편, 하나의 이메일 계정은 쉽게 수신된 이메일의 개수가 수십만개를 넘길 수 있다. 따라서 index server의 주요 병목 지점은 disk I/O이다.

- Index를 만드는 작업은 write-heavy 하므로 좋은 전략으로 LSM(Log-Structured Merge-Tree)를 사용해 index 데이터를 디스크에  
  구조화할 수 있다. Write path는 순차적인 write(sequential write)만을 사용함으로써 최적화된다. LSM tree는 Bigtable,  
  Cassandra, RocksDB 등 다양한 데이터베이스의 주요 자료구조로 사용된다. 새로운 이메일이 도착하면 우선 level 0(in-memory cache)에  
  추가되고, 만약 메모리 내에 적재된 데이터량이 특정 기준을 넘어선다면 해당 데이터는 다음 레벨로 이동된다. LSM을 사용하는 또다른 이유로, LSM을  
  사용하면 자주 변경되는 데이터와 그렇지 않은 데이터를 쉽게 구분할 수 있다. 예를 들어 이메일 데이터는 자주 변경되지 않지만 폴더 데이터는  
  각기 다른 필터링 조건 때문에 자주 변경되는 편이다. 이 경우 이 둘을 2개의 다른 section으로 분리해 만약 요청이 폴더의 변경과 연관되어  
  있다면 이메일 데이터는 그대로 두고 폴더 데이터만 변경되게끔 할 수 있다.

  ![picture 26](/images/SDI2_DES_13.png)

- 이렇게 Elasticsearch를 사용하는 것과 직접 검색 엔진을 개발하는 것은 각각 아래의 장단점들이 있다.

  | 기능               | Elasticsearch                                                                                                                          | 직접 개발한 검색 엔진                                                      |
  | ------------------ | -------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
  | 확장성             | 특정 경우에 확장 가능                                                                                                                  | 이메일이라는 use case에 맞게 시스템을 최적화할 수 있기에 확장하기 더 쉽다. |
  | 시스템 복잡도      | datastore, Elasticsearch 2개를 모두 운영해야 한다.                                                                                     | 하나의 시스템만 운영하면 된다.                                             |
  | 데이터 일관성      | 데이터의 복제본이 2개 생긴다. 하나는 metadata datastore에, 다른 하나는 Elasticsearch에 있다. 따라서 데이터 일관성을 유지하기 까다롭다. | 데이터의 복제본은 metadata datastore에만 존재한다.                         |
  | 데이터 누락 가능성 | 없다. 만약 문제가 생기면 primary storage의 데이터로부터 Elasticsearch index를 다시 만들면 된다.                                        | 없다.                                                                      |
  | 개발 공수          | 연동하기 쉽다. 대규모 이메일 시스템의 경우, Elasticsearch를 관리하기 위한 별도의 팀이 필요할 수도 있다.                                | 직접 검색 엔진을 개발하는 것은 상당한 엔지니어링 공수가 들어가게 된다.     |

- 이렇게 각 선택지는 장단점이 있고, 일반적으로는 이메일 시스템의 규모가 작으면 연동하기 쉽고 막대한 개발 공수가 들어가지 않는  
  Elasticsearch를 도입하는 방안이 더 매력적이다. Elasticsearch는 동작하지만 이메일 검색 인프라를 관리하기 위한 별도의 개발 팀이  
  필요할 수도 있다. 반면 Gmail, Outlook 규모의 대규모 이메일 시스템을 지원하기 위해서라면 직접 검색 엔진을 개발하는 것이 더 좋을 것이다.

### Scalability, availability

- 각 사용자마다 데이터 접근 패턴이 모두 독립적이기 때문에 시스템을 구성하는 컴포넌트들의 수평적 확장이 잘 되어야 한다.

- 더 높은 가용성을 위해 데이터를 여러 개의 data center들로 복제시킬 수 있다. 사용자들은 자신들과 물리적으로 가까운 위치에 있는 메일 서버와  
  소통하게 된다. 네트워크 장애가 발생하면 사용자들은 다른 data center에 있는 데이터를 활용해 자신의 이메일 관련 작업을 할 수 있다.

  ![picture 27](/images/SDI2_DES_14.png)

---

## 마무리

- 이번 장에서는 대규모 이메일 시스템을 설계해보았다. 먼저 요구사항을 확실히 정의했으며 이후 대략적인 추정치들을 계산해서 정확히 설계하려는  
  시스템의 규모가 어느 정도인지를 파악했다. 개략적 설계 과정에서는 먼저 전통적인 이메일 서버들이 어떻게 구축되었는지 보았고, 이들이 왜  
  현대 use case들을 지원하기 어려운지도 보았다. 그리고 분산 이메일 서버들이 어떻게 구축되었는지와 이메일 관련 API들, 그리고 이메일 수신 및  
  발신 flow도 살펴보았다. 마지막으로 상세 설계에서는 metadata database를 설계하고 이메일을 어떻게 수신자에게 잘 도달시킬 것인지,  
  검색 기능, 그리고 확장성과 가용성에 대해서도 다뤄보았다.

- 아래의 내용들도 생각해 볼만 하다.

  - 장애 감래: 시스템의 다양한 컴포넌트들은 장애가 발생할 수 있다. Node 장애, 네트워크 이슈, 이벤트 지연 등의 문제가 발생할 수 있다.
  - Compliance: 이메일 서비스는 전세계에서 사용되고, 준수해야 하는 법적 규제 사항들이 있다. 예를 들어 유럽의 경우,  
    GDPR(General Data Protection Regulation)을 따르도록 PII(Personally Identifiable Information)을 다뤄야 한다.  
    이메일 도메인에서 법적 규제는 항상 신경써야 하는 문제이다.
  - Security: 이메일은 언제든지 민감한 정보를 담을 수 있기 때문에 보안이 중요하다.  
    Gmail의 경우 이를 위해 phishing protections, safe browsing, proactive alerts, account safety, confidential mode,  
    email encryption 등 다양한 기능을 제공한다.
  - Optimizations: 때에 따라 동일한 이메일이 여러 수신자들에게 발송될 수 있다. 이 경우, 현재 시스템은 동일한 첨부 파일을 여러 번 S3에  
    저장하게 된다. 이런 경우를 위해 값비싼 저장 연산을 수행하기 전 첨부 파일이 이미 object storage에 있는지 확인하도록 할 수 있다.

---
