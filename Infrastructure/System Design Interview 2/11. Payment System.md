# Payment System

- 이번 장에서는 결제 시스템을 설계해보자. 최근 수년 동안 e-commerce 시장은 급성장했고, 각 결제 transaction을 가능하게끔  
  하는 것은 뒷단에서 동작하는 겾제 시스템이다. 따라서 안정적이고 확장성 있고 유연한 결제 시스템은 사실상 필수 요소이다.

- 결제 시스템이 무슨 일을 하는지는 명확하지만 제대로 개발 및 유지하려면 많은 개발자들의 뇨력이 필요하다. 작은 실수가 있다면  
  수익에 직결되고, 사용자들로부터의 신뢰를 잃기도 가장 쉬운 부분이기도하다.

## 문제 이해 및 설계 범위 확정

- 결제 시스템은 굉장히 다양한 것을 의미할 수 있다. 누군가에게는 Apple Pay, Samsung Pay 등의 전자 지갑의 의미를 가질 수 있고,  
  누군가는 PayPal, Stripe 처럼 뒷단에서 결제를 처리하는 시스템으로 알고 있을 수 있다. 따라서 이번에도 여느 때와 마찬가지로  
  설계에 들어가기 전, 먼저 요구사항을 확실히 해보도록 하자.

### 기능적 요구사항

- Amazon.com과 같은 e-commerce 애플리케이션의 결제 백엔드를 담당한다고 생각하면 된다. 사용자가 주문을 시작하는 순간,  
  우리가 설계하는 시스템이 돈과 관련된 모든 부분을 처리한다.

- 신용카드, PayPal 등 실세계에서 사용되는 모든 결제 수단을 지원해야 한다.

- Strip, Braintree 등 제3자 결제 플랫폼을 사용하기 때문에 결제 과정에 대해서는 신경쓰지 않아도 된다.

- 신용카드 정보 등 매우 민감한 정보들은 제3자 서비스를 사용해 저장 및 관리한다.

- 애플리케이션 자체는 global service이지만, 환율은 하나만 사용한다고 가정한다.

- 매일 백만 건의 결제가 이뤄진다.

- 결제 시스템은 accounting, analytics 등 다양한 internal service들 및 payment service provider 등 다양한 external  
  service와 모두 상호작용한다. 따라서 서비스에 장애가 나면, 다른 서비스들과 상태가 일치하지 않는 상황이 발생할 수 있다.  
  따라서 이러한 불일치를 해결하기 위한 과정이 필요하다.

- 위 내용들을 모두 요약하면 아래 2개로 정리할 수 있다.

  - Pay-in flow: 결제 시스템은 판매자들을 대신해 고객으로부터 돈을 받는다.
  - Pay-out flow: 결제 시스템은 전세계의 판매자들에게 돈을 보낸다.

### 비 기능적 요구사항

- 안정성 및 장애 감래: 실패한 결제 내역들은 잘 관리되어야 한다.
- Internal service(accounting, payment system)들과 external service(payment service provider)들 사이의  
  상태 불일치를 해결하기 위한 과정이 필요하다. 이 프로세스는 특정 결제에 대한 정보가 전체 시스템에 걸쳐 일관성이 있는지를 비동기적으로 확인한다.

### 개략적 수치 추정

- 이 시스템은 하루에 100만건의 결제가 이뤄진다. 즉 TPS는 `1000000 / 10^5 = 10`이다.  
  일반적인 데이터베이스에서 10 TPS는 전혀 큰 수치가 아니기 때문에 이번 설계는 높은 처리량을 감당하는 부분이 아닌 어떻게 결제 과정을  
  안정적으로 처리할지에 대해 더 중점을 둘 것이다.

---

## 개략적 설계한 제시 및 동의 구하기

- 개략적으로 봤을 때 결제 흐름은 2개 단계로 나뉜다.

  - Pay-in flow
  - Pay-out flow

- Amazon.com과 같은 e-commerce 서비스를 예시로 들어보자. 구매자가 결제를 완료하면 비용은 Amazon의 은행 계좌로 들어가고, 이를  
  pay-in flow라 한다. 비용이 Amazon의 은행 계좌에 들어가 있지만, 이 모든 비용을 Amazon이 가져가지는 않는다. 판매자로부터 일정  
  금액의 수수료 등을 Amazon이 가져가는 것이기 때문이다. 따라서 이후 구매자가 구매한 상품이 배송이 완료되면 Amazon의 은행 계좌에 있던  
  돈 중 일부 금액이 판매자에게로 송금된다. 이것이 pay-out flow이다.

- Pay-in, pay-out flow는 아래 그림과 같다.

  ![picture 122](/images/SDI2_PSS_1.png)

### Pay-in flow

- Pay-in flow를 위한 개력작 설계안은 아래와 같다.

  ![picture 123](/images/SDI2_PSS_2.png)

- 위 설계안의 각 컴포넌트에 대해 알아보자.

#### Payment service

- Payment service는 사용자들이 발생시킨 결제 이벤트를 수신하고 결제 프로세스를 조정한다.  
  일반적으로 처음에는 AML/CFT 등의 규제에 부합하는지, 돈세탁 또는 다양한 범죄 행위에 대한 가능성이 있는지를 확인하는 "위험성 검사"를  
  진행한다. 그리고 이 "위험성 검사"를 통과하는 결제들만 실제 결제 프로세스로 전달한다. 이 "위험성 검사"는 굉장히 복잡하고 특수하기 때문에  
  보통 3rd-party provider를 사용한다.

#### Payment executor

- Payment executor는 PSP(Payment Service Provider)를 통해 단일 결제를 진행한다.  
  하나의 결제 이벤트는 여러 개의 결제 정보를 포함할 수 있다.

#### PSP(Payment Service Provider)

- PSP는 계좌 A의 돈을 계좌 B로 송금하는 역할을 한다. 위 예시에서 PSP는 구매자의 신용 카드 계좌로부터 돈을 빼낸다.

#### Card schemes

- Card scheme는 신용 카드 작업을 수행하는 단체이다. Visa, MasterCard, Discovery 등이 이에 해당한다.

#### Ledger

- Ledger는 결제 내역에 대한 회계 기록을 저장하는 컴포넌트이다. 예를 들어 사용자가 판매자에게 $1을 지급하면, ledger는 이를 구매자로부터  
  $1을 인출했고, 판매자에게 $1을 지급한다고 기록한다. Ledger는 e-commerce 서비스의 총 매출을 계산하는 등 post-payment analysis에  
  매우 핵심적으로 사용되는 컴포넌트이다.

#### Wallet

- Wallet은 판매자의 잔액 정보를 저장한다. 그리고 특정 사용자가 총 걸제한 금액에 대한 정보를 갖기도 한다.

- 이제 위 그림에 나타난 pay-in flow를 단계별로 살펴보자.

  - (1) 사용자가 "상품 구매" 버튼을 클릭하면, 결제 이벤트가 생성되고 payment service로 전달된다.
  - (2) Payment service가 결제 이벤트를 데이터베이스에 기록한다.
  - (3) 일부 결제 이벤트는 여러 개의 상품 구매 내역을 가질 수 있다. 예를 들어, 구매자는 여러 판매자의 상품을 장바구니에 담고 한 번에 결제할  
    수 있을 것이다.
  - (4) Payment executor가 상품 구매 내역을 데이터베이스에 저장한다.
  - (5) Payment executor가 신용 카드 결제를 진행하기 위해 외부의 PSP를 호출한다.
  - (6) Payment executor의 결제 프로세스가 성공적으로 완료되면 payment service는 wallet에 있는 판매자의 잔고 정보를 갱신한다.
  - (7) Wallet server가 갱신된 잔고 정보를 데이터베이스에 반영한다.
  - (8) Wallet service가 성공적으로 정보 갱신을 완료하면 payment service는 ledger를 호출해 결제 내역을 기록한다.
  - (9) Ledger service가 새로운 정보를 데이터베이스에 저장한다.

#### Payment service API

- Payment service는 RESTful API를 제공한다. 하나씩 살펴보자.

- `POST /v1/payments`

  - 이 Endpoint는 결제 이벤트를 생성하는 데 사용된다. 이전에 봤듯이 하나의 결제 이벤트는 여러 개의 상품 내역을 가질 수 있다.  
    아래 표는 request parameter 들이다.

    | field            | description                                                  | type   |
    | :--------------- | ------------------------------------------------------------ | ------ |
    | buyer_info       | 구매자 정보                                                  | json   |
    | checkout_id      | 전역적으로 고유한 결제 이벤트 ID                             | string |
    | credit_card_info | 신용카드 정보(암호화되거나 token일 수 있다. PSP마다 다르다.) | json   |
    | payment_orders   | 상품 목록                                                    | list   |

  - `payment_orders` 필드는 아래와 같다.

    | field            | description     | type   |
    | :--------------- | --------------- | ------ |
    | seller_account   | 판매자 계좌번호 | string |
    | amount           | 결제 금액       | string |
    | currency         | 결제 통화       | string |
    | payment_order_id | 결제의 고유 ID  | string |

  - 위 필드 중 `payment_order_id`는 전역적으로 고유한 값이다. Payment executor가 3rd-party PSP에 결제 요청을 보낼 때  
    이 값이 멱등성 key(idempotency key)로 사용된다.

  - 또한 `amount` 필드 타입이 double이 아닌 string인데, double은 아래와 같은 이유로 좋지 않다.

    - 직렬화, 역직렬화 과정이 프로토콜, 소프트웨어, 하드웨어에 따라 다를 수 있다. 이러한 차이로 인해 숫자 계산이 잘못될 수 있다.
    - 숫자가 매우 클 수 있거나 매우 작을 수도 있다.

- `GET /v1/payments/{id}`

  - 이 endpoint는 `payment_order_id`를 기반으로 한 단일 결제의 상태를 조회하는 데 사용된다.

#### Payment service data model

- Payment service는 결제 이벤트와 결제 내역을 저장하기 위한 2개의 테이블이 필요하다. 결제 시스템을 위한 데이터베이스를 고를 때,  
  성능은 주로 고려 사항이 아니다. 대신, 아래의 것들에 대해 다뤄보자.

  - 향상된 안정성: 해당 storage system이 대규모 금융 회사들이 n년 사용했는지의 여부는 좋은 참고 사항이 된다.
  - 모니터링, 분석 도구 등에 대한 원활한 지원 여부
  - DBA의 공급: 숙련된 DBA를 리크루팅할 수 있는지 여부는 굉장히 중요하게 고려해야 할 요인이다.

- 일반적으로는 NoSQL/NewSQL 대신 ACID transaction이 보장되는 전통적인 RDBMS를 선호한다.

- `payment_event` table은 결제 이벤트의 모든 내용을 담는다.

  | name             | type                      |
  | :--------------- | ------------------------- |
  | checkout_id      | string(PK)                |
  | buyer_info       | string                    |
  | seller_info      | string                    |
  | credit_card_info | card provider에 따라 다름 |
  | is_payment_done  | boolean                   |

- `payment_order` table은 각 결제의 상태를 저장한다.

  | name                 | type       |
  | :------------------- | ---------- |
  | payment_order_id     | string(PK) |
  | buyer_account        | string     |
  | amount               | string     |
  | checkout_id          | string(FK) |
  | payment_order_status | string     |
  | ledger_updated       | boolean    |
  | wallet_updated       | boolean    |

- Table들에 더 깊게 다뤄보기 전, 배경 정보들을 살펴보자.

  - `checkout_id`는 FK이다. 이는 하나의 결제 이벤트가 여러 개의 상품 결제 내역을 가질 수 있기 때문이다.
  - 3rd-paty PSP를 호출해 구매자의 신용 카드로부터 돈을 빼내려 할 때, 빠진 돈이 직접적으로 판매자에게 전달되지 않는다.  
    대신 해당 돈은 e-commerce 서비스의 은행 계좌로 입금된다. 이 프로세스를 pay-in이라 한다. Pay-out의 조건이 만족된다면  
    그제서야 e-commerce 서비스의 은행 계좌로부터 돈이 실제 판매자에게 전달되는 것이다. 따라서 pay-in 과정에는 판매자의 계좌 정보는  
    필요하지 않고, 구매자의 카드 정보만 있으면 된다.

- `payment_order` table에서 `payment_order_status`는 enum type이며 `NOT_STARTED`, `EXECUTING`, `SUCCESS`,  
  `FAILED`를 가진다. 갱신 로직은 아래와 같다.

  - 최초 상태는 `NOT_STARTED`이다.
  - Payment service가 결제 정보를 payment executor로 넘기면 상태가 `EXECUTING`로 변경된다.
  - Payment service는 payment executor의 응답에 따라 상태랄 `SUCCESS` 또는 `FAILED`로 갱신한다.

- `payment_order_status`가 `SUCCESS`가 되면 payment service는 wallet service를 호출해 판매자의 잔액 정보를 갱신하고  
  `wallet_updated` 필드를 true로 변경한다. 여기서는 wallet 정보 갱신이 항상 성공한다고 간주했기에 설계가 조금 단순하졌다.

- 완료된 후 payment service는 ledger service를 호출해 ledger database에 내역을 저장하고, `ledger_updated` 필드를  
  true로 갱신한다.

- 동일한 `checkout_id` 하위의 모든 상품 겨제가 완료되면 payment service는 `payment_event` table의 `is_payment_done`  
  필드를 true로 갱신한다. 일반적으로는 고정된 주기로 실행되는 job이 이 작업을 수행한다. 만약 성공적으로 완료된 결제 건수가 특정  
  기준치보다 덜하다면 알림을 보내 엔지니어들이 이에 대한 조치를 취하도록 한다.

#### Double-entry ledger system

- Ledger system에는 굉장히 중요한 설계 원칙이 있는데, 바로 double-entry principle(double-entry accounting/bookkeeping)이다.  
  Double-entry system은 정확한 회계 장부를 유지하기 위한 핵심 요소이다. 아래 표와 같이 모든 결제 transaction을 같은 금액을 갖는  
  두 개의 별도 ledger acocount에 저장한다.

  | account | debit | credit |
  | ------- | ----- | ------ |
  | buyer   | $1    | -      |
  | seller  | -     | $1     |

- Double-entry system에서 모든 transaction 기록들의 누적 합은 0이 된다. 1원이라도 부족하다면, 누군가 1원을 벌어갔음을 의미한다.  
  이는 end-to-end 추적과 전체 결제 cycle에서의 일관성을 보장하게 된다.

#### Hosted payment page

- 대부분의 회사들은 준수하기 어려운 법적 규제 때문에 신용 카드 정보를 직접 관리하지 않는다. 대신 PSP가 제공하는 hosted credit card page를  
  사용하게 된다. 웹사이트의 경우에 이는 widget이나 iframe이 되고, 모바일 애플리케이션의 경우에는 PSP가 제공하는 SDK를 사용하게 된다.  
  아래 그림은 PayPal이 제공하는 결제 페이지이다. 여기서 가장 중요하게 봐야할 점은 PSP가 제공하는 결제 페이지가 우리가 설계하는 서비스에  
  전혀 의존하지 않고 사용자의 카드 정보를 처리한다는 것이다.

  ![picture 124](/images/SDI2_PSS_3.png)

### Pay-out flow

- Pay-out flow의 컴포넌트들은 pay-in flow와 매우 유사하다. 한 가지 차이점은 pay-in flow가 구매자의 신용 카드로부터 e-commerce  
  서비스의 은행 계좌로 돈을 송금하기 위해 PSP를 쓰는 것과 달리 pay-out flow는 e-commerce 서비스의 은행 계좌로부터 판매자의  
  계좌로 돈을 옮기기 위해 3rd-party pay-out provider를 사용한다는 것이다.

- 일반적으로 결제 시스템은 pay-out을 처리하기 위해 Tipalti와 같은 3rd-party account payable provider를 사용한다.

---
