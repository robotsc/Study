# MSA IPC 개요

- 모놀리틱 애플리케이션은 대부분의 모듈이 언어 수준의 메소드나 함수를 통해 서로 호출하기 때문에  
  REST API나 클라우드 서비스 연계 모듈을 작성하지 않는 이상 IPC는 크게 신경 쓸 필요가 없다.

- 이와 달리 MSA는 애플리케이션을 여러 개의 서비스로 구성하며, 서비스는 대부분 요청을 처리하기 위해  
  서로 협동한다. 서비스 인스턴스는 여러 머신에서 실행되는 프로세스 형태이므로 반드시 IPC를 통해  
  상호 작용해야 한다. 따라서 IPC는 모놀리틱 아키텍쳐보다 MSA에서 차지하는 비중이 더 크다.

- IPC 기술은 옵션이 다양하다. 요즘은 JSON을 주고 받는 REST가 대세지만, 모든 경우를 만족하는  
  만병통치약은 없으므로 여러 가지 옵션을 잘 검토해야 한다.

- IPC는 애플리케이션 가용성에 영향을 미치는 아주 중요한 아키텍쳐 의사 결정 항목이고 트랜잭션 관리와도  
  맞물려 있다. 저자는 비동기 메시징으로 서로 통신하는 느슨하게 결합된 서비스로 구성된 아키텍쳐를 선호한다.  
  REST 같은 동기 프로토콜은 대부분 다른 애플리케이션과 통신할 때 사용한다.

<h2>MSA IPC 개요</h2>

- 서비스에 적용 가능한 IPC 기술은 정말 선택의 폭이 넓다. HTTP 기반의 REST나 gRPC 등  
  동기 요청/응답 기반의 통신 메커니즘도 있고, AMQP, STOMP 등 비동기 메시지 기반의 통신 메커니즘도 있다.  
  메시지 포맷 역시 JSON, XML 처럼 인간이 읽을 수 있는 text 포맷부터 Avro나 Protobuf처럼 효율이  
  우수한 binary 포맷까지 다양하다.

<h3>상호 작용 스타일</h3>

- 서비스 API에 알맞은 IPC를 선택하기 전에 클라이언트/서비스 간 상호 작용 스타일을 잘 살펴보면  
  요건에서 벗어나는 일 없이 특정 IPC 기술의 세부 내용에 빠져 헤매는 일을 방지할 수 있다.  
  상호 작용 스타일의 선택은 전체 애플리케이션의 가용성 영역에 영향을 끼치며, 적절한 통합 테스트 전략을  
  수립하는 데에도 도움이 된다.

- 클라이언트/서비스 간의 상호 작용 스타일은 다양하지만 아래의 두 가지 기준으로 분류할 수 있다.

  - 첫째, 일대일/일대다 여부이다.

    - 일대일(one-to-one): 각 클라이언트의 요청을 정확히 한 서비스가 처리한다.
    - 일대다(one-to-many): 각 클라이언트의 요청을 여러 서비스가 협동하여 처리한다.

  - 둘째, 동기/비동기 여부이다.

    - 동기(synchronous): 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹할 수 있다.
    - 비동기(asynchronous): 클라이언트가 블로킹하지 않는다. 응답은 즉시 전송되지 않아도 된다.

- 일대일 상호 작용도 종류는 다양하다.

  - 요청/응답(request/response): 클라이언트는 서비스에 요청하고 응답을 기다린다. 클라이언트는 응답이 제때 도착하리라  
    기대하고 대기 도중 블로킹할 수 있다. 결과적으로 서비스가 강하게 결합되는 상호 작용 스타일이다.
  - 비동기 요청/응답(asynchronous request/response): 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답한다.  
    클라이언트는 대기 중에 블로킹하지 않고, 서비스는 오랫동안 응답하지 않을 수 있다.
  - 단방향 알림(one-way notification): 클라이언트는 서비스에 일방적으로 요청만 하고 서비스는 응답을 보내지 않는다.

- 동기 요청/응답은 주로 IPC 기술에 서로 연관성이 없이 독립적인 상호 작용 스타일이다.  
  예를 들어 서비스는 REST나 메시징으로 요청/응답하는 다른 서비스와 소통할 수 있다. 2개의 서비스가 메시지 브로커를 통해  
  통신하는 경우에도 클라이언트 서비스는 응답을 기다리는 도중 블로킹될 수 있다. 그렇다고 두 서비스가 느슨하게 결합되었다는  
  뜻은 아니다. 이는 뒤에 가용성을 따질 때 다시 살펴보자.

- 일대다 상호 작용도 몇 가지 종류가 있다.

  - 발행/구독(publish/subscribe): 클라이언트는 알림 메시지를 발행하고, 여기에 관심 있는 0개 이상의 서비스가  
    메시지를 소비한다.
  - 발행/비동기 응답(publish/async response): 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련  
    서비스가 응답하길 기다린다.

- 각 서비스마다 이런 상호 작용 스타일을 조합해서 사용한다.

<h3>마이크로서비스 API 정의</h3>

- API와 인터페이스는 소프트웨어 개발의 핵심이다. 애플리케이션은 여러 모듈로 구성되며, 각 모듈마다 자신의 클라이언트가  
  호출하는 작업이 정의된 인터페이스가 있다. 잘 설계된 인터페이스는 유용한 기능을 표출하되 그 구현체는 감추어져 있기 때문에  
  클라이언트에 영향을 미치지 않고 코드를 고칠 수 있다.

- 모놀리틱 애플리케이션은 대부분 프로그래밍 언어에 맞게 인터페이스를 지정한다.  
  가령 Java 인터페이스는 클라이언트가 호출하는 메소드 목록이 정해져 있고, 클라이언트는 구현체 클래스를 직접 바라볼 수 없다.  
  Java는 정적 타입 언어이기 때문에 클라이언트와 인터페이스가 달라 호환되지 않으면 컴파일 조차 불가하다.

- MSA에는 API와 인터페이스가 똑같이 중요하다. 서비스 API는 서비스와 클라이언트 간의 약속이다. 클라이언트가 호출 가능한  
  작업과 서비스가 발행하는 인터페이스로 구성된다. 작업에는 이름, 매개변수, 반환형이 있다. 타입과 필드를 가진 이벤트는  
  메시지 채널에 발행된다.

- 문제는 서비스 API가 단순한 프로그래밍 언어의 일부분이 아니라는 것이다. 정의상 서비스와 클라이언트는 함께  
  컴파일되지 않는다. 따라서 새 버전의 서비스가 호환되지 않는 API에 맞물려 배포되어도 컴파일 에러는 안나고 런타임에 조용히  
  실패할 것이다.

- 어떤 IPC를 선택하든 서비스 API를 IDL(Interface Definition Language, 인터페이스 정의 언어)로 정확히  
  정의해야 한다. API 우선 방식으로 서비스를 정의하는 문제는 이미 좋은 자료가 많다. 인터페이스 명세를 작성한 후  
  클라이언트 개발자와 함께 의논하는 과정을 몇 차례 되풀이하면서 API를 정의한 후 서비스를 구현한다.  
  이렇게 설계 후 구현하는 방식으로 진행하면 클라이언트 니즈에 좀 더 부합한 서비스를 구축할 수 있다.

> 반드시 API를 먼저 설계하라!!

- API는 어떤 IPC를 사용하느냐에 따라 그 내용이 결정된다. 메시징으로 통신하는 API는 메시지 채널, 메시지 타입, 메시지 포맷으로  
  정의한다. HTTP로 통신하는 API는 URL, HTTP Method, 요청/응답 포맷으로 구성될 것이다.

<h3>API 발전시키기</h3>

- API는 새 기능을 추가하거나 기존 기능을 변경/삭제하는 과정을 거치며 계속 변한다.  
  모놀리틱 애플리케이션에서 API를 변경하고 모든 호출부를 수정하는 일은 그리 어렵지 않다.  
  여러 곳에서 사용하는 API를 고치려면 시간이 많이 걸리므로 사실상 변경 범위가 유일한 문제이다.

- 마이크로서비스 애플리케이션은 클라이언트를 다른 서비스 팀이 개발하는 경우가 대부분이기 때문에 서비스 API를  
  변경하기가 무척 어렵다. 서비스를 사용하는 클라이언트를 모두 찾아 강제로 업그레이드 시킬 수도 없을 것이다.  
  또 요즘은 유지보수할 때 서비스를 내리지 않기 때문에 규칙적인 단계로 서비스를 업그레이드하여 신규 버전을  
  동일하게 실행한다.

- 이런 문제를 해결하려면 전략을 잘 세워야 한다. API를 변경하는 방법도 어떤 성격의 변경인지에 따라 달라진다.

<h4>시맨틱 버저닝</h4>

- 시맨틱 버저닝 명세(Semantic Versioning Specification)는 API 버저닝에 관한 유용한 지침서이다.  
  여기에는 버전 번호를 사용하고 증가시키는 규칙들이 명시되어 있다. 시맨틱 비저닝은 원래 소프트웨어 패키지의 버저닝 용도로도  
  쓰였지만, 분산 시스템의 API 버저닝에도 사용할 수 있다.

- 이 명세에 따르면 버전 번호를 `MAJOR`, `MINOR`, `PATCH`의 3 파트로 구성하고, 아래 규칙에 따라 각각 증가시킨다.

  - `MAJOR`: 하위 호환되지 않는 변경분을 API에 적용 시
  - `MINOR`: 하위 호환되는 변경분을 API에 적용 시
  - `PATCH`: 하위 호환되는 오류 수정 시

- 이런 버전 번호를 API에 어떻게 넣을지는 규칙이 없는데, REST API라면 메이저 버전을 URL 경로의 첫 번째 엘리먼트로  
  쓸 수 있고, 메시징 기반의 서비스라면 이 서비스가 발행한 메시지에 버전 번호를 넣을 수 있을 것이다.  
  어찌되든 API를 올바르게 버저닝하여 일정한 규칙에 맞게 발전시키는 것이 중요하다.

<h4>하휘 호환되는 소규모 변경</h4>

- 변경을 하더라도 가급적 하휘 호환성을 보장하는 방향으로 해야 한다.  
  뭔가를 API에 추가하는 변경은 대부분 하위 호환된다.

  - 옵션 속성을 요청에 추가
  - 속성을 응답에 추가
  - 새 작업을 추가

- 이런 종류의 변경은 새 서비스에 적용해도 기존 클라이언트 역시 별 문제 없이 작동한다.  
  단, *당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게 바라보라*는 견고성 원칙을 지켜야 한다.  
  요청 속성이 누락되어도 서비스는 기본값을 제공하고, 서비스가 필요한 것보다 더 많은 속성을 응답하더라도 클라이언트는  
  간단히 무시해야 한다. 클라이언트/서비스가 견고성 원칙을 뒷받침하는 요청/응답 포맷을 사용하면 이런 과정이  
  매끄럽게 진행된다.

<h4>중대한 대규모 변경</h4>

- 경우에 따라서는 매우 중요한, 기존 버전과는 호환이 안되는 변경을 API에 적용해야 할 때가 있다.  
  일시에 클라이언트를 강제로 업그레이드하는 것은 불가능하므로 일정 기간 동안 서비스는 신, 구버전 API를  
  모두 지원해야 한다. HTTP 기반의 REST API라면 URL에 메이저 버전 번호를 삽입할 수 있다.(`/v1/~`, `/v2/~`)

- HTTP Content Negotiation을 이용해서 MIME Type 내부에 버전 번호를 끼워 넣는 방법도 있다.  
  가령 버전 1.X의 요청은 클라이언트가 아래와 같이 요청한다.

```
GET /path/to/api HTTP/1.1

Accept: application/vnd.example.resource+json; version=1
```

- 위는 클라이언트가 버전 1.X 응답을 기대한다고 API에 요청한 것이다.

- 여러 버전의 API를 지원하려면 API가 구현된 서비스 어댑터에 신, 구 버전을 올바르게 중계하는 로직이 있어야 한다.  
  API Gateway는 거의 반드시 버저닝된 API를 사용하며, 심지어는 구 버전 API도 여러 버전을 지원해야 하는 경우도 있다.

<h4>메시지 포맷</h4>

- IPC의 핵심은 메시지 교환이다. 대부분의 메시지는 데이터를 담고 있기 때문에 데이터 포맷은 중요한  
  설계 결정 항목이다. 또 IPC 효율, API 사용성, 발전성에도 영향을 미친다. 특히 메시징이나 HTTP Protocol을  
  사용하려면 메시징 포맷을 선택해야 한다. gRPC 같은 IPC는 메시지 포맷이 정해져 있다.  
  지금 단계에서는 어느 프로그래밍 언어로 마이크로서비스를 작성하더라도 나중에 다른 언어를 사용해서 작성하게 될 수도  
  있기 때문에 범언어적(Cross-Language) 메시지 포맷을 선택하는 것이 중요하다.  
  예를 들어, Java 직렬화는 Java에 국한된 기술이므로 사용하지 않는 것이 좋다.

- 메시지 포맷은 크게 텍스트와 이진 포맷으로 구분된다.

<h4>텍스트 메시지 포맷</h4>

- JSON, XML 등 텍스트 기반 포맷은 사람이 읽을 수 있고 자기 서술적인 장점이 있다.  
  JSON 메시지는 Named Property, XML 메시지는 Named Element와 그 값을 모아놓은 구조이다.  
  메시지 consumer는 자신이 관심 있는 값만 골라쓰고 나머지는 그냥 무시하면 되므로 메시지 스키마가  
  자주 바뀌어도 하위 호환성은 쉽게 보장된다.

- XML 문서 구조는 XML 스키마로 명시하는데, JSON에도 이런 메커니즘의 필요성이 점점 개발자 커뮤니티에서  
  설득력을 얻기 시작했다. 그래서 메시지 프로퍼티의 이름/타입 및 필수/옵션 여부가 정의된 JSON 스키마 표준이  
  제정되었다. 이 표준은 애플리케이션에 들어온 메시지를 확인하는 용도로 사용할 수 있고, 문서화에도 요긴하다.

- 텍스트 메시지 포맷의 단점은 메시지가 다소 길다는 사실이다. 모든 메시지에 속성값 이외의 속성명이 추가되는  
  오버헤드가 있고, 덩치가 큰 메시지는 텍스트를 파싱하는 오버헤드도 있다. 따라서 효율, 성능이 중요한  
  경우에는 이진 포맷을 고려해봐야 한다.

<h4>이진 메시지 포맷</h4>

- 이진 포맷은 종류가 다양하지만 크게 Protocol Buffer와 Avro가 유명하다.  
  이 두 포맷은 메시지 구조 정의에 필요한 타입 IDL을 제공하며, 컴파일러는 메시지를 직렬화, 역직렬화하는  
  코드를 생성한다. 따라서 서비스를 API 우선 접근 방식으로 설계할 수 밖에 없다.  
  그리고 정적 타입 언어로 클라이언트를 작성할 경우, 클라이언트가 API를 올바르게 사용하는지 컴파일러로  
  확인할 수 있다.

- 하지만 Avro Consumer는 스키마를 알고 있어야 메시지를 해석할 수 있기 때문에 API 발전 측면에서는  
  Protocol Buffer가 더 용이하다.

<hr/>
