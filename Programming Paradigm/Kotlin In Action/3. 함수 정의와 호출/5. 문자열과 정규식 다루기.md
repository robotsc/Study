# 문자열과 정규식 다루기

- 코틀린 문자열은 Java 문자열과 같다. 코틀린 코드가 만들어낸 문자열을 아무 Java 메소드에  
  넘겨도 되며, Java 코드에서 받은 문자열을 아무 코틀린 표준 라이브러리 함수에 전달해도 전혀  
  문제 없다. 특별한 변환도 필요 없고, Java 문자열을 감싸는 별도의 wrapper도 생기지 않는다.

- 코틀린은 다양한 확장 함수를 제공함으로써 표준 Java 문자열을 더 쉽게 다루게 해준다. 또한,  
  혼동이 야기될 수 있는 일부 메소드에 대해 더 명확히 코틀린 확장 함수를 제공함으로써 프로그래머의  
  실수를 줄여준다. Java와 코틀린 API의 차이를 알아보기 위한 첫 번째 예시로 문자열을 구분  
  문자열에 따라 나누는 작업을 코틀린에서 어떻게 처리하는지 보자.

## 문자열 나누기

- Java 개발자라면 `String#split()`에 익숙할 것이다. 모든 Java 개발자가 그렇진 않지만, 이에  
  불만을 표시하는 사람도 있다. 예를 들어 `"12.345-6.A".split(".")`의 결과가 `[12, 345-6, A]`이라고  
  생각하는 실수를 저지르는 개발자가 많다. 하지만 Java의 `split()`은 빈 배열을 반환한다. `split()`의  
  구분 문자열은 실제로는 정규식(regular expression)이기 때문이다. 따라서 마침표(`.`)는 모든 문자를  
  나타내는 정규식으로 해석된다.

- 코틀린에서는 Java의 `split()` 대신 여러 가지 다른 조합의 파라미터를 받는 `split()`  
  확장함수를 제공함으로써 혼동을 야기하는 메소드를 감춘다. 정규식을 파라미터로 받는 함수는 `String`이  
  아닌 `Regex` 타입의 값을 받는다. 따라서 코틀린에서는 `split()`에 전달하는 값의 타입에 따라  
  정규식이나 일반 텍스트 중 어느 것으로 문자열을 분리하는지 쉽게 알 수 있다.

- 아래 코드는 마침표나 `-`로 문자열을 분리하는 예시를 보여준다.

```kt
println("12.345-6.A".split("\\.|-".toRegex()))
// (12, 345, 6, A)
```

- 코틀린 정규식 문법은 Java와 똑같다. 위의 패턴은 마침표나 대시에 매치된다. 정규식을 처리하는  
  API는 표준 Java 라이브러리 API와 비슷하지만, 조금 더 코틀린답게 변경되었다. 예를 들어  
  코틀린에서는 `toRegex()` 확장함수를 사용해 문자열을 정규식으로 변환할 수 있다.

- 이런 간단한 경우에는 꼭 정규식을 쓸 필요가 없다. `split()` 확장 함수를 오버로딩한 버전 중에는  
  구분 문자열을 하나 이상 인자로 받는 함수가 있다.

```kt
println("12.345-6.A".split(".", "-"))
// (12, 345, 6, A)
```

- 위 경우에는 `split(".", "-")` 대신 `split('.', '-')`처럼 문자열 대신 문자를 인자로  
  넘겨도 마찬가지 결과를 볼 수 있다. 이렇게 여러 문자를 받을 수 있는 코틀린 확장 함수는 Java에  
  있는 단 하나의 문자만 받을 수 있는 메소드를 대신한다.

---

## 정규식과 3중 따옴표로 묶은 문자열

- 다른 예로 두 가지 다른 구현을 만들어보자. 첫 번째 구현은 `String`을 확장한 함수를 사용하고,  
  두 번째 구현은 정규식을 사용한다.

- 구현해볼 것은 파일의 전체 경로명을 디렉토리, 파일명, 확장자로 구분하는 것이다.  
  코틀린 표준 라이브러리에는 어떤 문자열에서 구분 문자열이 맨 처음 또는 마지막에 나타난 곳의 앞 또는 뒤의  
  부분 분자열을 반환하는 함수가 있다. 이런 함수들을 이용해 구현한 코드는 아래와 같다.

```kt
fun parsePath(path: String) {
    val directory = path.substringBeforeLast("/")
    val fullName = path.substringAfterLast("/")

    val fileName = fullName.substringBeforeLast(".")
    val extension = fullName.substringAfterLast(".")

    println("Dir: $directory, name: $fileName, ext: $extension")
}
```

- 코틀린에서는 정규식을 사용하지 않고도 문자열을 쉽게 파싱할 수 있다. 정규식은 강력하긴 하지만, 나중에 알아보기  
  힘든 경우가 많다. 정규식이 필요할 때는 코틀린 라이브러리를 사용하면 더 편하다. 같은 작업을 정규식을 통해  
  구현한 코드를 보자.

```kt
fun parsePath(path: String) {
  val regex = """(.+)/(.+)\.(.+)""".toRegex()
  val matchResult = regex.matchEntire(path)
  if(matchResult != null) {
    val (directory, filename, extension) = matchResult.destructured
    println("Dir: $directory, name: $filename, ext: $extension")
  }
}
```

- 위 예시에서는 3중 따옴표 문자열을 사용해 정규식을 썼다. 3중 따옴표 문자열에서는 역슬래시(`\`)를 포함한  
  어떤 문자도 escape할 필요가 없다. 예를 들어, 일반 문자열을 사용해 정규식을 작성하는 경우, 마침표 기호를  
  escape하려면 (`\\.`)라고 써야 하지만, 3중 따옴표 문자열에서는 `\.`라 쓰면 된다.

---

## 여러 줄 3중 따옴표 문자열

- 3중 따옴표 문자열을 escape를 피하기 위해서만 사용하지는 않는다. 3중 따옴표 문자열에는 줄바꿈을  
  표현하는 아무런 문자열이나 그대로 들어간다. 따라서 3중 따옴표를 쓰면 줄 바꿈이 들어있는 프로그램  
  텍스트를 쉽게 문자열로 만들 수 있다. 아래는 ASCII Art(글자만 사용해 그린 그림)를 하나 출력한다.

```kt
val kotlinLogo = """
  | //
	.| //
  .|/ \
"""

println(kotlinLogo.trimMargin("."))

/*
 * |  //
 * | //
 * | / \
 */

```

- 여러 줄을 포함하는 문자열에는 들여쓰기나 줄바꿈을 포함한 문자가 들어간다. 여러 줄 문자열을 코드에서 더 보기 좋게  
  표현하고 싶다면, 들여쓰기를 하되 들여쓰기의 끝 부분을 특별한 문자열로 표현하고, `trimMargin()`을 사용해 그  
  문자열과 그 직전의 공백을 제거한다. 이 예제에서는 마침표를 들여쓰기 구분 문자열로 사용했다.

- 여러 줄 문자열에는 줄 바꿈이 들어가지만, 줄 바꿈을 `\n`과 같은 특수 문자를 사용해 넣을 수는 없다.  
  반면에 `\`를 문자열에 넣고 싶으면 escape할 필요가 없다.

- 3중 따옴표 문자열 안에 문자열 템플릿을 사용할 수도 있다. 그러나 3중 따옴표 문자열 안에서는 escape를  
  할 수 없기 때문에, 문자열 템플릿의 시작을 표현하는 `$`를 3중 따옴표 안에 넣을 수 없다는 문제가 생긴다.  
  3중 따옴표 안에 `$`를 넣고 싶다면, 아래처럼 어쩔 수 없이 문자열 템플릿 안에 `'$'`처럼 넣어야 한다.

```kt
val price = 1.1
val priceString = """${'$'}$price"""
println(priceString)

// $1.1
```

- 프로그래밍 시 여러 줄 문자열이 요긴한 분야로 테스트를 꼽을 수 있다. 테스트에서는 여러 줄의 텍스트 출력을  
  만들어내는 연산을 실행하고, 그 결과를 예상 결과와 비교해야 하는 경우가 자주 있다. 여러 줄 문자열은  
  테스트의 예상 출력을 작성할 때 가장 완벽한 해법이다. 복잡하게 escape를 쓰거나 외부 파일에서 텍스트를  
  불러올 필요가 없다. 단지 3중 따옴표 사이에 HTML이나 텍스트를 넣으면 된다. 그리고 소스코드에서 더 보기  
  좋게 하려면 앞에서 본 `trimMargin()` 확장 함수를 사용하면 된다.

---
