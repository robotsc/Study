# 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

- 이번에는 컬렉션을 처리할 때 쓸 수 있는 코틀린 표준 라이브러리의 함수 몇 가지를 살펴보자.  
  그 과정에 아래와 같은 코틀린 언어 특성을 볼 수 있다.

  - vararg 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다.
  - 중위(infix) 함수 호출 구문을 사용하면 인자가 하나뿐인 메소드를 쉽게 호출할 수 있다.
  - 구조 분해 선언(destructuring declaration)을 사용하면 복합적인 값을 분해해서  
    여러 변수에 나눠 담을 수 있다.

## Java 컬렉션 API 확장

- 앞서 코틀린 컬렉션은 Java와 같은 클래스를 사용하지만, 더 확장된 API를 제공한다 했다.  
  그리고 리스트의 마지막 원소를 가져오는 예시와 숫자로 이뤄진 컬렉션의 최대값을 찾는 코드를  
  보았다.

```kt
val strings: List<String> = listOf("first", "second", "third")
strings.last()
// "third"

val numbers: Collection<Int> = setOf(1, 14, 2)
numbers.max()
// 14
```

- 이런 코드가 어떻게 작동할 수 있을까? 어떻게 Java 라이브러리 클래스의 인스턴스인 컬렉션에  
  대해 코틀린이 새로운 기능을 추가할 수 있을까? `last()`와 `max()`는 모두 확장함수 였던 것이다.

- `last()`는 앞서 `String`에 정의했던 `lastChar()`보다 복잡하지 않다. `last()`는 `List`의  
  확장함수다. `max()`의 경우에는 더 단순하게 정리한 선언을 보았다.

```kt
fun <T> List<T>.last(): T { /* find the last element */ }
fun Collection<Int>.max(): Int { /* find the max element */ }
```

- 코틀린 표준 라이브러리는 수많은 확장 함수를 포함하므로 여기서 그 모두를 볼 수는 없다.  
  코틀린 표준 라이브러리를 모두 다 알 필요는 없다. 필요할 때마다 IDE의 코드 자동 완성 기능 또는  
  API를 직접 보는 편이 훨씬 낫다.

---

## 가변 인자 함수

- 맨 처음에는 `arrayListOf()`, `hashSetOf()` 등 컬렉션을 만들어내는 함수들을 몇 가지 보았다.  
  이런 함수들의 공통적인 특징은 바로 인자의 개수가 그때그때 달라질 수 있다는 점이다.  
  파라미터 개수가 달라질 수 있는 함수를 정의하는 방법을 살펴보자.

```kt
val list = listOf(1, 2, 3)
```

- 위처럼 리스트를 생성하는 함수를 호출할 때 원하는 만큼 원소를 전달할 수 있다.  
  `listOf()`의 정의를 보자.

```kt
fun listOf<T>(varargs values: T): List<T> { /* ... */ }
```

- Java의 가변 길이 인자(varargs)와 같이, 가변 길이 인자는 메소드를 호출할 때 원하는 개수 만큼  
  인자를 넘기면 Java 컴파일러가 배열에 그 값들을 넣어준다. 코틀린의 가변 길이 인자도 Java와 비슷하다.  
  다만 문법이 조금 다를 뿐이다. 타입 뒤에 `...`를 붙이는 대신, 코틀린에서는 파라미터 앞에 vararg  
  변경자를 붙인다.

- 이미 배열에 들어있는 원소를 가변 길이 인자로 넘길 때도 코틀린과 Java 구문이 다르다. Java에서는 배열을  
  그냥 넘기면 되지만, 코틀린에서는 배열을 명시적으로 풀어서 배열의 각 원소가 인자로 전달되게 해야 한다.  
  기술적으로는 스프레드 연산자(spread operator)가 그런 작업을 해준다. 하지만 실제로는 전달하려는 배열  
  앞에 `*`를 붙이기만 하면 된다.

```kt
fun main(args: Array<String>) {
    val list = listOf("list: ", *args)
    println(list)
}
```

- 위 코드는 스프레드 연산자를 통해 배열에 들어 있는 값과 다른 여러 값을 함께 써서 함수를 호출할 수 있음을  
  보여준다. 이런 기능은 Java에서는 사용할 수 없다.

---

## 중위 호출과 구조 분해 선언

- `Map`을 만들려면 `mapOf()`를 사용한다.

```kt
val map = mapOf(1 to "one", 2 to "two", 3 to "three")
```

- 위 코드의 to는 코틀린 키워드가 아니다. 이 코드는 **중위 호출(infix call)** 이라는 특별한 방식으로  
  `to()`라는 일반 메소드를 호출한 것이다.

- 중위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드명을 넣는다.  
  (이때 객체, 메소드명, 유일한 인자 사이에는 공백이 들어가야 한다.) 아래 두 호출을 동일하다.

```kt
1.to("one")
1 to "one"
```

- 인자가 하나뿐인 메소드나 인자가 하나뿐인 확장함수에 중위 호출을 사용할 수 있다.  
  함수(메소드)를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수 선언에 추가해야 한다.  
  아래는 `to()`의 정의를 간략하게 줄인 코드다.

```kt
infix fun Any.to(other: Any) = Pair(this, other)
```

- 이 `to()` 함수는 `Pair`의 인스턴스를 반환한다. `Pair`는 코틀린 표준 라이브러리 클래스로, 그 이름대로  
  두 원소로 이뤄진 순서쌍을 표현한다. 실제로 `to()`는 제네릭 함수지만, 여기서는 설명을 위해 그런 세부  
  사항을 생략했다.

- `Pair`의 내용으로 두 변수를 즉시 초기화할 수 있다.

```kt
val (number, name) = 1 to "one"
```

- 이런 기능을 **구조 분해 선언(Destructuring Declaration)** 이라 한다.  
  `Pair` 인스턴스 외 다른 객체에도 구조 분해를 적용할 수 있다. 예를 들어, key와 value라는 두 변수를 `Map`의  
  원소를 사용해 초기화할 수 있다.

- Loop 에서도 구조 분해 선언을 활용할 수 있다. 이전에 `joinToString()`에서 본 `withIndex()`를 구조 분해  
  선언과 조합하면 컬렉션 원소의 인덱스와 값을 따로 변수에 담을 수 있다.

```kt
for((index, element) in list.withIndex()) {
    println("$index: $element")
}
```

- 마지막으로 `mapOf()`를 간단히 보자.

```kt
fun <K, V> mapOf(vararg values: Pair<K, V>): Map<K, V>
```

---
