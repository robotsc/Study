# 라이브러리를 익히고 사용하라

- 무작위 정수 하나를 생성하고 싶다고 해보자. 값의 범위는 0부터 명시한 수 사이다.  
  아주 흔히 마주치는 문제로, 많은 프로그래머가 아래와 같은 짤막한 메소드를 만들곤 한다.

```java
static Random random = new Random();

static int random(int n) {
  return Math.abs(random.nextInt()) % n;
}
```

- 괜찮은 듯 보여도 문제를 세 가지나 포함하고 있다.

  - 첫째, n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.
  - 둘째, n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환된다.

- 아래 코드는 예시를 위한 코드이다.

```java
public static void main(String[] args) {
  int n = 2 * (Integer.MAX_VALUE / 3);
  int low = 0;
  for(int i = 0; i < 1000000; i++) {
    if(random(n) < n / 2) {
      low++;
    }
  }
  System.out.println(low);
}
```

- `random()`이 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제로 돌려보면  
  666,666에 가까운 값을 얻는다. 무작위로 생성된 수 중에서 2/3 가량이 중간값보다 낮은 쪽으로  
  쏠린 것이다.

- `random()`의 세 번째 결함으로, 지정한 범위 _'바깥'_ 의 수가 종종 튀어나올 수 있다.  
  `random.nextInt()`가 반환한 값을 `Math.abs()`를 이용해 음수가 아닌 정수로 매핑하기 때문이다.  
  `nextInt()`가 `Integer.MIN_VALUE`를 반환하면 `Math.abs()`도 `Integer.MIN_VALUE`를  
  반환하고, 나머지 연산자(`%`)는 음수를 반환해버린다.(n이 2의 제곱수가 아닐 때)  
  이렇게 되면 이 메소드를 사용하는 프로그램은 실패할 것이고, 문제를 해결하고 싶어도 현상을 재현하기가  
  쉽지 않을 것이다.

- 이 결함을 해결하려면 의사난수 생성기, 정수론, 2의 보수 계산 등에 조예가 깊어야 한다.  
  다행이 우리가 직접 해결할 필요는 없다. `Random.nextInt(int)`가 이미 해결했기 때문이다.  
  이 메소드의 자세한 동작 방식은 몰라도 된다. 알고리즘에 능통한 개발자가 설계와 구현, 검증에 시간을 들여  
  개발했고, 이 분야의 여러 전문가가 잘 동작함을 검증했다. 그리고 이 라이브러리가 릴리즈된 후 20년 가까이  
  수백만의 개발자가 열심히 사용했지만 버그가 보고된 적이 없다. 혹시 버그가 발견되더라도 다음 릴리즈에서  
  수정될 것이다. **표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 우리보다 앞서 사용한 다른**  
  **프로그래머들의 경험을 활용할 수 있다.**

- Java7부터는 `Random`을 더이상 사용하지 않는 게 좋다. **`ThreadLocalRandom`으로 대체하면 대부분**  
  **잘 작동한다.** `Random`보다 더 고품질의 무작위 수를 생성할 뿐 아니라 속도도 더 빠르다.  
  한편, fork-join 풀이나 병렬 스트림에서는 `SplittableRandom`을 사용하자.

- 표준 라이브러리를 쓰는 두 번째 이점은 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도  
  된다는 것이다. 프로그래머들은 하부 공사를 하기보다는 애플리케이션 기능 개발에 집중하고 싶어한다.

- 세 번째 이점은 따로 노력하지 않아도 성능이 지속해서 개선된다는 점이다. 사용자가 많고, 업계 표준 벤치마크를  
  사용해 성능을 확인하기 때문에 표준 라이브러리 제작자들은 더 나은 방법을 꾸준히 모색할 수밖에 없다.  
  Java 플랫폼 라이브러리의 많은 부분이 수 년에 걸쳐 지속해서 다시 작성되며, 때로는 성능이 극적으로  
  개선되기도 한다.

- 네 번째 이점은 기능이 점점 많아진다는 것이다. 라이브러리에 부족한 부분이 있다면 개발자 커뮤니티에서 이야기가  
  나오고 논의된 후 다음 릴리즈에 해당 기능이 추가되곤 한다.

- 마지막 이점은 우리가 작성한 코드가 많은 사람에게 낯익은 코드가 된다는 것이다. 자연스럽게 다른 개발자들이 더  
  읽기 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 된다.

- 이상의 이점들에 비춰볼 때 표준 라이브러리의 기능을 사용하는 것이 좋아보이지만, 실상은 많은 프로그래머가  
  직접 구현해 쓰고 있다. 왜 그럴까? 아마도 라이브러리에 그런 기능이 있는지 모르기 때문일 것이다.  
  **메이저 릴리즈마다 주목할 만한 수많은 기능이 라이브러리에 추가된다.**  
  이러한 확실한 예시를 보기 위해, 지정한 URL의 내용을 가져오는 명령줄 애플리케이션을 작성해보자.  
  리눅스의 curl 명령과 비슷하다. 예전에는 작성하기가 까다로운 기능이었지만, Java9에서 `InputStream`에  
  추가된 `transferTo()` 메소드를 사용하면 쉽게 수현할 수 있다. 아래는 이를 이용해 기능을 완벽히  
  구현한 코드다.

```java
public static void main(String[] args) throws IOException {
  try (InputStream in = new URL(args[0]).openStream()) {
    in.transferTo(System.out);
  }
}
```

- 라이브러리가 너무 방대해 모든 API 문서를 파악하기 힘들겠지만,  
  **`java.lang`, `java.util`, `java.io`와 그 하위 패키지들에는 익숙해져야 한다.**  
  다른 라이브러리들은 필요할 때마다 익혀도 좋다. 라이브러리는 매년 아주 빠르게 성장하고 있으니 모든  
  기능을 요약하는 것은 무리다.

- 하지만 언급해둘만한 라이브러리는 몇 개 있다. 컬렉션 프레임워크와 스트림 라이브러리다.  
  `java.util.concurrent`의 동시성 기능도 마찬가지로 알아두면 큰 도움이 된다.  
  이 패키지는 멀티스레드 프로그래밍 작업을 단순화해주는 고수준의 편의 기능은 물론, 능숙한 개발자가  
  자신만의 고수준 개념을 직접 구현할 수 있도록 도와주는 저수준 요소들을 제공한다.

- 때때로 라이브러리가 필요한 기능을 충분히 제공해주지 못할 수도 있다. 더 전문적인 기능을 요구할수록  
  이런 일이 더 자주 발생할 것이다. 우선은 라이브러리를 사용하려 시도해보자. 어떤 영역의 기능을 제공하는지  
  살펴보고, 원하는 기능이 아니라 판단되면 대안을 사용하자. 어떤 라이브러리든 제공하는 기능은 유한하므로  
  항상 빈 구멍이 있기 마련이다. Java 표준 라이브러리에서 원하는 기능을 찾지 못하면, 그 다음 선택지는  
  고품질의 서드 파티 라이브러리가 될 것이다. 그래도 없다면 다른 선택이 없으니 직접 구현하자.

---

## 핵심 정리

- 바퀴를 다시 발명하지 말자. 아주 특별한 나만의 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을  
  가능성이 크다. 그런 라이브러리가 있다면, 쓰면 된다. 있는지 모르겠다면 우선 찾아보자. 일반적으로  
  라이브러리 코드는 우리가 직접 작성한 것보다 품질이 좋고, 점차 개선될 가능성이 크다.

---
