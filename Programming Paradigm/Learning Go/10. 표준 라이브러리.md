# 표준 라이브러리

## 입출력 관련 기능

- Go의 입출력 철학의 중심은 `io` 패키지에서 찾아볼 수 있다.  
  특히 해당 패키지에 정의된 `io.Reader`와 `io.Writer`는 Go에서 두세번째로 많이 사용되는 인터페이스일 것이다.  
  이 인터페이스들은 각각 단일 메소드로 정의되어 있다.

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
```

- `io.Writer` 인터페이스의 `Write()` 메소드는 인터페이스의 구현에 쓰여지는 byte slice를 인자로 받는다. 그리고 쓰여진 byte의  
  수와 잘못된 경우 오류를 반환한다. `io.Reader`의 `Read()`는 더 흥미로운데, 반환 파라미터를 통해 데이터를 반환받는 것보다  
  slice 입력 파라미터를 구현으로 전달하고 수정한다. 그리고 `len(p)`만큼 byte만큼 slice에 쓰일 것이다.  
  아마도 아래와 같은 것을 기대했기에 조금 어색해보일 수 있다.

```go
type NotHowReaderIsDefined interface {
	Read() (p []byte, err error)
}
```

- `io.Reader`의 `Read()`가 이렇게 구현된 데는 괜찮은 이유가 있다. `io.Reader`가 동작하는 방식을 이해하기 위한 대표적인 함수를 보자.

```go
func countLetters(r io.Reader) (map[string]int, error) {
	buf := make([]byte, 2048)
	out := map[string]int{}
	for {
		n, err := r.Read(buf)
		for _, b := range buf[:n] {
			if(b >= 'A' && b <= 'Z') || (b >= 'a' && b <= 'z') {
				out[string(b)]++
			}
		}
		if err == io.EOF {
			return out, nil
		}
		if err != nil {
			return nil, err
		}
	}
}
```

- 위 함수는 일단 buffer를 하나 생성하고 `r.Read()`를 호출할 때마다 재사용한다. 잠재적으로 큰 데이터 소스에서 읽기 위해 단일  
  메모리 할당을 사용하도록 한다. 만약 `Read()`가 `[]byte`를 반환하도록 설계되어 있다면, 매 단일 호출마다 새로운 할당이 필요할  
  것이다. 할당은 heap memory의 끝에 도달할 것이고, GC가 꽤 많은 작업을 수행하도록 할 것이다.

- 할당을 더 줄이려면 프로그램이 시작할 때 buffer pool을 생성하도록 하면 된다. 그런 다음 함수가 시작할 때 pool에서 buffer를  
  가져오고, 종료될 때 반환한다. `io.Reader`에 slice를 전달해 메모리 할당을 개발자의 통제 하에 둘 수 있는 것이다.

- 다음으로 buffer에 얼마나 많은 byte가 쓰였는지를 알기 위해 `r.Read()`에서 반환된 n 값을 사용해 buf slice의 하위 slice를  
  순회하면서 읽은 데이터를 처리할 수 있다.

- 마지막으로 `r.Read()`에서 `io.EOF` 오류가 반환되면, r이 수행할 모든 읽기 작업은 완료되었다고 판단한다. 이는 `io.Reader`에서  
  읽을 데이터가 남아있지 않다는 의미이기 때문이다. `io.EOF`가 반환되면 처리를 완료하고 결과를 반환한다.

- 여기에 `io.Reader`의 `Read()` 메소드에 관한 일반적이지 않은 것이 하나 있다. 함수나 메소드가 반환값으로 오류를 반환하는 대부분의  
  경우는 처리하기 전에 오류가 아닌 값이 반환된 것인지 확인한다. Data stream의 끝이나 예상치 못한 조건에서 발생한 오류 전에 읽은  
  데이터가 있을 수 있기 때문에, `Read()`를 위해서는 반대로 처리한다.

- `io.Reader`와 `io.Writer`는 아주 간단한 인터페이스이기에 다양한 방식으로 구현될 수 있다.  
  예를 들어 아래의 `strings.NewReader()` 함수를 사용해 문자열로부터 `io.Reader`를 생성할 수 있다.

```go
func foo() error {
	s := "The quick brown fox jumped over the lazy dog"
	sr := strings.NewReader(s)
	counts, err := countLetters(sr)
	if err != nil {
		return err
	}
	fmt.Println(counts)
	return nil
}
```

- 이전에 본 것 같이 `io.Reader`와 `io.Writer`의 구현은 종종 decorator 패턴으로 함께 연결된다. `countLetters()`는  
  `io.Reader`에 의존적이기 때문에 gzip으로 압축된 파일에서 영문자의 개수를 세기 위해 정확히 같은 `countLetters()` 함수를 사용할 수 있다.  
  첫 번째로, 파일 이름이 주어질 때 `*gzip.Reader` 클라이언트를 반환하는 함수를 작성해보자.

```go
func buildGZipReader(fileName string) (*gzip.Reader, func(), error) {
	r, err := os.Open(fileName)
	if err != nil {
		return nil, nil, err
	}
	gr, err := gzip.NewReader(r)
	if err != nil {
		return nil, nil, err
	}
	return gr, func() {
		gr.Close()
		r.Close()
	}, nil
}
```

- 위 함수는 `io.Reader`를 구현한 타입을 알맞게 wrapping하는 방법을 보여준다. `*os.File`(`io.Reader` 인터페이스를 만족하는)를  
  생성하고 유효한지 확인한 뒤, `*gzip.Reader` 인스턴스를 반환하는 `gzip.NewReader()`에 넘긴다. 유효하다면 `*gzip.Reader`와  
  `*os.File`이 실행했을 때, 자원을 알맞게 정리해주는 파일 닫기 클로저를 반환한다.

- `*gzip.Reader`는 `io.Reader`를 구현하기에 이전에 `*strings.Reader`로 사용한 것과 같이 `countLetters()`에서 사용할 수 있다.

```go
func bar() error {
	r, closer, err := buildGZipReader("someFile.gz")
	if err != nil {
		return err
	}
	defer closer()
	counts, err := countLetters(r)
	if err != nil {
		return err
	}
	fmt.Println(counts)
	return nil
}
```

- 읽기와 쓰기를 위한 표준 인터페이스를 가지기에 `io` 패키지 내에서 `io.Reader`에서 `io.Writer`로 복사하기 위한 `io.Copy()`라는  
  표준 함수도 제공한다. 기존 `io.Reader`와 `io.Writer` 인스턴스에 새로운 기능을 추가하기 위한 다른 표준 함수도 있다..

  - `io.MultiReader()`: 여러 `io.Reader` 인스턴스에서 차례대로 읽는 `io.Reader` 반환
  - `io.LimitReader()`: 제공된 `io.Reader`에서 특정 byte 수만큼만 읽어들이는 `io.Reader` 반환
  - `io.MultiWriter()`: 동시에 여러 `io.Writer` 인스턴스에 쓰기를 수행하는 `io.Writer` 반환

- 표준 라이브러리의 다른 패키지들은 `io.Reader`, `io.Writer`와 작업하기 위한 자체 타입과 함수를 제공한다.  
  이들은 대부분 압축 알고리즘, 기록, 암호화, buffer, byte slice 그리고 문자열을 다룬다,.

- `io`에서 정의한 `io.Closer`나 `io.Seeker`와 같은 단일 메소드로 이뤄진 인터페이스도 있다.

```go
type Closeable interface {
	Close() error
}

type Seekable interface {
	Seek(offset int64, whence int) (int64, error)
}
```

- `io.Closer` 인터페이스는 읽기와 쓰기가 완료되었을 때 정리할 필요가 있는 `os.File`과 같은 타입에서 구현된다.  
  대부분 `Close()`는 defer를 통해 호출한다.

```go
f, err := os.Open(fileName)
if err != nil {
	return nil, err
}
defer f.Close()
// Use f
```

- `io.Seeker` 인터페이스는 자원의 임의 접근을 위해 사용된다. 인자 중 whence의 유효한 값은 `io.SeekStart`, `io.Seekcurrent`,  
  `io.SeekEnd` 상수이다. 이는 사용자 지정 타입을 사용해 더 명확히 운영이 되었어야 하지만, 설계 상의 실수로 int 타입이 되었다.

- `io` 패키지는 다양한 방법으로 이런 4개의 인터페이스를 결합시키는 인터페이스를 정의한다. 이런 인터페이스로는 `io.ReadCloser`,  
  `io.ReadSeeker`, `io.ReadWriteCloser`, `io.ReadWriteSeeker`, `io.ReadWriter`, `io.WriteCloser`, `io.WriteSeeker`가 있다.

- 함수가 데이터를 갖고 어떤 행동을 하는지를 지정하기 위해 위와 같은 인터페이스들을 사용한다. 예를 들어, 파라미터로 `os.File`을 사용하는  
  것이 아니라, 파라미터로 어떤 일을 할 것인지 정확히 지정하기 위해 이러한 인터페이스를 사용하는 것이 좋다. 이렇게 하면 함수를 더 범용적으로  
  만들 뿐만 아니라 의도를 더 명확히 표현할 수 있다. 또한 자체적으로 데이터 소스와 싱크를 작성하는 경우, 코드를 이러한 인터페이스와 호환되도록  
  만들어야 한다. 일반적으로 `io`에 정의된 인터페이스처럼 단순하고 분리된 인터페이스를 만들기 위해 노력해야 한다.

- `ioutil` 패키지는 byte slice로 전체를 읽어들이는 `io.Reader`의 구현체, 파일에 읽기와 쓰기, 그리고 임시 파일로 동작하는 것과 같은  
  것들을 수행하기 위한 몇 가지 간단한 유틸리티를 제공한다. `ioutil.ReadAll()`, `ioutil.ReadFile()` 및 `ioutil.WriteFile()` 함수는  
  작은 데이터 소스를 위해서는 괜찮지만, 큰 데이터 소스를 위해서는 `bufio` 패키지에 있는 `bufio.Reader`, `bufio.Writer` 및  
  `bufio.Scanner`를 사용하는 것이 좋다.

- `ioutil`가 주는 또다른 장점으로는 Go 타입에 새로운 함수를 추가하기 위한 패턴을 보여준다는 것이 있다. `io.Reader`를 구현하는 타입을  
  가지지만 `io.Closer`는 없고, `io.ReadCloser`를 기대하는 함수에 그것을 전달해줄 필요가 있는 경우, `ioutil.NopCloser`로  
  `io.Reader`를 전달해 `io.ReadCloser`가 구현된 타입으로 될 수 있다.

```go
type NopCloser struct {
	io.Reader
}

func (nopCloser) Close() error { return nil }

func NopCloser(r Reader) ReadCloser {
	return nopCloser{r}
}
```

- 위처럼 인터페이스를 충족하기 위해 언제든 타입에 추가적 메소드를 넣기 위해 구조체에 타입을 embedding하도록 하자.

---
