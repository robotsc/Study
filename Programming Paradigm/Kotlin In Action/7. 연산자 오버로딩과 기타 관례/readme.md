## 연산자 오버로딩과 기타 관례

- Java에는 표준 라이브러리와 밀접하게 연관된 언어 기능이 몇 가지 있다.  
  예를 들어, for..in loop에 `java.lang.Iterable`을 구현한 객체를 사용할 수 있으며  
  자원을 사용하는 try문(try-with-resources)에 `java.lang.Autoclosable`을 구현한 객체를 사용할 수 있다.

- 이와 비슷하게 코틀린에서도 어떤 언어 기능이 정해진 사용자 작성 함수와 연결되는 경우가 몇 가지 있다.  
  하지만 코틀린에서는 이런 언어 기능이 어떤 타입(클래스)과 연관되기보다는, 특정 함수이름과 연관된다.  
  예를 들어 어떤 클래스 안에 plus라는 이름의 특별한 메소드를 정의하면, 그 클래스 인스턴스에 대해 `+` 연산자를  
  사용할 수 있다. 이런 식으로 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는  
  **관례(convention)** 라 한다.

- 언어 기능을 타입에 의존하는 Java와 달리, 코틀린은 함수 이름을 통한 관례에 의존한다. 코틀린에서 이러한 관례를  
  채택한 이유는 기존 Java 클래스를 코틀린 언어에 적용하기 위함이다. 기존 Java 클래스가 구현하는 인터페이스는  
  이미 고정되어 있고 코틀린 쪽에서 Java 클래스가 새로운 인터페이스를 구현하게끔 만들 수는 없다. 반면, 확장  
  함수를 사용하면 기존 클래스에 새로운 메소드를 추가할 수 있다. 따라서 기존 Java 클래스에 대해 확장 함수를  
  구현하면서 관례에 따라 이름을 붙이면 기존 Java 코드를 바꾸지 않아도 새로운 기능을 쉽게 부여할 수 있다.

---

## 요약

- 코틀린에서는 정해진 이름의 함수를 오버로딩함으로써 표준 수학 연산자를 오버로딩할 수 있다.  
  하지만 직접 새로운 연산자를 만들 수는 없다.

- 비교 연산자는 `equals()`와 `compareTo()`로 변환된다.

- 클래스에 `get()`, `set()`, `contains()`라는 함수를 정의하면 그 클래스 인스턴스에 대해 `[]`와  
  in 연산을 사용할 수 있고, 그 객체를 코틀린 컬렉션 객체와 비슷하게 다룰 수 있다.

- 미리 정해진 관례를 따라 `rangeTo()`, `iterator()`를 정의하면 범위를 만들거나 컬렉션과 배열의  
  원소를 이터레이션할 수 있다.

- 구조 분해 선언을 통해 한 객체의 상태를 분해해서 여러 변수에 대입할 수 있다.  
  함수가 여러 값을 한꺼번에 반환해야 하는 경우 구조 분해가 유용하다.  
  Data class에 대한 구조 분해는 바로 사용할 수 있지만, 일반 class 인스턴스에 대해 구조 분해를 사용하려면  
  `componentN()` 함수를 정의해야 한다.

- 위임 프로퍼티를 통해 프로퍼티 값을 저장하거나 초기화하거나 읽거나 변경할 때 사용하는 로직을 재활용할 수 있다.  
  위임 프로퍼티는 프레임워크를 만들 때 매우 유용하다.

- 표준 라이브러리 함수인 `lazy()`를 통해 지연 초기화 프로퍼티를 쉽게 구현할 수 있다.

- `Delegates.observable()` 함수를 사용하면 프로퍼티의 변경을 관찰할 수 있는 관찰자를 쉽게 추가할 수 있다.

- `Map`을 위임 객체로 사용하는 위임 프로퍼티를 통해 다양한 속성을 제공하는 객체를 유연하게 다룰 수 있다.

---
