# 대상의 이터레이션: while과 for loop

## while loop

- 코틀린에는 while과 do-while loop가 있다. 이 둘의 문법은 Java와 다르지 않다.

```kt
while (stmt) {
    //..
}

do {
    //..
} while (stmt)
```

- 이 두 루프는 매우 단순하며, 코틀린에서 추가한 새로운 기능도 없다.

---

## 수에 대한 이터레이션: 범위와 수열

- 코틀린에는 Java의 어떤 변수를 초기화하고 그 변수를 루프를 한 번 실행할 때마다 갱신하고, 루프 조건이  
  거짓이 될 때 반복을 마치는 형태의 for 루프에 해당하는 요소가 없다. 이런 loop의 가장 흔한 용례인  
  초기값, 증가값, 최종값을 사용한 루프를 대신하기 위해 코틀린에서는 범위(range)를 사용한다.

- 범위는 기본적으로 두 값으로 이뤄진 구간이다. 보통은 그 두 값은 정수 등의 숫자 타입의 값이며,  
  `..` 연산자로 시작 값과 끝 값을 연결해 범위를 만든다.

```kt
val oneToTen = 1..10
```

- 코틀린의 범위는 폐구간(닫힌 구간) 또는 양 끝을 포함하는 구간이다. 이는 두 번째 값(위 코드에서 10)이  
  항상 범위에 포함된다는 뜻이다.

- 정수 범위로 수행할 수 있는 가장 단순한 작업은 범위에 속한 모든 값에 대한 이터레이션이다.  
  이런 식으로 어떤 범위에 속한 값을 일정한 순서로 이터레이션하는 경우를 수열(progression)이라 한다.

- Fizz-Buzz 게임을 구현해보자. 인자가 없는 when을 사용해 조건을 검사한다.

```kt
fun fizzBuzz(i: Int) = when {
    i % 15 == 0 -> "FizzBuzz"
    i % 3 == 0 -> "Fizz"
    i % 5 == 0 -> "Buzz"
    else -> "$i"
}

for (i in 1..100) {
    print(fizzBuzz(i))
}
```

- 이번에는 100부터 1까지 거꾸로 세지만, 짝수만으로 게임을 진행해보자.

```kt
for (i in 100 downTo 1 step 2) {
    println(fizzBuzz(i))
}
```

- 여기서는 증가 값인 step을 갖는 수열에 대해 이터레이션한다. 증가 값을 사용하면 수를 건너뛸 수 있다.  
  증가 값을 음수로 만들면 정방향 수열이 아닌 역방향 수열을 만들 수 있다. 위 코드에서  
  `100 downTo 1`은 역방향 수열을 만든다. 그 뒤에 `step 2`를 붙이면 증가 값의 절대값이 2로 바뀐다.  
  즉 100, 98, 96, 94, .. 이렇게 가게 된다.

- 앞서 말한 대로 `..`은 항상 범위의 끝 값을 포함한다. 하지만 끝 값을 포함하지 않는 반만 닫힌 범위  
  (half-closed range)에 대해 이터레이션하면 편할 때가 자주 있다. 그런 범위를 만들고 싶다면  
  until 함수를 사용하자. 예를 들어 `for(x in 0 until size)`라는 루프는 `for(x in 0..size-1)`과  
  같지만, 조금 더 명확하게 개념을 표현한다.

---

## 맵에 대한 이터레이션

- 컬렉션에 대한 이터레이션을 위해서는 `for .. in` loop를 자주 쓴다. 이런 for loop는  
  Java와 마찬가지로 작동하기 때문에 볼 내용이 많지 않다. 대신 `Map`에 대한 이터레이션을 살펴보자.

- 예시로 문자에 대한 2진 표현을 출력하는 프로그램을 보자. 이때, 2진 표현은 `Map`에 저장된다.  
  아래 코드는 `Map`을 만들고, 몇 글자에 대한 2진 표현으로 맵을 채운다음, 그 맵의 내용을 출력한다.

```kt
val binaryReps = TreeMap<Char, String>()

for (c in 'A'..'F') {
    val binary = Integer.toBinaryString(c.toInt())
    binaryReps[c] = binary
}

for((letter, binary) in binaryReps) {
    println("$letter = $binary")
}
```

- 위 코드처럼 `..` 연산자를 숫자 타입의 값 뿐만 아니라 문자 타입의 값에도 적용할 수 있다.  
  `'A'..'F'`는 A부터 F에 이르는 문자를 모두 포함하는 범위를 만든다.

- 위 코드는 for loop를 사용해 이터레이션하려는 컬렉션의 원소를 푸는 방법을 보여준다.  
  원소를 풀어 key는 letter, value는 binary라는 두 변수에 저장한다.

- 또한 위 코드는 key를 사용해 `Map` 내의 value를 가져오거나, key에 해당하는 값을 설정하는  
  멋진 코틀린 기능도 보여준다. `get()`, `put()` 대신 `map[key]`나 `map[key] = value`를  
  사용해 값을 가져오고 설정할 수 있다.

```kt
binaryReps[c] = binary
```

- 위 코드의 Java 버전은 아래와 같다.

```kt
binaryReps.put(c, binary);
```

- `Map`에 대해 사용했던 구조 분해 구문은 `Map`이 아닌 컬렉션에도 활용할 수 있다.  
  그런 구조 분해 구문을 사용하면 원소의 현재 인덱스를 유지하면서 컬렉션을 이터레이션할 수 있다.  
  인덱스를 저장하기 위한 변수를 별도로 선언하는 등의 작업은 필요 없다.

```kt
val list = arrayListOf("10", "11", "1001")
for((index, element) in list.withIndex()) {
    println("$index: $element")
}
```

---

## in 으로 컬렉션이나 범위의 원소 검사

- in 연산자를 사용해 어떤 값이 범위에 속하는지를 검사할 수 있다. 반대로 `!in`을 사용하면  
  어떤 값이 범위에 속하지 않은지를 검사할 수 있다. 아래 코드는 어떤 문자가 정해진  
  문자의 범위에 속하는지를 검사하는 방법 중 하나다.

```kt
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
fun isNotDigit(c: Char) = c !in '0'..'9'
```

- 이렇게 하면 어떤 문자가 글자인지를 검사하는 방법은 간단해보인다. 내부적으로도 교묘한 부분이 없다.  
  이렇게 코드를 작성해도 여전히 문자의 코드가 첫 번째 글자의 코드와 마지막 글자의 코드 사이에  
  있는지를 비교한다. 하지만 이런 비교 로직은 표준 라이브러리의 범위 클래스 구현 내에 깔끔하게  
  갑춰져 있다.

> `c in 'a' .. 'z'`는`'a' <= c && c <= 'z'`로 변환된다.

- `in`과 `!in` 연산자를 when 식에서 사용해도 된다.

```kt
fun recognize(c: Char) = when(c) {
    in '0'..'9' -> "It's a digit!"
    in 'a'..'z', in 'A'..'Z' -> "It's a letter!"
    else -> "I don't know…​"
}
```

- 범위는 문자에만 국한되지 않는다. `java.util.Comparable` 인스턴스를 구현했기에 비교가 가능한  
  클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수도 있다. `Comparable`을 사용하는 범위의  
  경우에는 그 범위 내의 모든 객체를 항상 이터레이션하지는 못한다. 예를 들어 "Java"와 "Kotlin" 사이의  
  모든 문자열을 이터레이션할 수는 없다. 하지만 in 연산자를 사용하면 값이 범위 안에 속하는지를 항상 결정할 수 있다.

```kt
println("Kotlin" in "Java".."Scala") // true
```

- `String`에 있는 `Comparable` 구현이 두 문자열을 알파벳 순서로 비교하기 때문에 위 코드의 in 검사에서도  
  문자열을 알파벳 순서로 비교한다. 컬렉션에도 마찬가지로 in 연산을 사용할 수 있다.

```kt
println("Kotlin" in setOf("Java", "Scala")) // false
```

---
