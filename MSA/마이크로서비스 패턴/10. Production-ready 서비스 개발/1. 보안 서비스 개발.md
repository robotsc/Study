# 보안 서비스 개발

- 애플리케이션 개발자는 주로 아래의 4가지 보안 요소를 구현해야 한다.

  - **인증(authentication)** : 애플리케이션에 접근하는 다른 애플리케이션이나 사람(주체, principal)의 신원을 확인한다.  
    일반적으로 사용자 ID/PW나 애플리케이션 API key/secret 등의 주체가 자격 증명으로 확인된다.

  - **인가(authorization)** : 주체가 어떤 데이터에 어떤 작업을 요청해 수행할 수 있는 권한이 있는지 확인한다.  
    보통 역할 기반(role-based) ACL(Access Control List)을 함께 사용한다. 역할 기반 보안은 사용자마다 하나 이상의  
    역할을 배정해 특정 작업의 호출 권한을 부여하고, ACL은 사용자 또는 역할을 대상으로 특정 비즈니스 객체나 aggregate에  
    작업할 권한을 부여한다.

  - **감사(auditing)** : 보안 이슈 탐지, compliance 시행, 고객 지원을 위해 주체가 수행하는 작업을 추적한다.

  - **보안 IPC** : 모든 서비스를 드나드는 통신이 TLS를 경유하는 것이 가장 이상적이다. 서비스 간 통신은 인증이 필요한 경우도 있다.

## 기존 모놀리틱 애플리케이션의 보안

- 예제 애플리케이션은 소비자, 배달원, 음식점 직원 등 다양한 사용자가 브라우저, 모바일 앱을 통해 접속한다. 누구나 애플리케이션에 접근하려면  
  먼저 로그인을 해야 한다. 아래 그림은 예제 애플리케이션의 클라이언트가 인증을 받고 요청을 하는 과정을 보여준다.

  ![picture 101](/images/MSAP_PRSD_1.png)

- 그림과 같이 사용자가 ID/PW를 입력하면 클라이언트는 사용자 자격 증명을 서버에 POST 요청한다. 서버는 자격 증명이 맞으면 해당 클라이언트에게  
  세션 토큰을 반환한다. 클라이언트는 이후 모든 요청에 이 세션 토큰을 포함시켜 전송한다.

- 아래 그림은 예제 애플리케이션에 구현된 보안을 고수준에서 바라본 모습을 나타낸다.

  ![picture 102](/images/MSAP_PRSD_2.png)

- 위 그림의 보안 아키텍쳐에서 핵심은 session이다. 주체의 ID와 역할이 세션에 보관된다. 세션은 세션 토큰으로 식별하며, 클라이언트는  
  요청할 때마다 세션 토큰을 함께 넣어 보낸다. 세션 토큰은 보통 암호학적으로 강력한 무작위 숫자 등으로 알아보기 어렵게 생성된다.

- Security context(보안 context) 역시 이 아키텍쳐의 주요 오소이다. 여기에는 현재 요청을 보낸 사용자의 정보가 담긴다.

- 이러한 모놀리틱 애플리케이션의 설계는 사실 보안을 구현할 수 있는 유일한 수단이다. 이러한 in-memory session의 한 가지 단점은 특정  
  세션의 요청을 모두 동일한 애플리케이션 인스턴스로 routing해야 한다는 것이다. 이러한 요건은 load balancing 및 작업을 복잡하게  
  만든다. 예를 들어 특정 애플리케이션 인스턴스를 종료하려면 session draining 메커니즘을 직접 구현해야 한다.  
  DB에 세션을 저장시키는 우회책도 있다.

- 서버 쪽 세션을 아예 없애버릴 수도 있다. 실제로 매 요청마다 API key/secret 등의 자격 증명을 제공하는 API 클라이언트가 있기 때문에  
  서버 쪽의 세션을 유지할 필요가 없는 애플리케이션도 많다. 아니면 세션 토큰에 세션 상태를 저장하는 방법도 있다. 그런데 MSA에서 왜  
  보안을 구현하기가 어려운걸까?

---

## MSA에서의 보안 구현

- MSA는 모든 외부 요청을 API Gateway와 하나 이상의 서비스가 처리하는 분산 시스템이며 API Gateway는 요청을 처리하기 위한 다른  
  서비스들을 호출한다. 이렇게 호출되는 서비스들은 각자 나름대로의 보안을 구성해야 한다. 예를 들어 주문 서비스는 소비자 본인의  
  주문 정보만 조회할 수 있게 해야하는데, 그러려면 인증/인가를 조합해야 한다. MSA에 보안을 구현하려면 먼저 사용자의 인증/인가를  
  누가 처리할지를 먼저 결정해야 한다.

- 그런데 MSA는 모놀리틱의 설계를 그대로 베껴 쓸 수는 없기 때문에 보안 구현이 어렵다. 모놀리틱에서 사용 가능했던 아래의 두 가지 보안  
  요소는 MSA에는 전혀 사용할 수 없다.

  - In-memory security context: Thread local 등의 in-memory security context를 사용해 사용자의 신원을 전달하는  
    방법이지만, MSA에서 서로 다른 서비스는 메모리를 공유할 수 없으므로 이 방법을 통해 사용자 신원을 전달할 수 없다.

  - Centralized session: In-memory security context를 사용하지 못하니 in-memory session 또한 마찬가지이다.  
    느슨한 결합 원칙에 위배되기는 하지만 이론상으로는 여러 서비스가 DB 기반의 세션에 접근하는 것은 가능하다.  
    하지만 MSA에는 전혀 다른 세션 메커니즘이 필요하다.

### API Gateway에서 인증 처리

- 인증을 처리하는 방법은 여러 가지가 있다. 먼저 서비스마다 알아서 사용자를 인증하는 방법이 있다. 이렇게 하면 미인증 요청이 내부 네트워크로  
  들어올 수 있고, 모든 개발자가 제대로 보안을 구현하리라 확신할 수 없기 때문에 보안 취약점이 노출될 위험성이 크다.

- 더구나 인증하는 방식은 클라이언트마다 제각각이다. 매 요청마다 basic authentication으로 자격 증명을 전송하는 순진한 클라이언트도 있고,  
  처음 한 번 로그인한 이후로는 요청할 때마다 세션 토큰을 발급하는 클라이언트도 있다. 이처럼 다양한 인증 메커니즘을 각 서비스가 모두 알아서  
  처리하게 두는 것은 무리이다.

- 따라서 요청을 서비스에 보내기 전, API gateway가 요청을 인증하는 것이 좋다. API Gateway에 인증 로직을 중앙화하면 나중에 문제가  
  생겨도 한 곳만 고치면 되기에 보안 취약점이 노출될 가능성이 현저히 줄어든다. 또한 다양한 인증 메커니즘을 API gateway가 전담해서  
  처리하므로 복잡한 코드도 서비스에서 감출 수 있다.

- API 클라이언트는 자격증명을 포함해 요청을 전송하고 API gateway는 이 요청을 인증한다. 로그인 기반 클라이언트는 사용자 자격 증명을  
  API Gateway에 전송한 후 세션 토큰을 발급받는다. API gateway는 요청을 인증한 후, 하나 이상의 서비스를 호출한다.

- API gateway로부터 호출받은 서비스는 요청 주체가 누구인지 알아야 하고, 인증을 마친 요청인지 아닌지 반드시 확인해야 한다.  
  이를 구현하기 위해 API gateway가 매번 서비스에 요청할 때마다 access token을 함께 넣어 보내도록 할 수 있다.  
  서비스는 이 토큰을 이용해 요청을 검증하거나 주체의 정보를 획득한다.

> Access token: API Gateway는 신원, 역할 등의 사용자 정보가 담긴 token을 자신이 호출하는 서비스에 전달한다.

![picture 103](/images/MSAP_PRSD_3.png)

### 인가 처리

- 클라이언트의 자격 증명을 인증하는 것도 중요하지만, 해당 클라이언트가 요청한 작업을 할 수 있도록 허가되어 있는지를 검사하는  
  인가(authorization) 메커니즘도 중요하다.

- 인가를 구현할 후보지로 API gateway를 선택해보자. 권한이 없는 사용자가 특정 path에 접근하는 경우, API gateway가 요청을  
  적절한 서비스로 forwarding하기 전에 간단히 거부하면 된다. 인증과 마찬가지로 인가 로직도 API gateway 내부에 중앙화하면 보안을  
  강화할 수 있다.

- 하지만 이렇게 API gateway에 인가 로직을 두면, API gateway와 서비스가 단단히 결합하게 되어 나중에 변경 사항이 생기면 서로  
  맞물리게 될 수 있다. 또한 API gateway는 역할 기반의 URL path 접근만 구현할 수 있으며, 개별 도메인 객체에 대한 접근 권한을  
  제어하는 ACL까지 구현하기는 무리이다. 이를 구현한다는 것은 API gateway가 서비스 도메인 로직의 세부 내용까지 알고 있다는 뜻이기 때문이다.

- 따라서 인가 로직은 서비스에 구현하는 것이 좋다. 서비스가 직접 역할 기반으로 URL, method를 인가하고 ACL로 aggregate으로의 접근을  
  따로 관리하도록 하는 것이다.

### JWT로 사용자 신원/역할 전달

- API Gateway는 어떤 종류의 토큰에 사용자 정보를 담아 서비스에 전달할지 결정해야 한다. 토큰 종류는 크게 두 가지로 나뉜다.  
  첫째로 opaque token(난독화 토큰)은 보통 UUID를 많이 사용해 구현한다. 성능 및 가용성이 떨어지고 latency가 길다는 것이 단점이다.  
  토큰의 수신자가 토큰의 유효성을 검증하고 보안 서비스를 동기 RPC로 호출해 사용자 정보를 조회해야 하기 때문이다.

- 둘째로 보안 서비스의 호출이 필요 없는 transparent token(투명 토큰)이 있다. JWT는 사실상 이 투명 토큰의 표준 규격이다.  
  두 당사자 간의 사용자 신원/역할 등의 정보를 안전하게 표현하는 표준 수단인 것이다. 사용자 정보, 만료 일자 등 각종 metadata가 포함된 JSON  
  객체를 payload에 담아 JWT 생성자(ex. API gateway)와 JWT 수신자(ex. 서비스)만 알 수 있는 secret key로 서명한다.  
  덕분에 악의적인 제3자가 JWT를 위조, 변조하는 것은 사실상 불가능하다.

- 하지만 JWT는 토큰 자체가 포함되어 있어 취소할 수 없다는 문제가 있다. 서비스가 JWT signature과 만료 일자를 확인한 후 요청받은 작업을  
  수행하는 구조라 토큰이 악의적인 제3자에게 넘어가더라도 이를 무력화할 방법이 마땅치 않다. 해결 방법은 유효 기간이 짧은 JWT를 발급해 사용하는  
  것이다. JWT가 최대한 가까운 미래에 만료되도록 설정하면 제3자가 JWT를 탈취하더라도 뭔가 해볼 수 있는 시간이 제약될 것이다.  
  그런데 이렇게 수명이 짧은 JWT를 발행하면 애플리케이션이 세션을 유지하기 위해 계속해서 JWT를 재발행해야 할 것이다.  
  다행이 이러한 문제는 OAuth 2.0이라는 보안 표준을 적용해 해결할 수 있다.

### OAuth 2.0 응용

- 자격 증명, 역할 등의 사용자 정보를 DB로 관리하는 사용자 서비스를 구현하다고 해보자. API gateway는 이 사용자 서비스를 호출해 클라이언트의  
  요청을 인증하고 JWT를 획득한다.

- 이런 종류의 보안 인프라는 다행이 직접 개발할 필요가 없고, OAuth 2.0 표준이 제대로 구현된 기성 서비스나 프레임워크를 가져다 사용하면 된다.  
  OAuth 2.0은 Github, Google 등의 public cloud service의 사용자가 자신의 정보에 접근하려는 3rd party 애플리케이션을 패스워드의  
  노출 없이 허가할 수 있는 방안을 찾다가 정착된 인증 프로토콜이다.

- 이렇게 OAuth 2.0은 처음에는 public cloud service의 접근 인가 수단으로 사용되었지만, 여느 애플리케이션의 인증/인가 용도로도  
  사용할 수 있다. MSA에 OAuth 2.0 프로토콜을 적용해 보안을 구현해보자.

- 아래는 OAuth 2.0의 핵심 개념이다.

  - **Authorization server(인증 서버)** : 사용자 인증 및 access/refresh token 획득 API를 제공한다.
  - **Access token(액세스 토큰)** : 리소스 서버에 대한 접근을 허가하는 토큰이다.
  - **Refresh token(리프레시 토큰)** : 클라이언트가 새로운 access token을 얻기 위해 필요한 token이다.  
    수명은 길지만 취소 가능한(revocable) 토큰이다.
  - **Resource server(리소스 서버)** : Access token으로 접근을 허가하는 서비스이다. MSA에서는 MSA를 구성하는 다양한 서비스들이  
    리소스 서버가 된다.
  - **클라이언트** : 리소스 서버에 접근하려는 클라이언트이다. MSA에서는 API gateway가 바로 OAuth 2.0 클라이언트이다.

- API 클라이언트를 인증하는 방법을 살펴보자.  
  아래 그림은 API gateway가 인증하는 과정을 나타낸다. API gateway는 OAuth 2.0 인증 서버에 요청해 access token을 발급받는  
  방식으로 API 클라이언트를 인증한다. 그런 다음 API gateway는 해당 서비스에 access token을 포함시켜 하나 이상의 요청을 한다.

  ![picture 104](/images/MSAP_PRSD_4.png)

- 이벤트 순서는 아래와 같다.

  - (1) 로그인 기반의 클라이언트가 자격 증명을 API gateway에 POST한다.
  - (2) API gateway의 로그인 핸들러는 OAuth 2.0 인증 서버로 패스워드 승인을 요청한다.
  - (3) 인증 서버는 클라이언트의 자격 증명을 검증한 후 access/refresh token을 반환한다.
  - (4) API gateway는 인증 서버에서 받은 두 개의 토큰을 클라이언트에게 반환한다.
  - (5) 클라이언트는 API gateway에 요청할 때마다 access/refresh token을 실어 보낸다.
  - (6) API gateway의 세션 인증 인터셉터는 access token을 검증한 후 서비스에 실어 보낸다.

- Access token이 이미(또는 거의) 만료된 경우, API gateway는 인증 서버에 OAuth 2.0 Refresh Grant를 요청해 access token을  
  새로 발급받는다. Refresh token이 아직 만료/해지 전이라면 인증 서버는 access token을 새로 만들어 반환하며, API gateway는 새로운  
  access token을 서비스에 전달하고 클라이언트에게 반환한다.

- OAuth 2.0이 MSA의 유일한 보안 수단은 아니지만, 어떻게 보안을 구현하든 아래의 3개 기본 사상은 동일하다.

  - API gateway는 클라이언트 인증을 담당한다.
  - API gateway 및 서비스는 transparent token(ex. JWT)을 이용해 주체의 정보를 주고받는다.
  - 서비스는 토큰을 이용해 주체의 신원/역할 정보를 획득한다.

---
